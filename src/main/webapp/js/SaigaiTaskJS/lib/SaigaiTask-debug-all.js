// generated by SaigaiTaskJS/build/build.bat
/* Copyright (c) 2013 National Research Institute for Earth Science and
 * Disaster Prevention (NIED).
 * This code is licensed under the GPL version 3 license, available at the root
 * application directory.
 */
 /* ======================================================================
    dojo.js
   ====================================================================== */

/* Copyright (c) 2013 National Research Institute for Earth Science and
 * Disaster Prevention (NIED).
 * This code is licensed under the GPL version 3 license, available at the root
 * application directory.
 */
/**
 * eコミマップのライブラリが dojo を利用しているため、
 * 必要な関数だけここで定義する。
 * @class dojo
 */
if(typeof dojo=="undefined") {
	dojo = {};
}

if(typeof dojo.fromJson=="undefined") {
	dojo.fromJson=JSON.parse;
}
if(typeof dojo.toJson=="undefined") {
	dojo.toJson=JSON.stringify;
}

if(typeof dojo.trim=="undefined") {
	dojo.trim=$.trim;
}

if(typeof dojo.clone=="undefined") {
	dojo.clone=function(target){
		return $.extend({}, target);
	};
}

if(typeof dojo.isIE=="undefined") {
	var detectIE = function() {
		var ua = window.navigator.userAgent;

		  var msie = ua.indexOf('MSIE ');
		  if (msie > 0) {
		    // IE 10 or older => return version number
		    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		  }

		  var trident = ua.indexOf('Trident/');
		  if (trident > 0) {
		    // IE 11 => return version number
		    var rv = ua.indexOf('rv:');
		    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		  }

		  var edge = ua.indexOf('Edge/');
		  if (edge > 0) {
		    // Edge (IE 12+) => return version number
		    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
		  }
		  return 0;
	}
	dojo.isIE = detectIE();
}

if(typeof dojo.isChrome=="undefined") {
	var getChromeVersion = function() {     
		var raw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
		return raw ? parseInt(raw[2], 10) : 0;
	}
	dojo.isChrome = getChromeVersion();
}

if(typeof dojo.create=="undefined") {
	dojo.create = function(tag, attrs, refNode, pos) {
		var e = $("<"+tag+">");
		if(typeof attrs!="undefined") {
			if(typeof attrs.style!="undefined") {
				e.attr("style", attrs.style);
			}
			if(typeof attrs.innerHTML!="undefined") {
				e.html(attrs.innerHTML);
			}
			if(typeof attrs.className!="undefined") {
				e.addClass(attrs.className);
			}
		}
		return e.get(0);
	}
}

if(typeof dojo.keys=="undefined") {
	dojo.keys = {};
	dojo.keys.LEFT_ARROW = 37
	dojo.keys.UP_ARROW = 38
	dojo.keys.RIGHT_ARROW = 39
	dojo.keys.DOWN_ARROW = 40
	dojo.keys.DELETE = 46
}
/* ======================================================================
    SaigaiTask/Map.js
   ====================================================================== */

/* Copyright (c) 2013 National Research Institute for Earth Science and
 * Disaster Prevention (NIED).
 * This code is licensed under the GPL version 3 license, available at the root
 * application directory.
 */
/**
 * OpenLayersを利用した地図クライアントのクラス.
 * eコミマップに接続してWMSなどを取得する
 * @class SaigaiTask.SaigaiTask.Map
 * @param {String} div OpenLayers.MapのdivのID
 * @param {Object} options オプション
 */
SaigaiTask.Map = function(div, options){
	SaigaiTask.Map.util.CommonUtil.loadLibrary(options.contextPath);
	this.init(div, options);
}

/**
 * SVNリビジョン番号
 * @type {Number}
 */
SaigaiTask.Map.version = Number("$Revision: 6238 $".split(" ")[1]);

/**
 * srcからdestにプロパティをコピーします.
 * @param {Object} dest
 * @param {Object} src
 */
SaigaiTask.Map.copy = function(dest, src){
	if(src==null) return;
	if(dest==null) return;

	for(var property in src) {
		dest[property] = src[property];
	}
};

/**
 * destのundefinedまたはnullのプロパティをコピーします.
 * @param dest
 * @param src
 */
SaigaiTask.Map.extend = function(dest, src){
	if(src==null) return;
	if(dest==null) return;

	for(var property in src) {
		if(typeof dest[property]=="undefined"||dest[property]==null) {
			dest[property] = src[property];
		}
	}
};

/**
 * OpenLayers.Control.PanZoom のzoomworldボタンを拡張する.
 * @param {OpenLayers.Control.PanZoomBar | OpenLayers.Control.Zoom} panZoom
 */
SaigaiTask.Map.extendZoomWorld = function(panZoom){
	var zoomWorldListener = function(evt, map) {
		var zoomWorld = map.zoomWorld;
		if(typeof zoomWorld=="function"){
			zoomWorld();
			OpenLayers.Event.stop(evt);
			return false;
		}
	};

	// zoomworldアイコンを表示する
	if(panZoom.CLASS_NAME=="OpenLayers.Control.PanZoomBar") {
		panZoom.zoomWorldIcon = true;
		// onButtonClick で zoomworldボタンのイベントを拡張
		panZoom._onButtonClick = panZoom.onButtonClick;
		panZoom.onButtonClick = function(evt){
			var buttonElement = evt.buttonElement;
			var map = evt.object;
			switch (buttonElement.action) {
			case "zoomworld":
				return zoomWorldListener(evt, map);
			default:
				this._onButtonClick(evt);
			}
		};
	}

	if(panZoom.CLASS_NAME=="OpenLayers.Control.Zoom") {
		// create image btn(like OpenLayers.Control.PanZoom._addButton)
		var createImgButton = function(id, img, xy, sz, position) {
			var imgLocation = OpenLayers.Util.getImageLocation(img);
			var btn = OpenLayers.Util.createAlphaImageDiv(
					panZoom.id + "_" + id,
					xy, sz, imgLocation, "relative");
			btn.style.cursor = "pointer";
			btn.style.margin = "0px auto"; // centering
			return btn;
		};

		// create home button
		var id="zoomworld",
		img="zoom-world-mini.png",
		xy={x: 0, y: 2}, // outer div height:22. 2px margin of top and bottom.
		sz={w: 18, h:18};
		var btn = createImgButton(id, img, xy, sz, "relative");

		// set image title for tooltip
		var tooltip = lang.__("Move to the initial display position.");
		img = btn.getElementsByTagName("img")[0];
		img.title = tooltip;

		// click event
		btn.onclick = function(evt) {
			var map = panZoom.map;
			return zoomWorldListener(evt, map);
		}

		// wrap anchor element, for css "div.olControlZoom a"
		var link = document.createElement("a");
		link.appendChild(btn);

		// append to Zoom Control
		var div = panZoom.zoomInLink.parentElement;
		var position = null;
		switch(position) {
		// 上に追加
		case "head": div.insertBefore(link, panZoom.zoomInLink); break;
		// 下に追加
		case "tail": div.appendChild(link); break;
		// ＋と－の間に追加
		default: div.insertBefore(link, panZoom.zoomOutLink); break;
		}
	}

};

/**
 * オブジェクトをSAStrutsのクエリ文字列に変換する.
 * @param {Object} obj
 * @return {String} クエリ文字列
 */
SaigaiTask.Map.param = function(obj) {
	var prefix =null;
	var params = [];
	var add = function(key, value) {
		value = value == null ? "" : value;
		params[params.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
	};
	/**
	 * @param prefix HTTPリクエストパラメータ名
	 * @param obj HTTPリクエストパラメータ値
	 */
	var buildParams = function(prefix, obj) {
		if(jQuery.isArray(obj)) {
			jQuery.each(obj, function(idx, value) {
				buildParams(prefix+"["+idx+"]", value);
			});
		}
		else if(jQuery.type(obj)==="object") {
			var name = null;
			for(name in obj) {
				buildParams(prefix+"."+name, obj[name]);
			}
		}
		else {
			add(prefix, obj);
		}
	};

	for(prefix in obj) {
		buildParams(prefix, obj[prefix]);
	}

	return params.join("&").replace(/%20/g, "+");
};

SaigaiTask.Map.prototype = {

	/**
	 * 初期化オプション
	 * @type {Object}
	 */
	options: null,

	/**
	 * OpenLayersのイベントクラス
	 * @type {OpenLayers.Events}
	 */
	events: null,

	/**
	 * SaigaiTask.Mapクラスのイベントタイプ
	 * @type {Object<String, String>}
	 */
	EventType: {
		/** eコミマップのロード前 */
		beforeloadecommap: "beforeloadecommap",

		/** eコミマップのロード後 */
		loadendecommap: "loadendecommap",

		/** 全レイヤのロード完了後 */
		alllayerloadend: "alllayerloadend",

		/** 登録情報検索ウィンドウ表示前 */
		beforeshowcontentsearchview: "beforeshowcontentsearchview",

		/** 登録情報ポップアップ表示前 */
		beforeshowcontentpopup: "beforeshowcontentpopup",

		/** 凡例パネルをパネルに追加する前 */
		beforeaddlegend: "beforeaddlegend",

		/** 凡例パネルの再描画後 */
		afterredrawlegendpanel: "afterredrawlegendpanel",

		/** 描画レイヤ描画後 */
		afterdraw: "afterdraw",

		/** 登録情報の登録/更新後 */
		successcontentssubmit: "successcontentssubmit",

		/** 登録情報の削除後 */
		successcontentsdelete: "successcontentsdelete",

		/** 地図上クリックのハンドラ実行前 */
		beforemapclick: "beforemapclick",

		/** 地図クリックによる検索 */
		clicksearch: "clicksearch"
	},

	/**
	 * jQueryを使っているかのフラグ
	 * @type {boolean}
	 */
	usejQuery: null,

	/**
	 * SaigaiTaskのコンテキストパス
	 * @type {String}
	 */
	contextPath: null,

	/**
	 * AJAX APIクラス
	 * @type {SaigaiTask.Map.API}
	 */
	api: null,

	/**
	 * SaigaiTaskのコンテキストパスに /map を加えたもの
	 * @type {String}
	 */
	saigaitaskServer: null,

	/**
	 * OpenLayersの投影法のEPSGコード
	 * @type {Number}
	 */
	epsg: 4326,

	/**
	 * OpenLayersにしたい divのID
	 * @type {String}
	 */
	div: null,

	/**
	 * OpenLayers オブジェクト
	 * @type {OpenLayers.Map}
	 */
	map: null,

	/**
	 * コントロールの連想配列
	 * @type {Object.<String, OpenLayers.Control>}
	 */
	controls: null,

	/**
	 * ポップアップ管理クラス
	 * @type {SaigaiTask.Map.control.PopupManager}
	 */
	popupManager: null,

	/**
	 * SaigaiTaskのeコミマップの地図ID
	 * @type {Number}
	 */
	mapId: null,

	/**
	 * 登録情報のWMSレイヤでフィルタするフィーチャIDリストをレイヤIDでマップ
	 * @type {Object<String, Array<Number>}
	 */
	filter: null,

	/**
	 * 登録情報の検索でフィルタするフィーチャIDリストをレイヤIDでマップ
	 * @type {Object<String, Array<Number>}
	 */
	searchFilter: null,

	/**
	 * パネルなどのコンポネーント保存用オブジェクト
	 * @type {Object<String, *>}
	 */
	components: {
		/**
		 * 各パネルを配置するためのメインパネルのコンテナ
		 * @type {SaigaiTask.Map.view.MainPanel}
		 */
		mainpanel: null,

		/**
		 * 登録情報ウィンドウ
		 * @type {SaigaiTask.Map.view.ContentsFormWindow}
		 */
		contentsFormWindow: null
	},

	/**
	 * 凡例ウィンドウ表示フラグ
	 * @type {Boolean}
	 */
	showLegend: false,
	/** 凡例ウィンドウに表示しないレイヤのレイヤID配列 */
	excludesLayerIdsFromLegendWindow: [],

	// click
	clickHandler : null,
	clickBuffer: 10,

	/**
	 * eコミマップ情報配列
	 * @type {Array<SaigaiTask.Map.EcommapInfo>}
	 */
	ecommaps: null,

	// 移動量(px)
	pandx: 100,
	pandy: 50,

	/**
	 * 地図アイコン
	 * @type {SaigaiTask.Map.Icon}
	 */
	icon: null,

	/**
	 * 利用するジオコーダ
	 * support: GOOGLE
	 * @type {String}
	 */
	geocoder: null,

	/**
	 * データ表示時間パラメータ
	 */
	time: null,

	/**
	 * ブラウザリサイズ時に呼ばれるハンドラ
	 * リサイズ後のブラウザサイズに合わせて地図もリサイズする。
	 */
	resize: function() {
		var me = this;
		me.map.updateSize();
	},

	//=====================================================================
	// コンストラクタ
	//=====================================================================
	/**
	 * 初期化 OpenLayersを準備する
	 * @param {String} div OpenLayersにしたい divのID
	 * @param {SaigaiTask.Map.model.InitOptions} initOptions 初期化オプション
	 */
	init: function(div, initOptions){

		var me = this;

		// オプション設定
		var options = new SaigaiTask.Map.model.InitOptions();
		SaigaiTask.Map.copy(options, initOptions);
		me.options = options;
		// フィルタ(文字列を数字に変換して保存)
		me.filter = {};
		for(var filterLayerId in options.filterFeatureMap) {
			me.filter[filterLayerId] = [];
			var filterFeatureIds = options.filterFeatureMap[filterLayerId];
			for(var filterFeatureIdsKey in filterFeatureIds) {
				var filterFeatureId = parseInt(filterFeatureIds[filterFeatureIdsKey]);
				me.filter[filterLayerId].push(filterFeatureId);
			}
		}
		// 検索用フィルタも同じ
		SaigaiTask.Map.copy(me.searchFilter, me.filter);

		// ThickBox の iframe かチェックする
		(function(id){
			var iframe = parent.document.getElementById(id);
			if(iframe) {
				// 古いFirefoxだと "setting a property that has only a getter" のようなエラーが出るためtry-catchで回避
				try{
					console = parent.window.console;
					console.log(lang.__("Changed console to the parent of iframe"));
				} catch(e) {
					// do nothing
				}
			}
		})("TB_iframeContent");

		me.events = new OpenLayers.Events(me);
		// イベント定義を追加
		for(var eventtypeIdx in me.EventType) {
			var type = me.EventType[eventtypeIdx];
			me.events.extensions[type] = true;
		}

		// 変数初期化
		me.ecommaps = new Array();
		me.div = div;
		if(options) {
			// APIの設定
			if(options.api!=null) {
				this.api = options.api;
				this.api.stmap = this;
			}
			// アイコンの設定
			if(options.icon!=null) {
				this.icon = options.icon;
			}
			// コンテキストパスの設定
			var contextPath = options.contextPath;
			if(contextPath){
				me.contextPath = contextPath;
				me.saigaitaskServer = contextPath+"/map";
				if(this.api==null) {
					this.api = new SaigaiTask.Map.SaigaiTaskAPI(contextPath);
				}
				if(this.icon==null) {
					this.icon = new SaigaiTask.Map.Icon(contextPath+"/js/SaigaiTaskJS/css");
				}
			}
			// 凡例表示の設定
			if(typeof options.showLegend!='undefined') {
				me.showLegend = options.showLegend;
			}
			// 投影法
			me.epsg = options.epsg;
			// ジオコーダ
			if(options.geocoder!=null) {
				me.geocoder = options.geocoder;
			}
		}
		me.baseLayer = new Object();
		me.usejQuery = (typeof jQuery!='undefined');
		if(!me.usejQuery) {
			console.warn('jQuery was not found.');
		}

		// OpenLayers option
		var mapOptions = {
			// @see https://github.com/openlayers/ol2/issues/1302
			// Drawing problems with WMS (singleTile:true) and jQuery layout (map.updateSize() events) #1302
			// singleTile=true のWMSレイヤ（正確にはTileレイヤ）がある状態で、
			// 地図サイズ更新メソッド map.updateSize() を呼ぶと、なぜが layer=null のものが渡り Nullポで地図が真っ白になるという問題が発生する。
			// 上記の情報では tileManagerを無効化するとよいそうなので、nullでセットしておく
			// ※フィルタレイヤの空間検索範囲レイヤがシングルタイルなので、フィルタ有地図画面で発生していた
			tileManager: null,
			controls: [],
			// avoid animated zooming
			transitionEffect: null,
			zoomMethod: null
		};
		// epsg 900913, 3857
		if(me.epsg!=900913 || me.epsg == 3857) {
			if (options){
				if(options.scales) {
					mapOptions.scales = options.scales;
				} else {
					mapOptions.maxResolution = 0.703125;
					mapOptions.numZoomLevels = 22;
				}
			}
		}
		me.map = new OpenLayers.Map(div, mapOptions);
		me.setEpsg(me.epsg);
		me.controls = new Object();
		me.addControl(new OpenLayers.Control.Navigation({
			zoomWheelEnabled: true,
			handleRightClicks: true,
			zoomBoxKeyMask: OpenLayers.Handler.MOD_ALT
		}), me.getNavigationControlKey());
		// OpenLayers.Control.Navigation が内部で自動で登録する OpenLayers.Control.DragPan の
		// OpenLayers.Handler.Drag が mousedown, touchstart などのイベントでデフォルトでpropagation(伝播）しないようになっている。
		// タブレットなどのタッチ操作の場合に touchstart, touchend による擬似clickイベントがハンドラ順序によっては起動されない。
		// clickHandlerが OpenLayers.Handler.Drag よりも後になった場合でもイベントを伝播させるために stopDown を false (changed from Default:true) とする.
		// 他のところで OpenLayers.Handler.Drag を使用する場合は stopDown に注意すること
		me.controls.navigation.dragPan.handler.stopDown = false;
		var panZoom = new OpenLayers.Control.PanZoom();
		SaigaiTask.Map.extendZoomWorld(panZoom);
		me.addControl(panZoom, "panZoom");
		// マウス位置の座標を取得
		if (options && options.coordinateDecimal) {
			me.addControl(new OpenLayers.Control.MousePosition({
				displayProjection: new OpenLayers.Projection("EPSG:4326")
			}), 'mouseposition');
		}
		else {
			me.addControl(new SaigaiTask.Map.control.MousePosition60({
				displayProjection: new OpenLayers.Projection("EPSG:4326")
			}), 'mouseposition');
		}
		// 縮尺バーを表示
		//me.addControl(new OpenLayers.Control.ScaleLine(), "scaleLine");
		me.addControl(new OpenLayers.Control.ScaleBar(), "scaleBar");
		// 中心にカーソルを表示
		var centerCursorControl = new OpenLayers.Control.CenterCursor();
		me.addControl(centerCursorControl);
		centerCursorControl.moveCenter();
		// 帰属先を表示
		me.map.addControl(new OpenLayers.Control.Attribution());
		// 表示状態をセッションに保存
		//var sessionLayout = new SaigaiTask.Map.control.SessionLayout(this);
		//me.addControl(sessionLayout, "sessionLayout");
		// 地図印刷
		var pdfControl = new SaigaiTask.Map.control.PdfControl(this);
		me.addControl(pdfControl, "pdfControl");
		// 複数地図同期
		var syncControl = new SaigaiTask.Map.control.SyncControl(this);
		me.addControl(syncControl, "syncControl");
		// 登録情報の地物の複数選択
		var selectFeatureControl = new SaigaiTask.Map.control.SelectFeatureControl(this);
		me.addControl(selectFeatureControl, "selectFeatureControl");
		// UTMグリッド
		var mgrsControl = new SaigaiTask.Map.control.MgrsControl(this);
		me.addControl(mgrsControl, "mgrsControl");
		// メモ
		var rakugakiControl = new SaigaiTask.Map.control.RakugakiControl(this);
		me.addControl(rakugakiControl, "rakugakiControl");
		// KMLなどのベクタレイヤの地物のクリック用
		var kmlSelectControl = new OpenLayers.Control.SelectFeature([], {
			clickout: true, toggle: false, multiple: false, hover: false
		});
		me.addControl(kmlSelectControl, "kmlSelectControl");

		// 描画の初期化
		if(me.initDraw) me.initDraw();

		// イベントハンドラ
		me.clickHandler = new OpenLayers.Handler.Click(
			me, // control
			{click: me.onMapClick}, // callback
			{single: true, pixelTolerance: 5} // options
		);
		me.clickHandler.activate();

		// WFSProxyの初期化
		OpenLayers.ProxyHost = this.api.url.wfsProxyURL;

		// コンテキストメニューの設定
		me.components.contextmenu = new SaigaiTask.Map.view.ContextMenu(me, options.showMenuOptions);

		// 凡例を表示する
		if(me.showLegend) {
			new SaigaiTask.Map.view.MainPanel(me);
		}
		else {
			$("#"+me.div).width("100%").height("100%");
		}
		
		// レイヤ追加時の共通処理
		me.map.events.on({
			"preaddlayer": function(option) {
				var layer = option.layer;
				// loadingプロパティを追加
				layer.loading = false;
				layer.events.on({
					"loadstart": function() {
						layer.loading = true;
					},
					"loadend": function() {
						layer.loading = false;
						
						// check all layer loading
						var allloadend = true;
						for(var idx in me.map.layers) {
							var l = me.map.layers[idx];
							if(l.loading) {
								allloadend = false;
								break;
							}
						}
						
						if(allloadend) {
							me.events.triggerEvent("alllayerloadend");
						}
					}
				});
			}
		});
	},

	setEpsg: function(epsg, scales) {
		var me = this;
		var mapOptions;
		if (epsg == 900913) {
			mapOptions = {
				maxResolution : 156543.0339,
				numZoomLevels : 22,
				maxExtent : new OpenLayers.Bounds(-20037508.34,-20037508.34,20037508.34,20037508.34),
				units : 'm',
				projection : new OpenLayers.Projection("EPSG:900913"),
				displayProjection : new OpenLayers.Projection("EPSG:4326")
			};
		}
		else if (epsg == 3857) {
			mapOptions = {
				maxResolution : 156543.0339,
				numZoomLevels : 22,
				maxExtent : new OpenLayers.Bounds(-20037508.34,-20037508.34,20037508.34,20037508.34),
				units : 'm',
				projection : new OpenLayers.Projection("EPSG:3857"),
				displayProjection : new OpenLayers.Projection("EPSG:4326")
			};
		} else {
			mapOptions = {
				maxExtent: new OpenLayers.Bounds(-180,-90,180,90),
				projection: "EPSG:4326"
			};
			if (!!scales) {
				mapOptions.scales = scales;
			} else {
				mapOptions.maxResolution = 0.703125;
				mapOptions.numZoomLevels = 22;
			}
		}
		me.map.setOptions(mapOptions);
		me.epsg = epsg;

		me.events.triggerEvent("epsgchanged");
	},

	/**
	 * マウスポジションの経緯度を取得する.
	 * @return {OpenLayers.LonLat}
	 */
	getMouseLonLat: function() {
		var me = this;
		var lonlat = me.map.getLonLatFromPixel(me.controls['mouseposition'].lastXy);
		return lonlat;
	},

	/**
	 * レイヤを再読み込みします.
	 */
	reload: function() {
		var me = this;
		var map = me.map;
		var layers = map.layers;
		for(var layersIdx in layers) {
			var layer = layers[layersIdx];
			// ベースレイヤは除く
			if(layer.isBaseLayer) continue;
			layer.redraw(true);
		}
	},

	/**
	 * eコミマップの地図を地図IDを指定して読み込む
	 * @param {Long} mapId 地図ID
	 * @param {String} layerId 凡例ウィンドウに表示しないレイヤID（コンマ区切り文字)
	 * @param {String} onlyLayerId 指定したレイヤIDだけ表示（コンマ区切り文字）
	 */
	loadEcommap: function(mapId, layerIds, onlyLayerIds){
		var me = this;

		me.events.triggerEvent(me.EventType.beforeloadecommap);

		var lids = null;
		var olids = null;
		if (layerIds != null) {
			lids = layerIds.split(",");
			for (var i=0; i<lids.length; i=i+1)
				me.excludesLayerIdsFromLegendWindow.push(lids[i]);
		}
		if (onlyLayerIds != null && onlyLayerIds != "null")
			olids = onlyLayerIds.split(",");

		this.mapId = mapId;
		me.api.getEcommapInfo(mapId, function(ecommap) {
			if(ecommap!=null) {
				ecommap.stmap = me;
				ecommap = new SaigaiTask.Map.EcommapInfo(ecommap);
				me.registEcommapInfo(ecommap, lids, olids);
			}
		});
	},

	/**
	 * eコミ情報を地図へ登録
	 * @param {SaigaiTask.Map.EcommapInfo} ecommap eコミ情報
	 * @param {Array<Integer>} lids 凡例ウィンドウに表示しないレイヤID
	 * @param {Array<Integer>} olids 指定レイヤのみ表示ONにする
	 */
	registEcommapInfo: function(ecommap, lids, olids) {
		var me = this;

		// eコミマップ情報を取得
		me.ecommaps.push(ecommap);
		var ecommapIdx = me.ecommaps.length-1;
		ecommap.ecommapIdx = ecommapIdx;

		// epsg 再設定
		me.setEpsg(ecommap.epsg, ecommap.scales);
		// 表示制限範囲設定
		try {
			if(!!ecommap.layoutInfo && !!ecommap.layoutInfo.restrictedExtent) {
				var restrictedExtentArr = ecommap.layoutInfo.restrictedExtent
				if(restrictedExtentArr.length==4) {
					var restrictedExtent = new OpenLayers.Bounds(restrictedExtentArr[0], restrictedExtentArr[1], restrictedExtentArr[2], restrictedExtentArr[3]);
					var degProj = new OpenLayers.Projection("EPSG:4326");
					var maxExtent = new OpenLayers.Bounds(-20037508.34,-20037508.34,20037508.34,20037508.34).transform( new OpenLayers.Projection("EPSG:900913"), degProj);
					if(restrictedExtent.top    > maxExtent.top)    restrictedExtent.top = maxExtent.top;
					if(restrictedExtent.left   < maxExtent.left)   restrictedExtent.left = maxExtent.left;
					if(restrictedExtent.right  > maxExtent.right)  restrictedExtent.right = maxExtent.right;
					if(restrictedExtent.bottom < maxExtent.bottom) restrictedExtent.bottom = maxExtent.bottom;
					me.map.setOptions({restrictedExtent: restrictedExtent.clone().transform(degProj, new OpenLayers.Projection("EPSG:"+ecommap.epsg))});
				}
			}
		} catch(e) {
			console.error(lang.__("Failed to set display limitation range."), e);
		}

		// ベースレイヤ 初期化
		var baseLayers = ecommap.getBaseLayerInfos();
		me.addBaseLayers(baseLayers);
		// ArcGIS外部地図レイヤ初期化
		var arcgisLayerInfos = ecommap.getArcGISLayerInfos();
		me.addArcGISLayer(arcgisLayerInfos);
		// 主題図（画像）項目レイヤ初期化
		var overlayLayerInfos = ecommap.getOverlayLayerInfos();
		me.addOverlayLayer(overlayLayerInfos);
		// 外部地図レイヤ初期化
		var externalMapLayerInfos = ecommap.getExternalMapLayerInfos();
		me.addExternalMapLayer(externalMapLayerInfos, /*split*/true);
		// 主題図項目レイヤ初期化
		var referenceLayerInfos = ecommap.getReferenceLayerInfos();
		me.addReferenceLayer(referenceLayerInfos, /*split*/true);
		// KMLレイヤ初期化
		var kmlLayerInfos = ecommap.getLayerInfosByTypes([SaigaiTask.Map.Layer.Type.KML]);
		me.addLayers(kmlLayerInfos);
		// コンテンツレイヤ 初期化
		ecommap.contentsLayers = ecommap.getLayerInfosByTypes([SaigaiTask.Map.Layer.Type.LOCAL]);
		var contentsLayers = ecommap.contentsLayers;
		for(var key in contentsLayers) {
			var contentsLayer = contentsLayers[key];
			// 指定レイヤを表示ONにする。（被災状況、対応状況）
			if (olids != null) {
				contentsLayer.visibility = false;
				for (var i=0; i<olids.length; i=i+1) {
					if (olids[i]==contentsLayer.layerId)
						contentsLayer.visibility = true;
				}
			}
			else {
				if (lids!=null) {
					for (var i=0; i<lids.length; i=i+1){
						if (lids[i]==contentsLayer.layerId)
							contentsLayer.visibility = true; // 初期表示
					}
				}
			}
			// 検索フラグを立てる
			contentsLayer.searchable = contentsLayer.visibility;
		}
		me.addContentsLayers(ecommap);

		// Homeボタンクリック時の処理
		me.map.zoomWorld = function() {
			ecommap.moveToHome();
		};
		me.initHome();

		var callback = function(){
			// ポップアップの初期表示
			var popup = null;
			// HTTPリクエストパラメータから取得
			popup = SaigaiTask.Map.util.CommonUtil.getParameter("popup");
			// ポップアップの指定がなければオプションから取得
			if(popup==null) popup = me.options.popupid;
			// ポップアップを表示する
			if(popup!=null){
				var popups = popup.split(",");
				for(var idx in popups) {
					// ポップアップのフィーチャIDを取得する
					var layer = popups[idx].split(".")[0];
					var fid = popups[idx].split(".")[1];
					me.options.pinned = true; // ピン留め
					me.options.center = true; // 地図の中心に表示
					me.getContent(layer,fid, null, null, me.options);
					var layerInfo = me.getLayerInfo(layer);
					if(!!layerInfo) {
						layerInfo.visibility = true;
						layerInfo.searchable = true;
						var layer = layerInfo.getLayer();
						layer.refreshParams();
					}
				}
			}

			var legendcollapsed = null;
			legendcollapsed = SaigaiTask.Map.util.CommonUtil.getParameter("legendCollapsed");
			if(legendcollapsed == "true"){
				me.options.collapsed = true;
			}

			// イベント発火
			me.events.triggerEvent(me.EventType.loadendecommap, {
				ecommap: ecommap
			});
		};

		// 表示状態を復元する
		var sessionLayout = me.controls["sessionLayout"];
		if(!!sessionLayout)sessionLayout.loadLayout(callback, (olids == null));
		else callback();

		// 凡例パネル再描画
		me.components.mainpanel.redrawLegendPanel();
	},

	/**
	 * 表示状態をサーバに保存するイベントの初期化.
	 * @deprected
	 * sessionLayout.activate(); を直接使ってください.
	 */
	initSaveLayout: function(){
		var sessionLayout = this.controls["sessionLayout"];
		sessionLayout.activate();
		sessionLayout.loadLayout();
	},

	initHome: function() {
		var me = this;
		var olmap = me.map;

		// ホーム位置に移動
		olmap.zoomWorld();

		// ホーム位置記憶
		var center = me.getCenter();
		var zoom = me.map.getZoom();
		var homeLocation = {
			center: center,
			zoom: zoom
		};
		me.isHome = function() {
			var center = me.getCenter();
			var zoom = me.map.getZoom();
			if(homeLocation.center.equals(center)==false) return false;
			if(homeLocation.zoom!=zoom) return false;
			return true;
		};

		// 位置情報があれば移動
		var map = this;
		var popup = SaigaiTask.Map.util.CommonUtil.getParameter("popup");
		if(popup==null) {
			// パラメータに指定があれば中心位置を移動する
			var initCenter = SaigaiTask.PageURL.getInitCenter();
			if(initCenter!=null) {
				//initCenter.transform(new OpenLayers.Projection("EPSG:4326"), map.map.getProjectionObject());
				//map.map.setCenter(initCenter);
				map.setCenter(initCenter);
			}
			// パラメータに指定があればズームする
			var initZoom = SaigaiTask.PageURL.getInitZoom();
			if(isFinite(initZoom) && 0<initZoom) {
				//  ズームが効かないので遅延させる
				//setTimeout(function() {
					map.map.zoomTo(initZoom);
				//}, 1000);
			}
		}
	},

	onMapClick: function(evt){
		var me = this;

		// onmapclick before
		me.events.triggerEvent(me.EventType.beforemapclick);
		
		// ポップアップを閉じる
		if(me.popupManager!=null) {
			me.popupManager.closeAll();
		}

		// フォーカスを外す
		// ※メモ描画でテキストメモ編集モードのテキストエリアを閉じるために必要
		// 　@see src/main/webapp/js/SaigaiTaskJS/lib/SaigaiTask/Map/Layer/DrawLayerSelectDrag.js _startTextEdit
		if(!!document.activeElement && !!document.activeElement.blur) document.activeElement.blur();

/*
		// SelectFeature の clickFeature が呼ばれた場合、onMapClick は呼ばれないため不要
		var kmlSelectControl = me.controls["kmlSelectControl"];
		//KMLレイヤのFeatureがクリック位置にあるかチェック
		if (kmlSelectControl) {
			var selectedLayers = kmlSelectControl.layers;
			if (selectedLayers) {
				for (var i=0; i<selectedLayers.length; i++) {
					if (selectedLayers[i] && selectedLayers[i].getFeatureFromEvent(evt)) {
						alert("click!");
					}
				}
			}
		}
*/

		var lb = this.map.getLonLatFromPixel(new OpenLayers.Pixel(evt.xy.x-this.clickBuffer, evt.xy.y+this.clickBuffer));
		var rt = this.map.getLonLatFromPixel(new OpenLayers.Pixel(evt.xy.x+this.clickBuffer, evt.xy.y-this.clickBuffer));
		if (this.map.displayProjection) {
			lb.transform(this.map.getProjectionObject(), this.map.displayProjection);
			rt.transform(this.map.getProjectionObject(), this.map.displayProjection);
		}
		var bbox = [lb.lon,lb.lat,rt.lon,rt.lat];

		this.clickSearch(new OpenLayers.LonLat((lb.lon+rt.lon)/2, (lb.lat+rt.lat)/2), bbox, /*pinned*/false, {
			evt: evt
		});
	},

	/**
	 * @param {OpenLayers.LonLat} center
	 * @param {Array<Number>} bbox
	 * @param {Boolean} pinned ポップアップのピン留め
	 * @param {Object} option
	 * @param {Event} option.evt ハンドラが受け取ったイベント
	 */
	clickSearch: function(center, bbox, pinned, option){

		var me = this;

		// 他のポップアップを閉じる
		if(me.popupManager!=null) {
			me.popupManager.closeAll();
		}

		// 検索対象のレイヤIDを取得
		var layerIds = me.getSearchableLayerIds();
		if(layerIds.length==0){
			// 外部参照レイヤを検索
			var refcontentsPopup = new SaigaiTask.Map.view.RefContentsPopup(me);
			refcontentsPopup.getReferenceFeatureInfo(center, bbox);
			return;
		}

		// SLDのruleパラメータを取得する
		var rule = "";
		for(var idx in layerIds) {
			var layerId = layerIds[idx];
			// 登録情報レイヤのSLDルールの表示パラメータ付与
			var contentsLayerInfo = me.getLayerInfo(layerId);
			if(typeof contentsLayerInfo.params.rule=="string"
				&& 0<contentsLayerInfo.params.rule.length) {
				rule += (0<rule.length?",":"") + contentsLayerInfo.params.rule;
			}
		}

		// cidを取得する（SLDの取得で必要になるので）
		var cid = null;
		var ecommaps = me.ecommaps;
		for( var ecommapsKey in ecommaps ) {
			// レイヤが表示されているか調べる
			var ecommap = ecommaps[ecommapsKey];
			var mapInfo = ecommap.mapInfo;
			if(mapInfo.mapId==me.mapId) {
				cid = mapInfo.communityId;
				break;
			}
		}

		// フィルタするレイヤ数に応じて検索結果取得数を増やす
		var limit = 10;
		var filter = me.searchFilter;
		var filterLength = SaigaiTask.Map.util.CommonUtil.length(filter);
		limit += filterLength * 5;

		// カーソルをbusyに変更
		var mapDiv = $("#"+me.div);
		mapDiv.css("cursor", "wait");

		me.searchContentsByBbox(bbox, {
			cid: cid,
			layerIds: layerIds,
			limit: limit,
			async: true,
			rule: rule,
			success: function(result) {
				// フィルタが指定されているレイヤは指定フィーチャIDのみ検索結果に残す
				if(0<filterLength) {
					var featureInfos = result[1];
					var filteredResult = [];
					for(var featureInfosKey in featureInfos) {
						// 取得データのレイヤIDとフィーチャIDを得る
						var featureInfo = featureInfos[featureInfosKey];
						var layerId = featureInfo[0];
						var featureId = featureInfo[1];
						// フィルタに存在するかチェックする
						var isFilter = false;
						var filterFeatureIds = filter[layerId];
						if(typeof filterFeatureIds!="undefined") {
							isFilter = jQuery.inArray(featureId, filterFeatureIds) == -1;
						}
						// フィルタしないものは残す
						if(isFilter==false) {
							filteredResult.push(featureInfo);
						}
					}
					result[1] = filteredResult;
				}

				// 結果数を減らす
				result[1] = result[1].slice(0, 10);

				// イベント発火
				if(!option) option = {}; // なければ作成
				option.executePopup = true;
				var args = {
					layerIds: layerIds,
					center: center,
					bbox: bbox,
					option: option,
					result: result,
					executePopup: true
				}
				me.events.triggerEvent(me.EventType.clicksearch, args);

				// ポップアップはイベントからも制御できる
				if(args.executePopup) {
					// 結果をポップアップする
					if (result[1].length == 1) {
						//一つの場合は、コンテンツを再取得してポップアップ
						me.getContent(result[1][0][0], result[1][0][1], center, bbox, {
							pinned: pinned
						});
					} else if (result[1].length > 1) {
						//一覧をポップアップ
						var listPopup = new SaigaiTask.Map.view.ListPopup(me);
						listPopup.show(center, bbox, result, pinned);
					} else {
						// 外部参照レイヤを検索
						var refcontentsPopup = new SaigaiTask.Map.view.RefContentsPopup(me);
						refcontentsPopup.getReferenceFeatureInfo(center, bbox);
					}
				};

				mapDiv.css("cursor", "default");

			},
			error: function() {
				mapDiv.css("cursor", "default");
			}
		});


	},

	/**
	 * 矩形で登録情報を検索します.
	 * @param {Array<Number>} bbox WGS84の矩形配列 [SW.x, SW.y, NE.x, NE.y]
	 * @param {Object<String, Object>} options オプション
	 * @param {Array<String>} options.mapId 検索対象のマップID (default 表示中のマップID)
	 * @param {Array<String>} options.layerIds レイヤIDの配列 (default 表示中のレイヤID)
	 * @param {Number} options.limit 取得数の上限 (default 0)
	 * @param {Boolean} options.async AJAXの同期・非同期通信 (default false)
	 * @param {String} options.rule SLDの表示ルールパラメータ
	 * @return {Object} result(同期通信の場合のみ)
	 * {Number} result[0] 検索結果情報の配列
	 * {Number} result[0][0] total
	 * {Number} result[0][1] limit
	 * {Number} result[0][2] offset
	 * {Array.<Array>}} result[1] 検索されたフィーチャ情報の配列
	 * {Array.<Object>} result[1][#] フィーチャ情報配列
	 * {String} result[1][#][0] レイヤID
	 * {String} result[1][#][1] フィーチャID
	 * {Array.<Number>} result[1][#][2] ジオメトリ情報配列
	 * {Number} result[1][#][2][0] 中心位置のx座標
	 * {Number} result[1][#][2][1] 中心位置のy座標
	 * {Number} result[1][#][2][2] 矩形からの距離[m]
	 * {Array.<Object>} result[1][#][3] 属性情報配列
	 * {Array.<Object>} result[1][#][4] ファイル情報配列
	 * {Array.<Object>} result[1][#][5] メタ情報配列
	 */
	searchContentsByBbox: function(bbox, options) {

		var me = this;

		// デフォルトオプションの生成
		var defaultOptions = {
			cid: null,
			mapId: me.mapId,
			layerIds: me.getVisibleLayerIds(),
			limit: 0,
			async: false,
			rule: ""
		};

		// 未指定のオプションをデフォルトで上書きする
		var op = {};
		Ext.applyIf(op, options);
		Ext.applyIf(op, defaultOptions);
		console.log("op");
		console.log(op);

		return me.api.searchContentsByBbox(bbox, op.cid, op.mapId, op.layerIds, op.rule, op.limit, op.async, op.success);
	},

	/**
	 * 避難所情報をサーバから検索します.
	 * @param {SaigaiTask.Map.model.ShelterSearchOptions} options
	 */
	searchShelter: function(options) {
		var me = this;
		var result = null;
		var url = me.contextPath + me.url.searchShelterURL;
		options._csrf = SaigaiTask.ajaxcsrfToken;
		Ext.Ajax.request({
			url: url,
			method: "GET",
			params: options,
			async: false,
			success: function(response) {
				result = JSON.parse(response.responseText);
			}
		});
		return result;
	},

	/**
	 * 指定住所をジオコードして取得できれば移動します.
	 * @param {String} address 住所文字列
	 */
	moveAddress: function(address) {
		var me = this;

		var defer = $.Deferred();

		me.geocode(address)
		.done(function(results, status) {
			var result = results[0];
            var point = result.geometry.location;
			//console.log("Google Results : ");
			//console.log(results[0]);
			//TODO : 取得した住所のtype種別に応じてzoomLevelを調整する？
			var lonlat = new OpenLayers.LonLat(point.lng(),point.lat());
			// WGS84から地図の投影法に変換
			lonlat = lonlat.transform(new OpenLayers.Projection("EPSG:4326"), me.map.getProjectionObject());
			if(!!me.map.restrictedExtent) {
				if(me.map.restrictedExtent.containsLonLat(lonlat)==false) {
					alert(lang.__("Failed to move due to out of range."));
					defer.reject(result);
					return;
				}
			}
			me.map.setCenter(lonlat, 15);

			defer.resolve(result);
		});

		return defer.promise();
	},

	/**
	 * 引数に応じてジオコーディング・逆ジオコーディングします。
	 * 将来、ジオコーダを切り替えるためにこれを利用します.
	 * @param {OpenLayers.Geometry.Point} opt ジオコーディング
	 * @param {OpenLayers.LonLat} opt ジオコーディング
	 * @param {String} opt 逆ジオコーディング
	 * @return {jQuery.Deffered}
	 */
	geocode: function(opt) {
		var me = this;
		if(me.geocoder!=null) {
			if(me.geocoder.toUpperCase()=="GOOGLE") {
				return me.geocodeGoogle(opt);
			}
		}

		// otherwise
		alert(lang.__("No geocoder to be available."));
		var defer = $.Deferred();
		defer.reject();
		return defer.promise();
	},

	/**
	 * Googleジオコーダーを使ってジオコーディング・逆ジオコーディングします.
	 * @return {jQuery.Deffered}
	 */
	geocodeGoogle: function(opt) {
		// バージョンチェック
		var isV3 = false;
		try{ isV3 = google.maps.version.indexOf("3.")==0; } catch(e) {alert(lang.__("Google Map JavaScript API v3 has not been loaded."));}

		// Google Maps JavaScript API v3
		var defer = $.Deferred();
		geocoder = new google.maps.Geocoder();

		// parse opt, build option
		var option = {};
		switch(typeof opt) {
		// 文字列の場合は逆ジオコーディングとする
		case "string":
			option.address = opt;
			break;
		case "object":
			if(!!opt.CLASS_NAME) {
				switch(opt.CLASS_NAME) {
				case "OpenLayers.Geometry.Point":
					var point = opt;
					var lat = point.y;
					var lng = point.x;
					option.latLng = new google.maps.LatLng(lat, lng);
					break;
				case "OpenLayers.LonLat":
					var lonlat = opt;
					var lat = lonlat.lat;
					var lng = lonlat.lon;
					option.latLng = new google.maps.LatLng(lat, lng);
					break;
				}
			}
			break;
		}
		// execute
		geocoder.geocode(option, function(results, status) {
			if(status==google.maps.GeocoderStatus.OK) {
				defer.resolve(results, status);
			}
			else {
				defer.reject(results, status);
			}
		});

		return defer.promise();
	},

	/**
	 * 逆ジオコーディング結果を整形した住所文字列に変換します.
	 * @param {Object} result 逆ジオコーディング結果
	 * @param {Object} formatOption 整形オプション
	 */
	getFormattedAddress: function(result, formatOption) {
		var addr = result.formatted_address;

		// 日本を削除
		addr = addr.replace(/^日本, /,'');

		// 郵便番号を削除
		addr = addr.replace(/^〒\d\d\d-\d\d\d\d /,'');

		// 県名を取得
		var pref = null;
		var addressComponentsIdx = result.address_components.length-1;
		for(;0<=addressComponentsIdx; addressComponentsIdx--) {
			var component = result.address_components[addressComponentsIdx];
			if(component.types[0]=="administrative_area_level_1") {
				pref = component.long_name;
			}
		}
		// 県名以下の住所情報がある場合は県名を削除
		if(pref!=null) {
			var replacedAddr = addr.replace(pref, "");
			if(replacedAddr.length!=0) {
				addr = replacedAddr;
			}
		}
		return addr;
	},

	/**
	 * 登録情報をフィーチャIDを指定してポップアップ表示します.
	 * @param {String} layer レイヤID
	 * @param {Number} fid フィーチャID
	 * @param {OpenLayers.LonLat} center クリック位置(optional)
	 * @param {Array<Number>} bbox クリック位置の矩形範囲(optional)
	 * @param {Object} options そのほかオプション(optional)
	 */
	getContent: function(layer, fid, center, bbox, options) {
		// 引数チェック
		if(typeof layer=="undefined" || layer==null || layer=="") {
			console.warn(lang.__("Layer ID has not been specified."));
			return;
		}
		if(isNaN(parseFloat(fid)) || isFinite(fid)==false) {
			console.warn(lang.__("Feature ID is not specified in numeric."));
			return;
		}
		// 登録情報を取得
		var me = this;
		me.api.getContent(me.mapId, layer, fid, center, bbox, function(data) {
			if(data==null) {
				return;
			}
			else if(typeof data=="error"){
				console.warn("error!",args);
			}
			else{
				var contentsPopup = new SaigaiTask.Map.view.ContentsPopup(me);
				contentsPopup.show(layer, fid, data, center, bbox, options);
			}
		});
	},

	/**
	 * @param url URL
	 * @param title 画像タイトル
	 * @param maxw 最大幅
	 * @param maxh 最大高
	 */
	createImg: function(url, title, maxw, maxh) {
		var me = this;
		// ロード中の画像を生成
		var extImg = {
			xtype: 'image',
			src: me.saigaitaskServer+'/images/loading.gif',
			style: {
				width: '32px',
				height: '32px'
			}
		};
		var extImgObj = Ext.create('Ext.Img', extImg);

		// 画像を読み込み
		var img = new Image();
		//var imgResized = false;
		img.onload = function(){
			// DOMに要素ができるまで処理しない
			if (!extImgObj.getEl()) {
				setTimeout(img.onload, 100);
				return;
			}
			imgResized = true;
			// 画像をリサイズする
			var w = img.width;
			var h = img.height;
			if(typeof img.naturalWidth!='undefined') { // for Firefox, Safari, Chrome
				w = img.naturalWidth;
				h = img.naturalHeight;
			}
			// 最大サイズより大きい場合は縮小する
			var rate = Math.min(maxw/w, maxh/h);
			if(rate<1) {
				w = Math.round(w*rate);
				h = Math.round(h*rate);
			}
			// 変更がある場合のみ更新する(毎回更新するとafterlayoutイベントが発生して無限ループになる)
			if(w!=extImgObj.getWidth()) extImgObj.setWidth(w);
			if(h!=extImgObj.getHeight()) extImgObj.setHeight(h);
			if(extImgObj.src!=url) {
				extImgObj.setSrc(url);
			}
			// タイトルの設定
			if(typeof title!="undefined"&&title!=null) {
				extImgObj.getEl().set({title: title});
			}

			// 画像クリック時にライトボックス風に表示する
			extImgObj.getEl().dom.onclick = function() {
				var img = this;
				FalUtil.showImageWindow(img.src);
			};

			// TODO: ポップアップの画像を縦に中央揃えにする
		};
		img.src = url;

		window.extImgObj = extImgObj;

		return extImgObj;
	},

	/**
	 * 登録情報のWFSレイヤを追加する
	 * @param cid
	 * @param mid
	 * @param layerId
	 * @param fids
	 * @param options
	 * @param options.styleMap
	 * @return {OpenLayers.Layer.Vector} WFSレイヤ
	 */
	addContentsWFSLayer: function(cid,mid,layerId,fids,options){
		// デフォルトオプションの生成
		var defaultOptions = {
			styleMap: null
		};

		// 未指定のオプションをデフォルトで上書きする
		var op = {};
		Ext.applyIf(op, options);
		Ext.applyIf(op, defaultOptions);

		var me = this;
		var layerInfo = me.getLayerInfo(layerId);
		var ecommap = me.ecommaps[0];
		var url = ecommap.ecommapURL+"/wfs?";
		if(ecommap.wfsURL!=null) url = ecommap.wfsURL;
		url += "cid="+cid;
		var featureType = layerId;
		var featureNS = "";

		// filter を設定する
		if(!fids) fids = [];
		var filter = null;
		if(fids!=null) {
			new OpenLayers.Filter.FeatureId({ fids: fids });
		}
		if(layerInfo.timeSeriesType==SaigaiTask.Map.Layer.TimeSeriesType.HISTORY) {
			//filter
			var time = SaigaiTask.PageURL.getTime();
			if(!time) time = new Date();
			var iso8601Time = new Date(time).toISOString();
			// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
			if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
				iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
			}
			filter = new OpenLayers.Filter.Logical({
				type: OpenLayers.Filter.Logical.AND,
				filters: [ new OpenLayers.Filter.Comparison({
					type: OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
					property: "time_from",
					value: iso8601Time
				}), new OpenLayers.Filter.Comparison({
					type: OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
					property: "time_to",
					value: iso8601Time
				})]
			});
		}

		// styleMap
		var styleMap = op.styleMap;
		if(styleMap==null) {
			var sldXML = this.getSLD(mid, layerId);
			var sldFormat = new OpenLayers.Format.SLD();
			var sld = sldFormat.read(sldXML);
			for(var l in sld.namedLayers){
				var styles = sld.namedLayers[l].userStyles;
				styleMap = styles[0];
			}
		}
		return this.addWFSLayer(url, featureType, featureNS, filter, styleMap);
	},

	/**
	 * WFSレイヤを地図に追加する。
	 * @param url
	 * @param featureType
	 * @param featureNS
	 * @param filter
	 * @return {OpenLayers.Layer.Vector} WFSレイヤ
	 */
	addWFSLayer: function(url, featureType, featureNS, filter, styleMap){
		var protocol = new OpenLayers.Protocol.WFS({
			url: url,
			featureType: featureType,
			featureNS: featureNS,
			srsName: "EPSG:" + this.epsg,
			srsNameInQuery: "EPSG:" + this.epsg,
			outputFormat: "json", // XMLだと、GeoServerが infinity をパースできず、例外が発生するためJSON形式をリクエストする
			readFormat: new OpenLayers.Format.GeoJSON()
		});
		// 接続できるか一度テストする
		var response = protocol.read({
			maxFeatures: 100,
			callback: function(response) {
				console.log("test wfs response");
				console.log(response);
				console.log(response.error);
				if(-1 < response.priv.responseText.indexOf("<servlet-exception>")) {
					console.error(lang.__("Failed to get WFS.")+url + "\n" + response.priv.responseText);
				}
			}
		})
		var wfs = new OpenLayers.Layer.Vector("WFS", {
	        strategies: [new OpenLayers.Strategy.BBOX()],
			protocol: protocol,
			filter: filter,
			styleMap: styleMap
		});
		this.map.addLayer(wfs);
		return wfs;
	},

	/**
	 * 複数のコンテンツレイヤを登録する
	 * @param ecommap eコミマップ情報
	 */
	addContentsLayers: function(ecommap){
		return this.addContentsLayer(ecommap);
	},

	/**
	 * コンテンツレイヤを新しいレイヤで登録する。
	 * @param ecommap eコミマップ情報
	 */
	addContentsLayer: function(ecommap){
		var contentsLayerInfo = ecommap.contentsLayerInfo;
		if(contentsLayerInfo==null) {
			return null;
		}
		// フィルタ対象レイヤがあるかどうかチェック
		var hasFilterLayer = false;
		for(var idx=ecommap.contentsLayerInfos.length-1; 0<=idx; idx--) {
			var layerInfo = ecommap.contentsLayerInfos[idx];
			if(layerInfo.filterkey!=null) {
				hasFilterLayer = true;
				break;
			}
		}
		// フィルタ対象レイヤがある場合はWMSレイヤを１つずつわける
		if(hasFilterLayer) {
			// 試しにレイヤ情報１つにつきレイヤを１つ作成する
			for(var idx=ecommap.contentsLayerInfos.length-1; 0<=idx; idx--) {
				var layerInfo = ecommap.contentsLayerInfos[idx];
				var contentsLayerInfo = ecommap.createContentsLayerInfo();
				contentsLayerInfo.appendChildLayerInfo(layerInfo);
				var isFilterLayer = layerInfo.filterkey!=null;
				// フィルタ対象レイヤの場合
				if(isFilterLayer) {
					// パラメータを設定
					contentsLayerInfo.params.filterlayer = layerInfo.layerId;
					contentsLayerInfo.params.filterkey = layerInfo.filterkey;
					contentsLayerInfo.params.grayout = layerInfo.grayout;
					// 空間検索範囲レイヤがあれば追加する
					if(layerInfo.hasSpatialLayer()) {
						layerInfo.createSpatialLayer();
					}
				}
				var contentsLayer = new SaigaiTask.Map.Layer.WMSLayer(contentsLayerInfo);
				this.map.addLayer(contentsLayer);

				console.log("contensLayer.params");
				console.log(contentsLayer.params);

				// 自動リロード
				var reload = ecommap.mapInfo.reload;
				if(0<reload) {
					var timerId = setInterval(function(){
						contentsLayer.redraw(true);
					}, reload*1000);
					ecommap.mapInfo.reloadkTimerId = timerId;
				}
			}
			return;
		}
		// 通常の場合は１つのWMSレイヤにすべてのレイヤを含める
		var contentsLayer = new SaigaiTask.Map.Layer.WMSLayer(contentsLayerInfo);
		this.map.addLayer(contentsLayer);

		console.log("contensLayer.params");
		console.log(contentsLayer.params);

		// 自動リロード
		var reload = ecommap.mapInfo.reload;
		if(0<reload) {
			var timerId = setInterval(function(){
				contentsLayer.redraw(true);
			}, reload*1000);
			ecommap.mapInfo.reloadkTimerId = timerId;
		}

		return contentsLayer;
	},

	/**
	 * 登録情報レイヤのWMSのURLとレイヤの表示プロパティを取得する
	 * @deprecated もう使用しないがFeatureIdのフィルタは移設する必要がある？
	 * @param ecommapIdx eコミマップ情報インデックス
	 * @return オブジェクト ret
	 */
	getContentsWmsURLInfo: function(ecommapIdx){
		console.log("getContentsWmsURL");
		var ecommap = this.ecommaps[ecommapIdx];
		var mapInfo = ecommap.mapInfo;
		var contentsLayers = ecommap.contentsLayers;
		var layerAuthKeys = ecommap.layerAuthKeyMap;

		// 変数初期化
		var mapCid = mapInfo.communityId;
		var mapId = mapInfo.mapId;
		var layers="",keys="";
		var layerArray=[], keyArray=[];

		// 各レイヤの情報を取得する
		var visible = true;
		var layerId = null, layerAuthKey = null;
		for(var key in contentsLayers){
			console.log("contentsLayers["+key+"]");
			var contentsLayer = contentsLayers[key];
			layerId = contentsLayer.layerId;
			//var layerName = contentsLayer.name;
			//var contentsAttr = new Array(0);
			layerAuthKey = layerAuthKeys[layerId];
			console.log("visible: "+visible);
			console.log("layerId: "+layerId);
			console.log("layerAuthKey: "+layerAuthKey);
			if( layerId!=null && layerAuthKey!=null && contentsLayer.visibility==true ) {
				if(jQuery.inArray(layerId, layerArray)==-1) {
					layerArray.push(layerId);
					keyArray.push(layerAuthKey);
				}
			}
		}

		if(0<layerArray.length) {
			layers = layerArray.join(",");
			keys = keyArray.join(",");
		}

		if(layers.length==0){
			layers = layerId;
			keys = layerAuthKey;
			visible = false;
		}

		// wms URL
		var server = this.saigaitaskServer;
		var wmsBaseURL = server+this.url.wmsAuthURL;
		// フィーチャIDフィルタ
		var featureId = "";
		if(this.filter){
			var first = true;
			var filterLayerId = new Array();
			for(var layerId in this.filter){
				// レイヤIDが指定されていなければ次へ
				if(!layerId) continue;
				var featureIdList = this.filter[layerId];
				if(featureIdList){
					for(var idx in featureIdList){
						var fid = featureIdList[idx];
						if(first)first=false;
						else featureId += ",";
						featureId += layerId+"."+fid;
						filterLayerId.push(layerId);
					}
				}
			}
			// フィルタがあれば、レイヤは最低限のものだけにする
			if(0<filterLayerId.length){
				layers = filterLayerId.join(',');
				keys = new Array();
				for(var idx in filterLayerId){
					keys.push( layerAuthKeys[filterLayerId[idx]] );
				}
				keys = keys.join(',');
			}
		}
		//var wmsURL = wmsBaseURL+"?cid="+mapCid+"&mid="+mapId+"&keys="+keys+"&featureId="+featureId+"&";
		var wmsURL = wmsBaseURL+"?cid="+mapCid+"&mid="+mapId+"&featureId="+featureId+"&";

		var ret = {
				wmsURL: wmsURL,
				layers: layers,
				visibility: visible
		};
		console.log("ret");
		console.log(ret);
		return ret;
	},

	/**
	 * SLDファイルをhttpで取得します.
	 * @param mid
	 * @param layerId
	 * @return {String} SLD文字列
	 */
	getSLD: function(mid, layerId){
		return this.api.getSld(mid, layerId);
	},

	/**
	 * レイヤIDでレイヤ情報をマップ.
	 */
	getLayerMap: function(){
		var me = this;
		var layers = me.getAllLayers();
		var map = {};
		for(var idx in layers) {
			var layer = layers[idx];
			map[layer.layerId] = layer;
		}
		return map;
	},

	/**
	 * すべてのレイヤ情報を取得する.
	 * @returns {Array}
	 */
	getAllLayers: function(){
		var me = this;
		var ecommap = me.ecommaps[0];
		 return ecommap.baseLayers.concat(ecommap.contentsLayers).concat(ecommap.overlayLayers)
		 .concat(ecommap.referenceLayers);
	},

	redrawLayer: function(obj) {
		var me = this;
		if(typeof obj=="object") {
			if(!!obj.CLASS_NAME) {
				if(obj.CLASS_NAME=="SaigaiTask.Map.Layer.WMSLayer") {
					var layer = obj;
					if(layer!=null && typeof layer.refreshParams=="function") {
						// refreshParams でセットされる Visibility は、LayerInfo を見ているが、
						// 空間検索範囲の LayerInfo は元の方になっていて、
						// 場合によっては反転するためもとの状態を保持して再設定する
						var visibility = layer.getVisibility();

						// 再読み込み
						success |= layer.refreshParams({
							nocache: true
						});

						layer.setVisibility(visibility);
					}
					return success;
				}
				if(obj.CLASS_NAME=="SaigaiTask.Map.Layer.LayerInfo") {
					var success = false;
					var layerInfo = obj;
					var layers = []
					var layer = layerInfo.getLayer();
					if(layer!=null) {
						me.redrawContentsLayer(layer);
						layer = layerInfo.spatialLayer;
						if(layer!=null) {
							me.redrawContentsLayer(layer);
						}
					}
				}
			}
		}
		return false;
	},

	/**
	 * 登録情報レイヤを再描画する
	 * @deprecated
	 * @param ecommapIdx eコミマップ情報インデックス
	 * @return 再描画した場合は true
	 */
	redrawContentsLayer: function(obj){
		var me = this;

		if($.isNumeric(obj)) {
			var ecommapIdx = obj;
			var ecommap = me.ecommaps[ecommapIdx];
			var contentsLayerInfo = ecommap.contentsLayerInfo;
			if(contentsLayerInfo!=null) {
				var layer = contentsLayerInfo.getLayer();
				var reloaded = me.redrawContentsLayer(contentsLayerInfo);
				// リロードできなかった場合は、子レイヤのリロードを行う
				if(!reloaded) {
					for(var idx in contentsLayerInfo.children) {
						var child = contentsLayerInfo.children[idx];
						me.redrawContentsLayer(child);
					}
				}
			}
		}
		else if(typeof obj=="object") {
			return me.redrawLayer(obj);
		}
		return false;
	},

	addBaseLayers: function(baseLayers){
		for( var key in baseLayers )
			this.addBaseLayer(baseLayers[key]);
	},

	/**
	 *
	 * @param layerInfo ベースレイヤ情報
	 */
	addBaseLayer: function(layerInfo){
		if( !layerInfo ) return;

		layerInfo = new SaigaiTask.Map.Layer.LayerInfo(layerInfo);

		layer = SaigaiTask.Map.Layer.newLayerFromLayerInfo(layerInfo);
		if(layer instanceof SaigaiTask.Map.Layer.GoogleLayer) {
			if(typeof google == "undefined") {
				alert(lang.__("Set geocoder setting to Google's when to user Google Map."));
				return;
			}
		}


		// ベースレイヤを追加
		this.map.addLayer(layer);

		// レイヤの切り替え
		if(layerInfo.visibility) {
			this.map.setBaseLayer(layer);
		}

		this.baseLayer[layerInfo.layerId] = layer;
	},

	/**
	 * 登録情報レイヤで表示中のレイヤのIDを配列で取得します.
	 * @return {Array.<String>} 表示しているレイヤがない場合は空の配列
	 */
	getVisibleLayerIds: function() {
		var me = this;
		var layerIds = [];
		var ecommaps = me.ecommaps;
		for( var ecommapsKey in ecommaps ) {
			// レイヤが表示されているか調べる
			var ecommap = ecommaps[ecommapsKey];
			var contentsLayers = ecommap.contentsLayers;
			if(contentsLayers){
				for(var contentsLayersKey in contentsLayers){
					var contentsLayer = contentsLayers[contentsLayersKey];
					var layerId = contentsLayer.layerId;
					var visible = contentsLayer.visibility;
					if(visible){
						layerIds.push(layerId);
					}
				}
			}
		}
		return layerIds;
	},

	/**
	 * 検索対象のレイヤIDを取得します.
	 * @return {Array.<String>} 検索対象のレイヤがない場合は空の配列
	 */
	getSearchableLayerIds: function() {
		var me = this;
		var layerIds = [];
		var ecommaps = me.ecommaps;
		for( var ecommapsKey in ecommaps ) {
			// レイヤが表示されているか調べる
			var ecommap = ecommaps[ecommapsKey];
			var contentsLayers = ecommap.contentsLayers;
			if(contentsLayers){
				for(var contentsLayersKey in contentsLayers){
					var contentsLayer = contentsLayers[contentsLayersKey];
					var layerId = contentsLayer.layerId;
					if(contentsLayer.alwaysNotSearch==false && contentsLayer.searchable){
						layerIds.push(layerId);
					}
				}
			}
		}
		return layerIds;
	},

	/**
	 * レイヤIDからレイヤ情報を取得します.
	 * @param {String} layerId
	 * @return layerInfo
	 */
	getLayerInfo: function(layerId) {
		var layerInfo = null;
		var ecommaps = this.ecommaps;
		for( var ecommapsKey in ecommaps ) {
			var ecommap = ecommaps[ecommapsKey];
			var contentsLayers = ecommap.contentsLayers;
			for( var contentsLayersKey in contentsLayers ) {
				var contentsLayer = contentsLayers[contentsLayersKey];
				if( contentsLayer.layerId==layerId ) {
					layerInfo = contentsLayer;
					return layerInfo;
				}
			}
		}
		return null;
	},

	/**
	 *
	 * @param {Array<SaigaiTask.Map.Layer.LayerInfo>} レイヤ情報配列
	 */
	addLayers: function(layerInfos) {
		var me = this;
		for(var key in layerInfos) {
			var info = layerInfos[key];
			me.addLayer(info);
		}
	},
	/**
	 * レイヤを追加する
	 * @param {Object} obj OpenLayers.Layer または SaigaiTask.Map.Layer.LayerInfo
	 */
	addLayer: function(obj) {
		var me = this;

		switch(obj.CLASS_NAME) {
		case "SaigaiTask.Map.Layer.LayerInfo":
			var layer = SaigaiTask.Map.Layer.newLayerFromLayerInfo(obj);
			// KMLLayer は OpenLayers.Control.SelectFeature に追加するため、addLayerの必要なし
			if(layer.CLASS_NAME!="SaigaiTask.Map.Layer.KMLLayer"
				/* 汎用レイヤグループは、addLayerの必要なし */
				&& layer.CLASS_NAME!="SaigaiTask.Map.Layer.Group") {
				me.map.addLayer(layer);
			}
			break;
		default:
			if(obj instanceof OpenLayers.Layer) {
				me.map.addLayer(obj);
			}
			break;
		}
	},

	/**
	 * 主題図項目レイヤ情報配列からレイヤを作成して追加します.
	 * @param referenceWMSLayerInfos 主題図項目レイヤ情報配列
	 * @param split false:１つのレイヤとして追加、true:子レイヤそれぞれで追加
	 */
	addReferenceLayer: function(referenceLayerInfos, split) {
		var me = this;
		if(!!!split) {
			this.addLayers(referenceLayerInfos);
		}
		else {
			var layerInfos = referenceLayerInfos;
			for(var key in layerInfos) {
				var info = layerInfos[key];
				var childLayerInfos = info.children;
				
				for(var key2 in childLayerInfos) {
					var childLayerInfo = childLayerInfos[key2];
					childLayerInfo.wmsURL = info.wmsURL;
					me.addLayer(childLayerInfo);
				}
			}
		}
	},

	/**
	 * 主題図（画像）項目レイヤ情報配列からレイヤを作成して追加します.
	 * @param overlayLayerInfos 主題図（画像）項目レイヤ情報配列
	 */
	addOverlayLayer: function(_overlayLayerInfos) {
		var overlayLayerInfos = [].concat(_overlayLayerInfos).reverse();
		for(var key in overlayLayerInfos) {
			var info = overlayLayerInfos[key];

			// レイヤを追加
			var layer = null;
			if (info.type == SaigaiTask.Map.Layer.Type.OVERLAY_XYZ)
				layer = new SaigaiTask.Map.Layer.XYZLayer(info);
			else
				layer = new SaigaiTask.Map.Layer.WMSLayer(info);
			this.map.addLayer(layer);
		}
	},

	/**
	 * 外部地図(ArcGIS)レイヤ情報配列からレイヤを作成して追加します.
	 * @param externalMapWMSLayerInfos 外部地図レイヤ情報配列
	 */
	addArcGISLayer: function(arcgisLayerInfos) {
		var me = this;
		var layers = [];
		for(var key in arcgisLayerInfos) {
			var info = arcgisLayerInfos[key];
			var layer = SaigaiTask.Map.Layer.newLayerFromLayerInfo(info);
			layers.push(layer);
		}

		// 先に追加したものが下になるので、逆順にする
		layers.reverse();
		me.map.addLayers(layers);
	},

	/**
	 * 外部地図レイヤ情報配列からレイヤを作成して追加します.
	 * @param externalMapWMSLayerInfos 外部地図レイヤ情報配列
	 * @param split false:１つのレイヤとして追加、true:子レイヤそれぞれで追加
	 */
	addExternalMapLayer: function(externalMapLayerInfos, split) {
		var me = this;
		var layers = [];
		for(var key in externalMapLayerInfos) {
			var info = externalMapLayerInfos[key];
			if(!!!split || info.type==SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_XYZ) {
				var layer = SaigaiTask.Map.Layer.newLayerFromLayerInfo(info);
				layers.push(layer);
			}
			else {
				var childLayerInfos = info.children;
				for(var key2 in childLayerInfos) {
					var childLayerInfo = childLayerInfos[key2];
					childLayerInfo.wmsURL = info.wmsURL;
					var layer = SaigaiTask.Map.Layer.newLayerFromLayerInfo(childLayerInfo);
					layers.push(layer);
				}
			}
		}
		
		// 先に追加したものが下になるので、逆順にする
		layers.reverse();
		me.map.addLayers(layers);
	},

	replaceHref: function(str) {
		return str.replace(/(https?\:\/\/[^\s|<]+)/ig, '<a href="#" onclick="openWin(\'$1\'); return false;">$1</a>');
	},

	//Layer Scale
	/** レイヤの標準スケールを返却 設定されていない場合は0 */
	getLayerScale: function(layerId) {
		var layerInfo = this.getLayerInfo(layerId);
		if (layerInfo) return layerInfo.scale;
		return 10000;
	},

	/** 縮尺に応じたズームレベルを返却 */
	getLayerScaleZoom: function(layerId){
		var layerScale = this.getLayerScale(layerId);
		if (layerScale == 0) return this.contentsZoomLevel;
		return this.map.getZoomForResolution(OpenLayers.Util.getResolutionFromScale(layerScale, this.map.baseLayer.units), true);
	},

	getFilterFeatureIdsByForm: function(formId){
		// フィルターを更新する
		var responseText = SaigaiTask.Map.util.jQueryUtil.submitForm('#'+formId);
		var json = eval("("+responseText+")");
		this.filter = json;
		console.log(json);

		// 登録情報をすべて再描画する
		for(var idx=0; idx<this.ecommaps.length; idx++){
			this.redrawContentsLayer(idx);
		}
	},

	/**
	 * 描画用ツールバーを表示します.
	 * @param {Object} toolbarOptions
	 * @return {Ext.toolbar.Toolbar} ツールバー
	 */
	initDrawToolbar: function(toolbarOptions) {
		var me = this;
		return new SaigaiTask.Map.view.DrawToolbar(me, toolbarOptions);
	},

	readFeatureGeometryValue: function(selector){
		var wkt = jQuery(selector).val();
		var features = null;
		if(typeof wkt!="undefined"){
			var wktFormat = new OpenLayers.Format.WKT();
			features = wktFormat.read(wkt);
		}
		return features;
	},

	/**
	 * jQueryを使います。
	 * フィーチャの値を指定クラスに書き込む
	 * @param feature
	 */
	writeFeatureGeometoryValue: function(feature){
		if(!feature) return;
		var me = this;
		var wkt = me.getWKT(feature);
		var featureId = feature.fid;
		switch(feature.geometry.CLASS_NAME){
		case "OpenLayers.Geometry.Point":
		case "OpenLayers.Geometry.LineString":
		case "OpenLayers.Geometry.Polygon": // 四角形も含む
		default:
			// 値を書き込む
			if(me.usejQuery){
				var c = "."+featureId;
				var jqueryObj = jQuery(c);
				jqueryObj.val(wkt);
			}
			break;
		}
	},

	/**
	 * フィーチャをWKTで取得します.
	 * @param feature フィーチャ
	 * @returns wkt なければ null
	 */
	getWKT: function(feature) {
		if(!feature) return;
		feature = feature.clone();
		var geometry = feature.geometry;
		var wkt = null;
		switch(geometry.CLASS_NAME){
		case "OpenLayers.Geometry.Point":
		case "OpenLayers.Geometry.LineString":
		case "OpenLayers.Geometry.Polygon": // 四角形も含む
		default:
			feature.geometry.transform(new OpenLayers.Projection("EPSG:"+this.epsg), new OpenLayers.Projection("EPSG:4326"));
			var wktFormat = new OpenLayers.Format.WKT();
			wkt = wktFormat.write(feature);
			break;
		}
		return wkt;
	},

	//=====================================================================
	//イベントの自動バインド
	//=====================================================================
	/**
	 * jQuery を使ってクリックイベントを指定のクラスに追加する
	 */
	bindMapEvent: function(){
		if(!this.usejQuery)return;
		// jQuery の初期化関数でイベントをバインドする
		var m = this;
		jQuery(document).ready(function(){
			var mClass = m.div;
			// zoom in
			var zoomInClass = "."+mClass+"ZoomIn";
			console.log("zoomInClass: "+zoomInClass);
			var zoomInElems = jQuery(zoomInClass);
			zoomInElems.each(function(){
				jQuery(this).click(function(){
					m.zoomIn();
				});
			});
			// zoom out
			var zoomOutClass = "."+mClass+"ZoomOut";
			console.log("zoomOutClass: "+zoomOutClass);
			var zoomOutElems = jQuery(zoomOutClass);
			zoomOutElems.each(function(){
				jQuery(this).click(function(){
					m.zoomOut();
				});
			});
			// 選択
			var navigationClass = "."+mClass+"Navigation";
			console.log("navigationClass: "+navigationClass);
			navigationElems = jQuery(navigationClass);
			navigationElems.each(function(){
				jQuery(this).click(function(){
					m.setNavigationControlActivation(true);
				});
			});
			// 移動
			var moveClass = "."+mClass+"Move";
			console.log("moveClass: "+moveClass);
			moveElems = jQuery(moveClass);
			moveElems.each(function(){
				jQuery(this).click(function(){
					m.setDragPanControlActivation(true);
				});
			});

		});
	},

	//=====================================================================
	//OpenLayersラッパーメソッド
	//=====================================================================

	/** control **/
	/**
	 * コントローラをOpenLayersに追加する
	 * キーがあれば連想配列に保存する
	 * @param control コントローラ
	 * @param key 連想配列のキー
	 */
	addControl: function(control, key) {
		if(typeof key!='undefined'){
			this.controls[key]=control;
		}
		return this.map.addControl(control);
	},

	setControlActivation: function(control,activation) {
		if(activation)return control.activate();
		else return control.deactivate();
	},

	getNavigationControlKey: function() {
		return "navigation";
	},

	/**
	 * マウス操作コントロールをすべて解除して選択コントロールにする
	 * マウスカーソルの変更にjQueryを使います。
	 */
	deactivateMouseControl: function() {
		this.setNavigationControlActivation(false); // 選択
		this.setDragPanControlActivation(false); // 移動
		this.clickHandler.deactivate(); // クリック時のポップアップ
		// 地図ポップアップ無効時にKMLのポップアップも無効にする
		var kmlSelectControl = this.controls.kmlSelectControl;
		if(kmlSelectControl.active) {
			kmlSelectControl.deactivate();
		}

		// マウスカーソル
		if(this.usejQuery){
			jQuery("#"+this.div).css("cursor","default");
		}
	},

	/**
	 * 選択
	 */
	setNavigationControlActivation: function(activation) {
		var key = this.getNavigationControlKey();
		var control = this.controls[key];
		if(!control)return;
		if(typeof activation=="undefined"){
			// 指定がなければ反転する
			activation = !control.active;
		}

		if(activation){
			this.deactivateMouseControl();
			this.clickHandler.activate();
			// clickHandler の後に kmlSelectControl を有効にしないと、
			// KMLフィーチャクリックとclickHandlerの両方のイベントが発生するので注意
			var kmlSelectControl = this.controls.kmlSelectControl;
			// KMLSelectControlがすでに有効になっている場合は一旦無効にして再度有効化する
			if(kmlSelectControl.active) {
				kmlSelectControl.deactivate();
			}
			kmlSelectControl.activate();
		}

		return this.setControlActivation(control, activation);
	},

	/**
	 * 移動
	 * マウスカーソルの変更にjQueryを使います。
	 */
	setDragPanControlActivation: function(activation) {
		var key = this.getNavigationControlKey();
		var control = this.controls[key];
		if(!control)return;
		if(typeof activation=="undefined"){
			// 指定がなければ反転する
			activation = !control.active;
		}

		if(activation){
			this.deactivateMouseControl();
			this.clickHandler.deactivate();
			// マウスカーソル
			if(this.usejQuery){
				jQuery("#"+this.div).css("cursor","move");
			}
		}
		return this.setControlActivation(control, activation);
	},

	/**
	 * 中心位置をWGS84で取得します.
	 * @return {OpenLayers.LonLat} EPSG:4326のLonLat
	 */
	getCenter: function() {
		var center = this.map.getCenter();
		if(center==null) return null;
		return center.transform(this.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));
	},

	/**
	 * @param {OpenLayers.LonLat} EPSG:4326のLonLat
	 */
	setCenter: function(lonlat, zoomLevel) {
		lonlat = lonlat.transform(new OpenLayers.Projection("EPSG:4326"), this.map.getProjectionObject());

		//popup表示の場合にのみlevelを15で表示
		if(SaigaiTask.Map.util.CommonUtil.getParameter("popup")!=null || this.options.popupid!=null){
			zoomLevel = 15;//とりあえず15に固定
			return this.map.setCenter(lonlat, zoomLevel);
		}else{
			return this.map.setCenter(lonlat, zoomLevel);
		}
	},

	// pan
	pan: function(dx,dy,options) {
		return this.map.pan(dx,dy,options);
	},
	panLeft: function() {
		return this.pan(-this.pandx,0);
	},
	panTop: function() {
		return this.pan(0,-this.pandy);
	},
	panRight: function() {
		return this.pan(this.pandx,0);
	},
	panBottom: function() {
		return this.pan(0,this.pandy);
	},
	panTR: function() {
		return this.pan(this.pandx,-this.pandy);
	},
	panTL: function() {
		return this.pan(-this.pandx,-this.pandy);
	},
	panBR: function() {
		return this.pan(this.pandx,this.pandy);
	},
	panBL: function() {
		return this.pan(-this.pandx,this.pandy);
	},
	// zoom
	zoomIn: function() {
		return this.map.zoomIn();
	},
	zoomOut: function() {
		return this.map.zoomOut();
	},
	zoomTo: function(zoom) {
		return this.map.zoomTo(zoom);
	},
	/**
	 *
	 * @param {OpenLayers.Bounds} bounds EPSG:4326のbounds
	 * @param closest
	 */
	zoomToExtent: function(bounds,closest) {
		// 投影法の変換
		bounds = bounds.clone().transform(new OpenLayers.Projection("EPSG:4326"), this.map.getProjectionObject());
		// zoomToExtent
		if(this.map.baseLayer) {
			return this.map.zoomToExtent(bounds,closest);
		}
		return null;
	},
	getLayer: function(idx) {
		var layers = this.map.layers;
		var layer = layers[idx];
		return layer;
	},

	// layer visibility
	setLayerVisibility: function(idx,visibility) {
		var layer = this.getLayer(idx);
		layer.setVisibility(visibility);
	},
	getLayerVisibility: function(idx) {
		var layer = this.getLayer(idx);
		return layer.getVisibility();
	},
	toggleLayerVisibility: function(idx) {
		var visibility = ! this.getLayerVisibility(idx);
		this.setLayerVisibility(idx,visibility);
	},
	/**
	 * 指定レイヤを最前面に表示する
	 * @param {OpenLayers.Layer.Layer} layer
	 */
	toFront: function(layer) {
		var me = this;
		var layers = me.map.layers, layersIdx=null, l, newZIndex=0;
		for(layersIdx in layers) {
			l = layers[layersIdx];
			if(l.id==layer.id){
				newZIndex = Math.max(Number(l.getZIndex()), newZIndex);
			}
			else {
				newZIndex = Math.max(Number(l.getZIndex())+1, newZIndex);
			}
		}
		layer.setZIndex(newZIndex);
	},
	/**
	 * ベースレイヤを切り替える
	 * @param 切り替えたいベースレイヤのID
	 */
	setBaseLayerById: function(layerId) {
		if(layerId){
			var layer = this.baseLayer[layerId];
			return this.setBaseLayer(layer);
		}
	},
	/**
	 * ベースレイヤを切り替える
	 * @param 切り替えたいベースレイヤ
	 */
	setBaseLayer: function(layer) {
		if(layer){
			// visibility を更新
			var ecommap = this.ecommaps[0];
			var baseLayerInfos = ecommap.getBaseLayerInfos();
			for(var idx in baseLayerInfos) {
				var baseLayerInfo = baseLayerInfos[idx];
				baseLayerInfo.visibility = (layer.layerInfo.layerId==baseLayerInfo.layerId);
			}
			//this.map.baseLayer.layerInfo.visibility = false;
			//layer.layerInfo.visibility = true;
			return this.map.setBaseLayer(layer);
		}
	},
	/**
	 * コンテンツレイヤ情報を取得する
	 * @param ecommapIdx eコミマップ情報インデックス
	 * @param layerId 登録情報レイヤID
	 * @return 登録情報レイヤの情報
	 */
	findContentsLayerInfo: function(ecommapIdx, layerId) {
		var ecommap = this.ecommaps[ecommapIdx];
		var contentsLayers = ecommap.contentsLayers;
		for(var key in contentsLayers){
			var layer = contentsLayers[key];
			if(layer.layerId==layerId) return layer;
		}
		return null;
	},
	/**
	 * レイヤの検索対象フラグを設定します.
	 * @param {String} layerId
	 * @param {Boolean} searchable 検索に含めるかどうか
	 */
	setLayerSearchable: function(layerId, searchable) {
		var me = this;
		var layerInfo = me.getLayerInfo(layerId);
		if(layerInfo!=null) {
			layerInfo.searchable = searchable;
		}
	},

	/** <span class="ja">度単位の解像度を地図の解像度に変更 </span><span class="en">Convert map resolution to degree unit</span>*/
	toMapResolution: function(reso) {
		if (this.epsg == 4326) return reso;
		return reso * OpenLayers.INCHES_PER_UNIT.dd/OpenLayers.INCHES_PER_UNIT[this.map.units];
	},

	////////////////////////////////////////////////////////////////
	/** 地図のdivをfocusして地図外のfocusを解除 */
	focus : function()
	{
		this.map.div.tabIndex = 0;
		this.map.div.focus();
	},
	/** 地図がfocusされているか */
	isFocus : function()
	{
		return document.activeElement == this.map.div;
	}

};
/* ======================================================================
    SaigaiTask/Map/Layer.js
   ====================================================================== */

/**
 * SaigaiTask.Map.Layerパッケージ
 * @requires SaigaiTask/Map.js
 */
SaigaiTask.Map.Layer = {
	/**
	 * レイヤ情報のレイヤ種別に合うレイヤクラスを探してレイヤを生成する.
	 * 該当するレイヤがなければＷＭＳレイヤで生成する
	 */
	newLayerFromLayerInfo: function(layerInfo) {
		var layer = null;
		if(layerInfo) {
			// レイヤ種別に対応するクラスがあればそれで生成する
			var type = layerInfo.type;
			for(var key in SaigaiTask.Map.Layer) {
				// レイヤクラスかチェック
				if(typeof SaigaiTask.Map.Layer[key]=="function" && typeof SaigaiTask.Map.Layer[key].type!="undefined") {
					// 複数対応のため配列にする
					var types = SaigaiTask.Map.Layer[key].type;
					if($.isArray(SaigaiTask.Map.Layer[key].type)==false) types = [SaigaiTask.Map.Layer[key].type];
					for(var typesIdx in types) {
						// レイヤ種別をチェック
						if(type==types[typesIdx]) {
							// 引数にlayerInfoを渡してレイヤを生成
							layer = new SaigaiTask.Map.Layer[key](layerInfo);
							break;
						}
					}
				}
			}
			// レイヤ種別で見つからない場合は
			// WMSレイヤを生成する
			if(layer==null) {
				layer = new SaigaiTask.Map.Layer.WMSLayer(layerInfo);
			}
		}
		return layer;
	}
};
/* ======================================================================
    SaigaiTask/Map/Layer/Type.js
   ====================================================================== */

/**
 * レイヤー種別
 * @requires SaigaiTask/Map/Layer.js
 */
SaigaiTask.Map.Layer.Type = {

		/**
		 * レイヤグループ（汎用）
		 * SaigaiTask オリジナルタイプ
		 */
		GROUP: 0,

		// 登録情報レイヤ
		/**
		 * eコミのローカルGeoServerで持っているコンテンツレイヤ
		 */
		LOCAL: 1,

		/**
		 * eコミのグループ化用のコンテンツを持たないレイヤ
		 */
		LOCAL_GROUP: 10,

		// 主題図項目レイヤ初期化
		/**
		 * eコミの外部WMSの参照用コンテンツレイヤ
		 */
		REFERENCE: 51,

		/**
		 * eコミの外部参照地図のWMSのレイヤを子に持つレイヤ LAYERパラメータは付けない
		 */
		REFERENCE_WMS: 59,

		// ベースレイヤ
		/**
		 * WMSベースレイヤ
		 */
		BASE_WMS: 1100,

		/**
		 * eコミのタイルキャッシュベースレイヤ
		 */
		TILED: 1150,

		/**
		 * eコミのOpenLayers.Layer.TileCache ベースレイヤ
		 */
		TILECACHE: 1152,

		/**
		 * eコミのOpenStreetMapレイヤ
		 */
		OSM: 1153,

		/**
		 * eコミのOpenLayers.Layer.GOOGLE ベースレイヤ
		 */
		GOOGLE: 1155,

		/**
		 * eコミのwebtis.Layer.BaseMap（電子国土）
		 */
		WEBTIS: 1160,
		/** OpenLayers.Layer.XYZTile ベースレイヤ */
		BASE_XYZ: 1170,

		/**
		 * eコミのXYZレイヤの背景地図
		 */
		BASE_XYZ: 1170,

		/** KMLレイヤ */
		KML: 130,

		// 主題図（画像）項目レイヤ初期化
		OVERLAY_WMS: 100,
		OVERLAY_WMS_SINGLE: 101,
		OVERLAY_TILED: 150,
		OVERLAY_TILECACHE: 151,
		OVERLAY_OSM: 152,
		OVERLAY_XYZ: 170,

		/**
		 * 外部地図レイヤ
		 */
		EXTERNAL_MAP_WMS: 900,
		EXTERNAL_MAP_WMS_LAYERS: 901,
		EXTERNAL_MAP_XYZ: 910,

		/**
		 * ArcGISレイヤ
		 */
		EXTERNAL_MAP_ARCGIS_LAYERS: 903,

		/**
		 * ベースレイヤのレイヤ種別を配列で取得します.
		 * @returns {Array<Number>}
		 */
		getBaseLayerTypes: function() {
			return [
					SaigaiTask.Map.Layer.Type.BASE_WMS,
					SaigaiTask.Map.Layer.Type.TILED,
					SaigaiTask.Map.Layer.Type.TILECACHE,
					SaigaiTask.Map.Layer.Type.OSM,
					SaigaiTask.Map.Layer.Type.GOOGLE,
					SaigaiTask.Map.Layer.Type.WEBTIS,
					SaigaiTask.Map.Layer.Type.BASE_XYZ
				];
		},

		isBaseLayerType: function(type) {
			return jQuery.inArray(type, SaigaiTask.Map.Layer.Type.getBaseLayerTypes())!=-1;
		},

		getOverlayLayerTypes: function() {
			return [
					SaigaiTask.Map.Layer.Type.OVERLAY_WMS,
					SaigaiTask.Map.Layer.Type.OVERLAY_WMS_SINGLE,
					SaigaiTask.Map.Layer.Type.OVERLAY_TILED,
					SaigaiTask.Map.Layer.Type.OVERLAY_TILECACHE,
					SaigaiTask.Map.Layer.Type.OVERLAY_OSM,
					SaigaiTask.Map.Layer.Type.OVERLAY_XYZ
				];
		},

		isOverlayLayerType: function(type) {
			return jQuery.inArray(type, SaigaiTask.Map.Layer.Type.getOverlayLayerTypes())!=-1;
		},

		getExternalmapLayerTypes: function() {
			return [
					SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS,
					SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS_LAYERS,
					SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_XYZ,
					SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_ARCGIS_LAYERS
				];
		},

		isExternalmapLayerType: function(type) {
			return jQuery.inArray(type, SaigaiTask.Map.Layer.Type.getExternalmapLayerTypes())!=-1;
		},

		getArcGISLayerTypes: function() {
			return [
					SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_ARCGIS_LAYERS
				];
		},

		isArcGISLayerType: function(type) {
			return jQuery.inArray(type, SaigaiTask.Map.Layer.Type.getArcGISLayerTypes())!=-1;
		}
};
/* ======================================================================
    OpenLayers/Layer/XYZZoom.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * requires OpenLayers/Layer/Grid.js
 */

/** 
 * Class: OpenLayers.Layer.XYZZoom
 * The XYZ class is designed to make it easier for people who have tiles
 * arranged by a standard XYZ grid. 
 * 
 * This clone from OpenLayers.Layer.XYZ.
 * Customized for digital zoom and tile direction.
 * 
 * Inherits from:
 *	- <OpenLayers.Layer.Grid>
 */
OpenLayers.Layer.XYZZoom = OpenLayers.Class(OpenLayers.Layer.Grid, {
	
	isBaseLayer: true,
	
	sphericalMercator: false,
	
	zoomOffset: 0,
	
	serverResolutions: null,
	
	/** 最大ズームレベル これを超えたらデジタルズーム */
	maxZoomLevel : 22,
	
	/** 変更前のタイルサイズ OpenLayers.Size*/
	orgTileSize : null,
	
	/**
	 * Constructor: OpenLayers.Layer.XYZ
	 *
	 * Parameters:
	 * name - {String}
	 * url - {String}
	 * options - {Object} Hashtable of extra options to tag onto the layer
	 */
	initialize: function(name, url, options) {
		if (options && options.sphericalMercator || this.sphericalMercator) {
			options = OpenLayers.Util.extend({
				projection: "EPSG:900913",
				numZoomLevels: 22
			}, options);
		}
		
		if (options) {
			if (options.maxZoomLevel > 0) this.maxZoomLevel = options.maxZoomLevel;
			//Gridには送らない
			delete options.maxZoomLevel;
		}
		
		OpenLayers.Layer.Grid.prototype.initialize.apply(this, [
			name || this.name, url || this.url, {}, options
		]);
		
	},
	
	/**
	 * APIMethod: clone
	 * Create a clone of this layer
	 *
	 * Parameters:
	 * obj - {Object} Is this ever used?
	 * 
	 * Returns:
	 * {<OpenLayers.Layer.XYZ>} An exact clone of this OpenLayers.Layer.XYZ
	 */
	clone: function (obj) {
		
		if (obj == null) {
			obj = new OpenLayers.Layer.XYZ(this.name, this.url, this.getOptions());
		}

		//get all additions from superclasses
		obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);

		return obj;
	},

	/**
	 * Method: getURL
	 *
	 * Parameters:
	 * bounds - {<OpenLayers.Bounds>}
	 *
	 * Returns:
	 * {String} A string with the layer's url and parameters and also the
	 *			passed-in bounds and appropriate tile size specified as
	 *			parameters
	 */
	getURL: function (bounds) {
		var xyz = this.getXYZ(bounds);
		var url = this.url;
		if (OpenLayers.Util.isArray(url)) {
			var s = '' + xyz.x + xyz.y + xyz.z;
			url = this.selectUrl(s, url);
		}
		
		return OpenLayers.String.format(url, xyz);
	},
	
	/**
	 * Method: getXYZ
	 * Calculates x, y and z for the given bounds.
	 *
	 * Parameters:
	 * bounds - {<OpenLayers.Bounds>}
	 *
	 * Returns:
	 * {Object} - an object with x, y and z properties.
	 */
	getXYZ: function(bounds) {
		bounds = this.adjustBounds(bounds);
		var res = this.getServerResolution();
		var x = Math.round((bounds.left - this.maxExtent.left) / (res * this.tileSize.w));
		var y = Math.round((this.maxExtent.top - bounds.top) / (res * this.tileSize.h));
		var z;
		if (this.map.getZoom() > this.maxZoomLevel) {
			z = this.maxZoomLevel;
			if (this.zoomOffset) z += this.zoomOffset;
		} else {
			z = this.getServerZoom();
		}
		
		if (this.wrapDateLine) {
			var limit = Math.pow(2, z);
			x = ((x % limit) + limit) % limit;
		}
		
		return {'x': x, 'y': y, 'z': z};
	},
	
	/* APIMethod: setMap
	 * When the layer is added to a map, then we can fetch our origin 
	 *	  (if we don't have one.) 
	 * 
	 * Parameters:
	 * map - {<OpenLayers.Map>}
	 */
	setMap: function(map) {
		OpenLayers.Layer.Grid.prototype.setMap.apply(this, arguments);
		if (!this.tileOrigin) { 
			this.tileOrigin = new OpenLayers.LonLat(this.maxExtent.left, this.maxExtent.bottom);
		}
	},
	
	moveTo: function(bounds, zoomChanged, dragging) {
		if (zoomChanged) {
			var dz = this.map.getZoom() - this.maxZoomLevel;
			if (dz > 0) {
				//タイルサイズ変更
				var rate = Math.pow(2, dz);
				this.tileSize = new OpenLayers.Size(
					this.orgTileSize.w * rate, this.orgTileSize.h * rate
				);
			} else {
				this.tileSize = this.orgTileSize;
			}
		}
		return OpenLayers.Layer.Grid.prototype.moveTo.apply(this, arguments);
	},
	
	setTileSize: function(size) {
		OpenLayers.Layer.Grid.prototype.setTileSize.apply(this, [size]);
		this.orgTileSize = this.tileSize;
	},
	
	CLASS_NAME: "OpenLayers.Layer.XYZZoom"
});
/* ======================================================================
    OpenLayers/Layer/GSITile.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * requires OpenLayers/Layer/Grid.js
 * @requires OpenLayers/Layer/XYZZoom.js
 */

/**
 * Class: OpenLayers.Layer.XYZ
 * The XYZ class is designed to make it easier for people who have tiles
 * arranged by a standard XYZ grid.
 *
 * Inherits from:
 *	- <OpenLayers.Layer.Grid>
 */
OpenLayers.Layer.GSITile = OpenLayers.Class(OpenLayers.Layer.XYZZoom,
{
	gsiInfos : {
		STD:{url:"http://cyberjapandata.gsi.go.jp/xyz/std/${z}/${x}/${y}.png",maxZoomLevel:18}, //2～18
		ORT:{url:"http://cyberjapandata.gsi.go.jp/xyz/ort/${z}/${x}/${y}.jpg",maxZoomLevel:18}, //2～18
		GAZO1:{url:"http://cyberjapandata.gsi.go.jp/xyz/gazo1/${z}/${x}/${y}.jpg",maxZoomLevel:17}, //10～17
		GAZO2:{url:"http://cyberjapandata.gsi.go.jp/xyz/gazo2/${z}/${x}/${y}.jpg",maxZoomLevel:17}, //15～17
		GAZO3:{url:"http://cyberjapandata.gsi.go.jp/xyz/gazo3/${z}/${x}/${y}.jpg",maxZoomLevel:17}, //15～17
		GAZO4:{url:"http://cyberjapandata.gsi.go.jp/xyz/gazo4/${z}/${x}/${y}.jpg",maxZoomLevel:17}, //15～17
		TOHO1:{url:"http://cyberjapandata.gsi.go.jp/xyz/toho1/${z}/${x}/${y}.jpg",maxZoomLevel:17}, //15～17
		TOHO2:{url:"http://cyberjapandata.gsi.go.jp/xyz/toho2/${z}/${x}/${y}.jpg",maxZoomLevel:18}, //15～18
		TOHO3:{url:"http://cyberjapandata.gsi.go.jp/xyz/toho3/${z}/${x}/${y}.jpg",maxZoomLevel:18}, //15～18
		TOHO4:{url:"http://cyberjapandata.gsi.go.jp/xyz/toho4/${z}/${x}/${y}.jpg",maxZoomLevel:18}, //15～18
		PALE:{url:"http://cyberjapandata.gsi.go.jp/xyz/pale/${z}/${x}/${y}.png",maxZoomLevel:18}, //12～18
		//RELIEF:{url:"http://cyberjapandata.gsi.go.jp/xyz/relief/${z}/${x}/${y}.png",maxZoomLevel:15}, //5～15
		BLANK:{url:"http://cyberjapandata.gsi.go.jp/xyz/blank/${z}/${x}/${y}.png",maxZoomLevel:14} //5～14
	},
	//5-14 航空写真広域用
	BLANK_MAP_URL : "http://cyberjapandata.gsi.go.jp/xyz/blank/${z}/${x}/${y}.png",

	type : "STD",

	/** 標準のクレジット表記 */
	GSI_ATTRIBUTION : ((("<a href=\"https://maps.gsi.go.jp/development/ichiran.html\" target=\"_blank\">国土地理院</a>"))),


	initialize: function(name, type, options)
	{
		this.type = type;
		var gsiInfo = this.gsiInfos[type];

		if (!options) options = {};
		options.projection =  "EPSG:900913";

		this.url = gsiInfo.url;
		this.maxZoomLevel = gsiInfo.maxZoomLevel;

		//標準クレジットを設定
		this.attribution = this.GSI_ATTRIBUTION;

		OpenLayers.Layer.Grid.prototype.initialize.apply(this, [
			name || this.name, this.url, {}, options
		]);
	},

	clone: function (obj) {

		if (obj == null) {
			obj = new OpenLayers.Layer.GSITile(this.name, this.url, this.getOptions());
		}
		//get all additions from superclasses
		obj = OpenLayers.Layer.XYZZoom.prototype.clone.apply(this, [obj]);

		return obj;
	},

	getURL: function (bounds) {
		var xyz = this.getXYZ(bounds);
		var url = this.url;

		// 地図画面が HTTPS の場合は地理院タイルもHTTPSにする
		if(window.location.protocol=="https:") {
			url = url.replace("http:", "https:")
		}

		//航空写真はズームレベルに応じてURLを切り替える
		if (this.type == "PALE") {
			if (xyz.z < 12) {
				url = this.gsiInfos.STD.url;//標準地図
			}
		} else if (this.type != "STD" && this.type != "ORT") {
			if (xyz.z < 10 || (this.type != "GAZO1" && xyz.z < 15)) {
				url = this.BLANK_MAP_URL;
			}
		}

		if (OpenLayers.Util.isArray(url)) {
			var s = '' + xyz.x + xyz.y + xyz.z;
			url = this.selectUrl(s, url);
		}

		return OpenLayers.String.format(url, xyz);
	},

	moveTo: function(bounds, zoomChanged, dragging) {
		if (zoomChanged) {
			var z = this.map.getZoom();
			//attribution入れ替え
			var update = this.attribution == this.GSI_ATTRIBUTION;
			if (this.type == "STD" && 5 <= z && z <= 8) {
				this.attribution =
					"The bathymetric contours are derived from those contained within the GEBCO Digital Atlas,"
					+"published by the BODC on behalf of IOC and IHO (2003) (http://www.gebco.net)<br/>"
					+((("海上保安庁許可第２２２５１０号（水路業務法第２５条に基づく類似刊行物）<br/>")))
					//+lang.__("Japan Coast Guard permission No. 222510 (similar publications based on the waterway business Law Article 25)<br/>")
					+this.GSI_ATTRIBUTION;
			} else if (this.type == "ORT" && 5 <= z && z <= 12) {
				this.attribution =
					((("データソース：Landsat8画像(GSI,TSIC,GEO Grid/AIST), 海底地形(GEBCO)<br/>")))
					+this.GSI_ATTRIBUTION;
			} else {
				this.attribution = this.GSI_ATTRIBUTION;
			}
			//attributionコントロール更新
			if (update) {
				var controls = this.map.controls;
				for (var i=0; i<controls.length; i++) {
					if (controls[i].updateAttribution) controls[i].updateAttribution();
				}
			}
		}
		return OpenLayers.Layer.XYZZoom.prototype.moveTo.apply(this, arguments);
	},

	CLASS_NAME: "OpenLayers.Layer.GSITile"
});
/* ======================================================================
    SaigaiTask/Map/Layer/WebtisLayer.js
   ====================================================================== */

///**
// * WEBTIS Layer (電子国土)
// * 
// * 以下の読込が必要.
// * <script type="text/javascript" src="http://portal.cyberjapan.jp/sys/v4/webtis/webtis_v4.js" charset="UTF-8"></script>
// * <link rel="stylesheet" type="text/css" href="http://portal.cyberjapan.jp/sys/v4/css/webtis.css">
// * 
// * @requires SaigaiTask/Map/Layer.js
// * @requires SaigaiTask/Map/Layer/Type.js
// */
//SaigaiTask.Map.Layer.WebtisLayer = new OpenLayers.Class(webtis.Layer.BaseMap, {
//	layerInfo: null,
//	initialize: function(layerInfo) {
//		this.layerInfo = layerInfo;
//		var layerID1 = "JAIS", layerID2 = "BAFD1000K", layerID3 = "BAFD200K", layerID4 = "DJBMM", layerID5 = "FGD";
//		var featureIds = layerInfo.featuretypeId.split(",");
//		if(featureIds.length>=5){
//			layerID1 = featureIds[0];
//			layerID2 = featureIds[1];
//			layerID3 = featureIds[2];
//			layerID4 = featureIds[3];
//			layerID5 = featureIds[4];
//		}
//		var dataset = {0 : { dataId : "" }, 1 : { dataId : "" }, 2 : { dataId : "" }, 3 : { dataId : "" }, 4 : { dataId : "" },
//			5 : { dataId : layerID1 }, 6 : { dataId : layerID1 }, 7 : { dataId : layerID1 }, 8 : { dataId : layerID1 }, 9 : { dataId : layerID2 },
//			10 : { dataId : layerID2 }, 11 : { dataId : layerID2 }, 12 : { dataId : layerID3 }, 13 : { dataId : layerID3 }, 14 : { dataId : layerID3 },
//			15 : { dataId : layerID4 }, 16 : { dataId : layerID4 }, 17 : { dataId : layerID4 }, 18 : { dataId : layerID5 },
//			19 : { dataId : "" }, 20 : { dataId : "" } , 21 : { dataId : "" } };
//
//		//著作権情報
//		var name = layerInfo.name;
//		webtis.Layer.BaseMap.prototype.initialize.apply(this, [name, {dataSet: dataset, isBaseLayer: true}]);
//		if (layerInfo.attribution) {
//			//hack
//			this.updateAttribution = this.updateAttributionIE7;
//			this.attributionTemplate = "<br/>"+layerInfo.attribution+"<br/>"+this.attributionTemplate+"<br/>";
//		}
//	}
//});

/**
 * WEBTIS Layer (電子国土)
 * 標準的なXYZ座標系の地理院タイルと呼ばれる仕様ができた.
 * webtis_v4.js を使わずに OpenLayers の標準のクラスで取得できるようになった。
 * @requires OpenLayers/Layer/XYZZoom.js
 * @requires OpenLayers/Layer/GSITile.js
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 */
SaigaiTask.Map.Layer.WebtisLayer = new OpenLayers.Class(OpenLayers.Layer.GSITile, {
	layerInfo:null,
	initialize: function(layerInfo) {
		this.layerInfo = layerInfo;
		OpenLayers.Layer.GSITile.prototype.initialize.apply(this, [layerInfo.name, layerInfo.featuretypeId]);
		
	}
});

SaigaiTask.Map.Layer.WebtisLayer.type = SaigaiTask.Map.Layer.Type.WEBTIS;
/* ======================================================================
    SaigaiTask/Map/API.js
   ====================================================================== */

/**
 * SaigaiTaskのAPIインタフェースを定義します.
 * @requires SaigaiTask/Map.js
 */
SaigaiTask.Map.API = OpenLayers.Class({

	contextPath: null,

	/**
	 * SaigaiTask.Mapオブジェクト
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	initialize: function(contextPath) {
		var me = this;

		me.contextPath = contextPath;

		// SaigaiTask.Map.API.[サブAPI名] のクラスをロードする
		// サブAPIの変数名は小文字とする
		for(var subApiName in SaigaiTask.Map.API) {
			var subApi = SaigaiTask.Map.API[subApiName];
			if(typeof subApi=="function") {
				var subApiVarName = subApiName.toLowerCase()
				me[subApiVarName] = new subApi(me);
			}
		}
	},

	errorMsg: function(jqXHR) {
		return "\n\n[HTTP status code "+jqXHR.status+"]";
	},

	/**
	 * エラーメッセージを表示します.
	 */
	showError: function(jqXHR) {
		alert(lang.__("Failed to get data.<!--2-->")+this.errorMsg(jqXHR));
	},

	/**
	 * eコミマップの地図初期化データを取得します.
	 * @param {Number} mapId 地図ID
	 * @param success コールバック関数
	 */
	getEcommapInfo: function(mapId, success) {
		var me = this;
		var url = me.url.ecommapInfoURL;
		jQuery.ajax(url, {
			async: true,
			dataType: "json",
			data: {
				mapId: mapId
			},
			success: function(data, textStatus, jqXHR) {
				if(jQuery.isFunction(success)) {
					success(data);
				}
			},
			error: function(jqXHR, status, errorThrown) {
				if(jqXHR.status!=0) {
					alert(lang.__("Failed to get initialization map data. (mapId=")+mapId+")"+me.errorMsg(jqXHR));
				}
				console.error(errorThrown);
			}
		});
	},

	/**
	 * 登録情報を1件取得します.
	 * @param mid 地図ID
	 * @param layer レイヤID
	 * @param fid フィーチャID
	 * @param center 中心位置
	 * @param bbox 矩形検索で使ったbbox
	 * @param success コールバック関数
	 */
	getContent: function(mid, layer, fid, center, bbox, success) {
		try {
			var me = this;
			var layerInfo = me.stmap.getLayerInfo(layer);
			if(!layerInfo) return; // layer not found
			var url = this.url.contentsGetURL;
			url += "?"+"layer="+layer+"&fid="+fid;
			if(mid!=null) {
				url += "&mid="+mid;
			}
			var time = layerInfo.getTime();
			if(time==null) time = SaigaiTask.PageURL.getTime();
			if(!!time) {
				var iso8601Time = time.toISOString();
				// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
				if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
					iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
				}
				if(!!time) url += "&time="+iso8601Time;
			}

			jQuery.ajax(url, {
				async: true,
				dataType: "json",
				cache: false,
				//headers: {
				//	"X-CSRF-Token": SaigaiTask.csrfToken
				//},
				success: function(data, textStatus, jqXHR) {
					if(jQuery.isFunction(success)) {
						success(data);
					}
				},
				error: function(jqXHR, status, errorThrown) {
					var errorMsg = "\n\n[HTTP status code "+jqXHR.status+"]";
					alert(lang.__("Failed to get data.<!--2-->")+errorMsg);
					console.error(errorThrown);
				}
			});
		} catch (e) { console.error(e); }
	},

	/**
	 * 登録情報を1件削除します.
	 * @param layer レイヤID
	 * @param fid フィーチャID
	 * @param success コールバック関数
	 */
	deleteContent: function(layer, fid, success) {
		try {
			var url = this.url.contentsDeleteURL;

			jQuery.ajax(url, {
				async: true,
				data: {
					layer: layer,
					fid: fid
				},
				cache: false,
				//headers: {
				//	"X-CSRF-Token": SaigaiTask.csrfToken
				//},
				success: function(data, textStatus, jqXHR) {
					if(jQuery.isFunction(success)) {
						success(data);
					}
				},
				error: function(jqXHR, status, errorThrown) {
					var errorMsg = "\n\n[HTTP status code "+jqXHR.status+"]";
					alert(lang.__("Failed to delete data.")+errorMsg);
					console.error(errorThrown);
				}
			});
		} catch (e) { console.error(e); }
	},

	/**
	 * 矩形で登録情報を検索します.
	 * @param bbox 矩形
	 * @param cid サイトID
	 * @param mid 地図ID
	 * @param layerIds 検索レイヤID
	 * @param rule SLD表示ルール
	 * @param limit 取得数
	 * @param async 非同期通信フラグ
	 * @param success コールバック関数
	 * @returns
	 */
	searchContentsByBbox: function(bbox, cid, mid, layerIds, rule, limit, async, success) {
		var me = this;
		// オプションでURLを組み立てる
		var url = me.url.contentsBboxURL+"?";
		url += "bbox="+(bbox.join(","));
		url += "&cid="+cid;
		url += "&mid="+mid;
		url += "&layers="+layerIds.join(',');
		url += "&rule="+rule;
		url += "&limit="+limit;
		url += "&noname=true";

		// 時間パラメータを取得
		var me = this;
		var layertimes = "";
		for(var idx in layerIds) {
			var layerId = layerIds[idx];
			var layerInfo = me.stmap.getLayerInfo(layerId);
			if(layerInfo.time!=null) {
				if(layertimes.length!=0) layertimes += ",";
				var time = layerInfo.getTime();
				var iso8601Time = time.toISOString();
				// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
				if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
					iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
				}
				layertimes += layerId +","+ iso8601Time;
			}
		}
		if(0<layertimes.length) {
			url += "&layertimes="+layertimes;
		}
		var time = SaigaiTask.PageURL.getTime();
		if(!!time) {
			var iso8601Time = time.toISOString();
			// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
			if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
				iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
			}
			if(!!time) url += "&time="+iso8601Time;
		}

		// 検索する
		var result = null;
		jQuery.ajax(url, {
			async: async,
			dataType: "json",
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: function(data, textStatus, jqXHR) {
				var result = data;
				if(jQuery.isFunction(success)) {
					success(result);
				}
			},
			error: function(jqXHR, status, errorThrown) {
				var errorMsg = "\n\n[HTTP status code "+jqXHR.status+"]";
				alert(lang.__("Failed to get data.<!--2-->")+errorMsg);
				console.error(errorThrown);
			}
		});

		if(async==false) {
			return result;
		}
	},

	/**
	 * コンテンツ情報を属性・空間検索します.
	 * TODO: ExtJSのFormになっているところをこっちに移す？
	 */
	searchContents: function() {},

	/**
	 * サーバから検索範囲をWKTで取得します.
	 * 検索範囲はバッファ計算、結合したジオメトリです.
	 * @param params HTTPリクエストパラメータ
	 */
	getContentsSearchRangeWKT: function(params) {
		var me = this;
		var wkt = null;

		var url = me.url.contentsSearchRangeWKTURL;

		jQuery.ajax(url, {
			dataType: "json",
			data: params,
			async: false,
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: function(data) {
				wkt = data.items.wkt;
			}
		});
		return wkt;
	},

	/**
	 * レイヤの属性情報配列を取得します.
	 * @param layerId レイヤID
	 * @return layerInfo, attrInfos を持つJSONオブジェクト
	 */
	getAttrInfos: function(layerId) {
		var url = this.url.attrInfoURL;
		var json = null;
		jQuery.ajax({
			url: url,
			type: "GET",
			async: false,
			cache: false,
			dataType: "json",
			data: {
				layer: layerId
			},
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: function(data) {
				json = data;
			}
		});
		return json;
	},

	/**
	 * レイヤの最終更新日時を取得します.
	 */
	getLayerLastUpdateTime: function(layerInfo) {
		var url = this.url.layerLastUpdateTimeURL;
		var time = layerInfo.getTimeParam();
		var json = null;
		jQuery.ajax({
			url: url,
			type: "GET",
			async: false,
			cache: false,
			dataType: "json",
			data: {
				layer: layerInfo.layerId,
				attrIds: layerInfo.updatecolumn,
				time: time
			},
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: function(data) {
				json = data;
			}
		});
		return json;
	},

	/**
	 * SLDファイルを文字列で取得します.
	 * @param mid 地図ID
	 * @param layerId レイヤID
	 * @returns SLD文字列
	 */
	getSld: function(mid, layerId) {
		var url = this.url.sldURL;
		url += "?mid="+mid+"&layer="+layerId;

		var result = null;
		jQuery.ajax(url, {
			dataType: "text",
			async: false,
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: function(data) {
				result = data;
			}
		});
		return result;
	},

	/**
	 * 印刷処理を実行します.
	 */
	createPdf: function(params, success) {
		var url = SaigaiTask.contextPath+"/PdfServlet";
		var defaultParams = {
			// プレビュー表示ページ
			prev_row: 0,
			prev_col: 0,

			// 印刷種別
			printmap: 1,
			printlegend: 1,

			// タイトル
			maptitle: "",
			// タイトルの配置
			titlealign: 0,
			// タイトルの文字サイズ自動フラグ
			titlefontauto: 1,

			// 説明・注釈
			description: "",
			// 説明・注釈の配置
			descalign: 2,
			// 説明・注釈の文字サイズ自動フラグ
			descfontauto: 1,

			//bboxtype: "on",

			// 用紙サイズ
			pagesize: "a4",

			// 用紙向き 0: 縦, 1: 横
			rotate: 1,

			// 地図分割数
			rows: 1,
			cols: 1,

			// 地図ページマージン
			mapmt: 5,
			mapmb: 5,
			mapml: 5,
			mapmr: 5,

			// アイコンの倍率
			iconrate: 1.0,

			// 線の太さ
			linerate: 1.0,

			// スケール
			scalealign: 4,

			// 凡例の列幅の自動フラグ
			legendcolauto: 1,
			// 凡例サイズ
			legendrate: 0.8,
			// 凡例表示位置 1: 左上、 2: 右上、 3: 左下、 4: 右下
			legendpos: 3,

			legendcontents: 10,
			legendref: 10,
			legendbase: 10,

			// 凡例のマップ内余白
			legendmapmt: 3,
			legendmapmb: 3,
			legendmapmr: 3,
			legendmapml: 3,

			// 凡例の別ページ余白
			legendmt: 10,
			legendmb: 10,
			legendml: 10,
			legendmr: 10,

			// 一覧のマージン
			listmt: 10,
			listmb: 10,
			listml: 10,
			listmr: 10,
			// 一覧のマージンの自動フラグ
			listcolauto: 1,

			// 帳票表示
			listfile: 1,
			listlayers: ["c11", "c13"],

			// ヘッダ
			header_l: null,
			header_l_text: "",
			header_c: null,
			header_c_text: "",
			header_r: null,
			header_r_text: "",

			// フッタ
			fpage: 1,
			fmappage: 1,
			memoVisible: true,

			// 外枠索引
			index_enabled: 0,
			index_h: 2,
			index_cols: 6,
			index_v: 1,
			index_rows: 6,
			
			//cid: 1,
			//mid: 11,
			//sid: "ah12w8vvw20q",
			//epsg: 900913,
			//bbox: "15452148.098818863,4494180.914057751,15511294.545987,4536016.207544248",

			//登録情報の時間パラメータ
			time: null,

			//レイヤ個別の時間パラメータ 登録情報はレイヤ単位、主題図はサーバ単位、主題図画像はレイヤ単位
			//カンマ区切り "レイヤID1,時間1,レイヤID2,時間2"
			layertimes: null,

			// 登録情報のSLDルールごとの表示パラメータ
			// 例 c42:0:1:2,c50:1
			// c42はルール0番目と1番目のみ表示、c50はルール1番目のみを表示
			rule: null,

			// layers の指定がないと、eコミ地図設定で表示されたものが印刷される
			contentslayers: "",
			reflayers: "",
			kmllayers: "",
			overlaylayers: "",
			baselayer: ""
		};


		var data = {};
		Ext.applyIf(data, params);
		Ext.applyIf(data, defaultParams);
		$.ajax({
			url: url,
			type: "post",
			data: data,
			success: function(data, textStatus, jqXHR) {
				if(jQuery.isFunction(success)) {
					success(data);
				}
			}
		});
	},

	/**
	 * レイヤIDに対応するメタデータを更新します.
	 */
	updateMetadata: function(layerId) {
		var url = this.url.metadataUpdateURL;
		url += "?layer="+layerId;

		jQuery.ajax(url, {
			dataType: "text",
			async: true,
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: function(result) {
				console.log("updateMetadata: "+result)
			}
		});
	},

	/**
	 * ジオメトリを切り出します.
	 * @param {String} WKT 切り出されるジオメトリのWKT
	 * @param {String} layerId 切り出すレイヤのレイヤID
	 * @return {Object} 切り出し結果オブジェクト
	 */
	intersection: function(wkt, layerId) {
		var url = this.url.intersectionURL;

		var result = null;
		jQuery.ajax(url, {
			type: "post",
			dataType: "json",
			async: false,
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			data: {
				wkt: wkt,
				layer: layerId
			},
			success: function(data) {
				result = data;
			},
			error: function(data) {
				throw lang.__("An error occurred in cropping.");
			}
		});
		return result;
	},

	/**
	 * MGRSコードから経緯度へ変換します。
	 * @param {String} mgrs MGRSコード
	 * @return {JSONObject} 結果オブジェクト
	 */
	mgrs2lonlat: function(mgrs) {
		var url = this.url.mgrs2lonlatURL;

		var result = null;
		jQuery.ajax(url, {
			type: "get",
			dataType: "json",
			async: false,
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			data: {
				mgrs: mgrs
			},
			success: function(data) {
				result = data;
			},
			error: function(data) {
				throw lang.__("An error occurred during the conversion MGRS code into coordinates.");
			}
		});
		return result;
	},

	/**
	 * ランドマーク検索機能が有効か無効かをチェックします。
	 * @return {JSONObject} 結果オブジェクト（valid）
	 */
	landmarkValid: function() {
		var url = this.url.landmarkValidURL;
		var defer = jQuery.Deferred();
		jQuery.ajax(url, {
			type: "post",
			dataType: "json",
			async: true,
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: defer.resolve,
			error: defer.reject
		});
		return defer.promise();
	},

	/**
	 * 1件のランドマークデータを登録します。
	 * @param {String} landmark ランドマーク名
	 * @param {double} lon 10進経度
	 * @param {double} lat 10進緯度
	 * @return {JSONObject} 結果オブジェクト（landmark）
	 */
	landmarkRegist: function(landmark, lon, lat) {
		var url = this.url.landmarkRegistURL;
		var defer = jQuery.Deferred();
		jQuery.ajax(url, {
			type: "post",
			//params: 'landmark='+landmark+'&lon='+lon+'&lat='+lat,
			dataType: "json",
			async: true,
			data: {
				landmarkData: JSON.stringify([{
					landmark : landmark,
					lon : lon,
					lat : lat
				}])
			},
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: defer.resolve,
			error: defer.reject
		});
		return defer.promise();
	},

	/**
	 * ランドマーク名からランドマークデータを検索します。
	 * @param {String} landmark ランドマーク名
	 * @return {JSONObject} 結果オブジェクト（landmark,lon,lat）
	 */
	landmarkSearch: function(landmark) {
		var url = this.url.landmarkSearchURL;
		var defer = jQuery.Deferred();
		jQuery.ajax(url, {
			type: "post",
			dataType: "json",
			async: false,//取得結果を待つ必要があるので
			data: {
				landmarkData: JSON.stringify([{
					landmark : landmark
				}])
			},
			//headers: {
			//	"X-CSRF-Token": SaigaiTask.csrfToken
			//},
			success: defer.resolve,
			error: defer.reject
		});
		return defer.promise();
	}

});

/**
 * メモAPI を追加
 * @requires SaigaiTask/Map/API.js
 */
SaigaiTask.Map.API.Rakugaki = OpenLayers.Class({

	/**
	 * API オブジェクト
	 * @type {SaigaiTask.Map.API}
	 */
	api: null,

	initialize: function(api) {
		var me = this;
		me.api = api;
	},

	/**
	 * 保存
	 */
	save: function(kml) {
		var me = this;
		var url = me.api.contextPath+"/page/map/rakugaki/save/";

		var result = null;
		jQuery.ajax(url, {
			type: "post",
			dataType: "json",
			async: false,
			data: {
				kml: kml
			},
			success: function(data) {
				result = data;
			},
			error: function(data) {
				throw lang.__("Unable to save memo KML.");
			}
		});
		return result;
	},

	download: function(option) {

		var me = this;

		var defaultOption = {
			url: me.api.contextPath+"/page/map/rakugaki/download/",
			type: "get",
			dataType: "xml",
			async: false,
			success: function(data) {
				result = data;
			},
			error: function(data) {
				throw lang.__("Unable to download memo KML.");
			}
		}
		Ext.applyIf(option, defaultOption);

		var result = null;
		jQuery.ajax(option);
		return result;
	},

	lock: function() {
		var me = this;
		var defer = jQuery.Deferred();
		jQuery.ajax({
			url: me.api.contextPath+"/page/map/rakugaki/lock",
			type: "get",
			dataType: "json",
			async: true,
			cache: false,
			success: defer.resolve,
			error: defer.reject
		});
		return defer.promise();
	},

	unlock: function() {
		var me = this;
		var defer = jQuery.Deferred();
		jQuery.ajax({
			url: me.api.contextPath+"/page/map/rakugaki/unlock",
			type: "get",
			dataType: "json",
			async: true,
			cache: false,
			success: defer.resolve,
			error: defer.reject
		});
		return defer.promise();
	}
});


/**
 * 災害対応システムの AJAX API を呼び出します.
 * TODO: あとで別ファイルに移動します.
 * @requires SaigaiTask/Map/API.js
 */
SaigaiTask.Map.SaigaiTaskAPI = OpenLayers.Class(SaigaiTask.Map.API, {

	/**
	 * コンテキストパス
	 * @type {String}
	 */
	contextPath: null,

	/**
	 * AJAXでデータを取得するためのURLの連想配列
	 * @type {Object.<String, String>}
	 */
	url: {
		//===============================================================
		// eコミマップのデータを取得するためのURL
		//===============================================================
		/**
		 * eコミマップ情報を取得するURL
		 * @type {String}
		 */
		ecommapInfoURL: "/map/ecommap/info",

		/**
		 * コンテンツ情報を取得するURL
		 * @type {String}
		 */
		contentsGetURL: "/map/ecommap/contents/get",

		/**
		 * コンテンツ情報を作成するURL
		 * @type {String}
		 */
		contentsCreateURL: "/map/contents/create/",

		/**
		 * コンテンツ情報を更新するURL
		 * @type {String}
		 */
		contentsUpdateURL: "/map/ecommap/contents/update",

		/**
		 * コンテンツ情報を削除するURL
		 * @type {String}
		 */
		contentsDeleteURL: "/map/ecommap/contents/delete",

		/**
		 * コンテンツ情報を矩形で検索するURL
		 * @type {String}
		 */
		contentsBboxURL: "/map/ecommap/contents/bbox",

		/**
		 * コンテンツ情報を属性・空間検索するURL
		 * @type {String}
		 */
		contentsSearchURL: "/map/ecommap/contents/search",

		/**
		 * コンテンツ情報の空間検索の検索範囲をWKTで取得するURL
		 * @type {String}
		 */
		contentsSearchRangeWKTURL: "/map/ecommap/contents/search/range/wkt",

		/**
		 * 属性情報を取得するURL
		 * @type {String}
		 */
		attrInfoURL: "/map/ecommap/attrInfo",

		/**
		 * SLDを取得するためのURL
		 * @type {String}
		 */
		sldURL: "/map/ecommap/sld",

		/**
		 * eコミにWFSリクエストをProxyするURL
		 * @type {String}
		 */
		wfsProxyURL: "/map/ecommap/wfsProxy?&url=",

		//===============================================================
		// 災害対応システムのデータを取得するためのURL
		//===============================================================
		/**
		 * 地図の表示状態（レイアウト）を読込・保存するURL
		 */
		layoutURL: "/map/layout/",

		/**
		 * この場所についてURL
		 */
		pointInfoURL: "/map/pointinfo/"
	},

	/**
	 * API初期化
	 */
	initialize: function(contextPath) {
		var me = this;
		me.contextPath = contextPath;
		// URL初期化
		var url = me.url;
		me.url = {};
		for(var idx in url) {
			me.url[idx] = contextPath+url[idx];
		}
	},

	/**
	 * レイアウトを取得します.
	 * @param data
	 * @param success
	 */
	loadLayout: function(data, success) {
		var url = this.url.layoutURL;
		jQuery.ajax(url, {
			dataType: "json",
			data: data,
			cache: false,
			async: false,
			success: function(layout){
				if(jQuery.isFunction(success)) {
					success(layout);
				}
			},
			error: function(data){
				// do nothing
			}
		});
	},

	/**
	 * レイアウトを保存します.
	 * @param data
	 * @returns jqXHR
	 */
	saveLayout: function(data) {
		// リクエストを送信する
		var url = this.url.layoutURL;
		return jQuery.ajax(url, {
			dataType: "json",
			cache: false,
			data: SaigaiTask.Map.param(data),
			success: function(data){
				// do nothing
			},
			error: function(data){
				// do nothing
			}
		});
	}
});


/**
 * 危機管理クラウドシステムの AJAX API を呼び出します.
 * TODO: あとで別ファイルに移動します.
 * @requires SaigaiTask/Map/API.js
 */
SaigaiTask.Map.SaigaiTask2API = OpenLayers.Class(SaigaiTask.Map.API, {

	/**
	 * コンテキストパス
	 * @type {String}
	 */
	contextPath: null,

	/**
	 * AJAXでデータを取得するためのURLの連想配列
	 * @type {Object.<String, String>}
	 */
	url: {
		//===============================================================
		// eコミマップのデータを取得するためのURL
		//===============================================================
//		/**
//		 * eコミマップ情報を取得するURL
//		 * @type {String}
//		 */
//		ecommapInfoURL: "/map/ecommap/info",



		/**
		 * コンテンツ情報を取得するURL
		 * @type {String}
		 */
		contentsGetURL: "/page/map/ecommap/contents/get",

		/**
		 * コンテンツ情報を登録するURL
		 * @type {String}
		 */
		contentsCreateURL: "/page/map/ecommap/contents/create",

		/**
		 * コンテンツ情報を更新するURL
		 * @type {String}
		 */
		contentsUpdateURL: "/page/map/ecommap/contents/update",

		/**
		 * コンテンツ情報を削除するURL
		 * @type {String}
		 */
		contentsDeleteURL: "/page/map/ecommap/contents/delete",

		/**
		 * コンテンツ情報を矩形で検索するURL
		 * @type {String}
		 */
		contentsBboxURL: "/page/map/ecommap/contents/bbox",

//		/**
//		 * コンテンツ情報を属性・空間検索するURL
//		 * @type {String}
//		 */
//		contentsSearchURL: "/map/ecommap/contents/search",

		/**
		 * コンテンツ情報の空間検索の検索範囲をWKTで取得するURL
		 * @type {String}
		 */
		contentsSearchRangeWKTURL: "/page/map/ecommap/contents/search/range/wkt",

		/**
		 * 属性情報を取得するURL
		 */
		attrInfoURL: "/page/map/ecommap/attrInfo",

		/**
		 * レイヤの最終更新日を取得するURL
		 * @type {String}
		 */
		layerLastUpdateTimeURL: "/page/map/ecommap/updatetime",

		/**
		 * SLDを取得するためのURL
		 * @type {String}
		 */
		sldURL: "/page/map/ecommap/sld",

		/**
		 * eコミにWFSリクエストをProxyするURL
		 * @type {String}
		 */
		wfsProxyURL: "/page/map/ecommap/wfsProxy?session_token="+SaigaiTask.csrfToken+"&_csrf="+$("meta[name='_csrf']").attr("content")+"&url=",

		/**
		 * クリアリングハウスのメタデータを更新するURL
		 */
		metadataUpdateURL: "/page/map/updatemetadata",

		/**
		 * ジオメトリの切り出しの空間演算をするURL
		 */
		intersectionURL: "/page/map/intersection",

		/**
		 * この場所についてURL
		 */
		pointInfoURL: "/page/map/pointinfo/",

		/**
		 * MGRS から 経緯度に変換するURL
		 */
		mgrs2lonlatURL: "/page/map/mgrs2lonlat",

		/**
		 * メモレイヤの保存
		 */
		rakugakiSaveURL: "/map/rakugaki/save/",

		/**
		 * ランドマーク検索機能が有効か無効かのチェック
		 */
		landmarkValidURL: "/page/map/landmark/valid/",

		/**
		 * ランドマークデータの登録
		 */
		landmarkRegistURL: "/page/map/landmark/regist/",

		/**
		 * ランドマークデータの検索
		 */
		landmarkSearchURL: "/page/map/landmark/search/"

	},

	/**
	 * API初期化
	 */
	initialize: function(contextPath) {
		var me = this;
		me.contextPath = contextPath;
		// URL初期化
		var url = me.url;
		me.url = {};
		for(var idx in url) {
			me.url[idx] = contextPath+url[idx];
		}

		// SaigaiTask.Map.APIの初期化
		SaigaiTask.Map.API.prototype.initialize.apply(this, [contextPath]);
	}
});
/* ======================================================================
    SaigaiTask/Map/Layer/TimeSeriesType.js
   ====================================================================== */

/**
 * レイヤー時系列種別
 * @requires SaigaiTask/Map/Layer.js
 */
SaigaiTask.Map.Layer.TimeSeriesType = {

		/**
		 * 時系列無し
		 */
		NONE: 0,

		/**
		 * 時系列あり 時点 time_fromのみ
		 */
		INSTANT: 10,

		/**
		 * 時系列あり 期間
		 */
		PERIOD: 11,

		/**
		 * 履歴管理
		 */
		HISTORY: 20
};

/**
 * 時間パラメータでタイムゾーン分時間をシフトするかどうかの設定
 * eコミマップがタイムゾーンをDBでもっていないための対策
 * @type Boolean
 */
SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET = false;
/* ======================================================================
    OpenLayers/Control/SelectDragFeature.js
   ====================================================================== */

/* Copyright (c) 2006-2010 by OpenLayers Contributors (see authors.txt for 
 * full list of contributors). Published under the Clear BSD license.  
 * See http://svn.openlayers.org/trunk/openlayers/license.txt for the
 * full text of the license. */

/**
 * @ requires OpenLayers/Control/SelectFeature.js
 */
/**
 * @class Featureの複数選択とドラッグ移動を可能にしたクラス.<br/>
 * 範囲選択(box=true)時はドラッグ移動不可<br/>
 * OpenLayers.Control.SelectFeature を拡張し OpenLayers.Control.DragFeature のDragを追加<br/>
 * hoverの動作は未検証<br/>
 * 
 * class: OpenLayers.Control.SelectDragFeature
 * The SelectFeature control selects vector features from a given layer on 
 * click or hover. 
 *
 * Inherits from:
 *	- <OpenLayers.Control>
 */
OpenLayers.Control.SelectDragFeature = OpenLayers.Class(OpenLayers.Control.SelectFeature, {
	
	/** Handler.Dragのcallback 追加可 */
	dragCallbacks: {},
	
	/** Handler.Featureのcallback 追加可 */
	featureCallbacks: {},
	
	/** OpenLayers.Handler.Keyboardのcallback 追加可 */
	keyboardCallbacks: {},
	
	/** マウスの下のfeature */
	mouseFeature : null,
	
	/**
	 * @since SaigaiTask-2.2
	 * @return タッチ操作の場合は true、クリック操作の場合は false
	 */
	directTouch: false,
	
	/** コントロール初期化処理
	 * @param layer コントロールを有効にするレイヤ
	 * @param options SelectFeatureと同様のオプション
	 * 
	 * Constructor: OpenLayers.Control.SelectFeature
	 * Create a new control for selecting features.
	 *
	 * Parameters:
	 * layers - {<OpenLayers.Layer.Vector>}, or an array of vector layers. The
	 *	   layer(s) this control will select features from.
	 * options - {Object} 
	 */
	initialize: function(layers, options) {
		var me = this;
		OpenLayers.Control.prototype.initialize.apply(this, [options]);
		
		if(this.scope === null) {
			this.scope = this;
		}
		this.initLayer(layers);

		this.handlers = {
			drag: new OpenLayers.Handler.Drag(
				this, OpenLayers.Util.extend({
					down: function(pixel) {
						//console.log("drag.down");
						me.downFeature(pixel);
					},
					move: function(pixel) {
						//console.log("drag.move");
						me.moveFeature(pixel);
					},
					up: function(pixel) {
						//console.log("drag.up");
						if(me.directTouch) {
							// タッチ操作ではマウスアウトが無いので、
							// タッチ終了後に即座にマウスアウト扱いにする
							me.upFeature(pixel);
							me.outFeature();
							me.handlers.drag.deactivate();
						}
						else {
							return me.upFeature(pixel);
						}
					},
					out: function(pixel) {
						//console.log("drag.out");
						me.cancel(pixel);
					},
					done: function(pixel) {
						//console.log("drag.done");
						me.doneDragging(pixel);
					}/*,
					// @since SaigaiTask-2.2
					// タッチデバイスの対応
					touchstart: function(pixel) {
						if(me.isTouchDevice()) {
							console.log("drag.touchstart");
							me.downFeature(pixel);
						}
					},
					touchmove: function(pixel) {
						if(me.isTouchDevice()) {
							console.log("drag.touchmove");
							me.moveFeature(pixel);
						}
					}
*/
				}, this.dragCallbacks),
				{documentDrag: this.documentDrag}
			),
			feature: new OpenLayers.Handler.Feature(
				this, this.layer, OpenLayers.Util.extend({
					//click: this.clickFeature, //dragのdown内から実行される
					dblclick : this.dblclickFeature,
					clickout: function() {
						if(me.isTouchDevice()) {
							me.handlers.drag.deactivate();
						}
						me.clickoutFeature();
					},
					over: this.overFeature,
					out: this.outFeature
				}, this.featureCallbacks),
				{geometryTypes: this.geometryTypes}
			),
			keyboard : new OpenLayers.Handler.Keyboard(
				this, {
					keydown: this.keydown
				}
			)
		};
		if (this.box) {
			this.handlers.box = new OpenLayers.Handler.Box(
				this, {done: this.selectBox},
				{boxDivClassName: "olHandlerBoxSelectFeature"}
			); 
		}

		// @since SaigaiTask-2.2
		// IE11の場合だとタッチ操作に対応しているためなのか、
		// IE11でマウスのクリックをしたときに touchstartイベントが発火される。
		// タイミングによってはIE11でテキストメモのダブルクリックができない場合があるため、
		// IE11ではタッチ操作をできないようにする。
		// @see OpenLayers.Handler.Feature#touchstart
		if(!me.isTouchDevice()) {
			me.handlers.feature.touchstart=null;
			//me.handlers.drag.touchstart=null;
		}
		else {
			// タッチ操作ができる場合は、
			// タッチすると clickイベントが発火されるため、
			// タッチハンドラをここで定義する
			me.handlers.feature.callbacks.click = function(feature) {
				me.directTouch = false;
				if(me.isTouchDevice()) {
					// タッチ操作ではmouseoverができないため、
					// mouseoverで dragコントロールを有効化できないのでその対策
					if(me.handlers.drag.active==false) {
						//console.log("touchclick "+feature.attributes.name);

						// ダイレクトタッチフラグをON
						me.directTouch = true;

						// イベントをdragコントロールにevtをセット
						var evt = me.handlers.feature.evt;
						me.handlers.drag.evt = evt;

						// タッチ操作ではマウスオーバが無いので、
						// タッチしたら即座にマウスオーバ扱いにする
						me.overFeature(feature);
						
						var evt = me.handlers.feature.evt;
						// クリック時にドラッグコントロールを有効にする
						//me.handlers.drag.activate();
						// タッチしてすぐにドラッグできるように
						// このクリックイベントをドラッグコントロールのdragstartを手動で呼び出す。
						// downFeatureはこの中で実行される
						me.handlers.drag.dragstart(evt)
					}
				}
				return false;
			};
		}

		// dragのデバッグ用
		var drag = this.handlers.drag;
		drag._activate = drag.activate;
		drag.activate = function(){ console.log("[drag] activate"); return drag._activate(); };
		drag._deactivate = drag.deactivate;
		drag.deactivate = function(){ console.log("[drag] deactivate"); return drag._deactivate(); };
	},
	
	/**
	 * Method: activate
	 * Activates the control.
	 * 
	 * Returns:
	 * {Boolean} The control was effectively activated.
	 */
	activate: function () {
		if (!this.active) {
			if(this.layers) {
				this.map.addLayer(this.layer);
			}
			this.handlers.feature.activate();
			this.handlers.keyboard.activate();
			if (this.box) {
				this.handlers.box.activate();
			}
		}
		return OpenLayers.Control.prototype.activate.apply(
			this, arguments
		);
	},
	
	/**
	 * Method: deactivate
	 * Deactivates the control.
	 * 
	 * Returns:
	 * {Boolean} The control was effectively deactivated.
	 */
	deactivate: function () {
		if (this.active) {
			this.handlers.feature.deactivate();
			this.handlers.keyboard.deactivate();
			this.handlers.drag.deactivate();
			if(this.box) this.handlers.box.deactivate();
			this.mouseFeature = null;
			if(this.layers) {
				this.map.removeLayer(this.layer);
			}
		}
		return OpenLayers.Control.prototype.deactivate.apply(
			this, arguments
		);
	},

	/**
	 * @since SaigaiTask-2.2
	 * @return タッチ可能なブラウザであれば true
	 */
	isTouchDevice: function() {
		// PC用chromeでもタッチ操作可能なため true になるので注意
		return 'ontouchstart' in document.documentElement;
	},
	
	/**
	 * Method: overFeature
	 * Called on over a feature.
	 * Only responds if this.hover is true.
	 *
	 * Parameters:
	 * feature - {<OpenLayers.Feature.Vector>} 
	 */
	overFeature: function(feature) {
		//console.log("overFeature");
		//console.log("feature "+feature.attributes.name);
		if(!this.handlers.drag.dragging) {
			//console.log("this.handlers.drag.activate();");
			this.handlers.drag.activate();
			this.over = true;
			this.mouseFeature = feature;
			OpenLayers.Element.addClass(this.map.viewPortDiv, this.displayClass + "Over");
		} else {
			if(this.box) this.handlers.box.deactivate();
			if(this.mouseFeature && feature && this.mouseFeature.id == feature.id) {
				this.over = true;
			} else {
				this.over = false;
			}
		}
		if(this.hover && feature) {
			if(this.highlightOnly) {
				this.highlight(feature);
			} else if(OpenLayers.Util.indexOf(
				feature.layer.selectedFeatures, feature) == -1) {
				this.select(feature);
			}
		}
	},
	
	/**
	 * Method: outFeature
	 * Called on out of a selected feature.
	 * Only responds if this.hover is true.
	 *
	 * Parameters:
	 * feature - {<OpenLayers.Feature.Vector>} 
	 */
	outFeature: function(feature) {
		//console.log("outFeature");
		//console.log("feature "+feature.attributes.name);
		if(!this.handlers.drag.dragging) {
			this.over = false;
			this.mouseFeature = null;
			if(!this.directTouch) this.handlers.drag.deactivate();
			//console.log("this.handlers.drag.deactivate();");
			OpenLayers.Element.removeClass(
				this.map.viewPortDiv, this.displayClass + "Over"
			);
		} else {
			if (this.mouseFeature && this.mouseFeature.id == feature.id) {
				this.over = false;
			}
		}
		if(this.box) this.handlers.box.activate();
		if(this.hover) {
			if(this.highlightOnly) {
				// we do nothing if we're not the last highlighter of the
				// feature
				if(feature._lastHighlighter == this.id) {
					// if another select control had highlighted the feature before
					// we did it ourself then we use that control to highlight the
					// feature as it was before we highlighted it, else we just
					// unhighlight it
					if(feature._prevHighlighter && feature._prevHighlighter != this.id) {
						delete feature._lastHighlighter;
						var control = this.map.getControl(
							feature._prevHighlighter);
						if(control) {
							control.highlight(feature);
						}
					} else {
						this.unhighlight(feature);
					}
				}
			} else {
				this.unselect(feature);
			}
		}
	},
	
	/** キーによってFeatureがマウスの下から消える可能性がある場合に呼び出す */
	outFeatureByKey : function()
	{
		this.mouseFeature = null;
	},
	
	////////////////////////////////
	/** featureダブルクリック時に呼ばれる関数 ダミー */
	onDblClick : function(){},
	/** Handler.Featureダブルクリック時に実行 */
	dblclickFeature: function(feature) {
		//console.log("dblClick");
		this.onDblClick(feature);
	},
	
	/** 地図上でのキー入力時に呼ばれる関数 ダミー */
	onKeyDown : function(){},
	/** キーイベント 地図上のみ有効になるように地図内かどうかは別途取得 */
	keydown : function(evt)
	{
		this.onKeyDown(evt);
	},
	
	////////////////////////////////
	// from DragFeature
	/**
	 * Method: downFeature
	 * Called when the drag handler detects a mouse-down.
	 *
	 * Parameters:
	 * pixel - {<OpenLayers.Pixel>} Location of the mouse event.
	 */
	downFeature: function(pixel) {
		//console.log("downFeature");
		this.lastPixel = pixel;
		// @since SaigaiTask-2.2
		// タッチ操作時にフィーチャが選択済みの場合に地図をドラッグしようとすると、
		// 地図移動ではなく、フィーチャ移動になってしまうため、
		// mouseFeatureはここで取得しなおす
		if (!!this.mouseFeature) {
			var evtFeature = this.layer.getFeatureFromEvent(this.handlers.drag.evt);
			if(this.mouseFeature!=evtFeature) {
				//console.log("overwrite mouseFeature");
				this.mouseFeature=evtFeature;
			}
			// mouseFeatureが無くなった場合は空にする
			if(!this.mouseFeature) {
				this.handlers.feature.layer.selectedFeatures = [];
			}
		}
		//キーで削除等の場合this.mouseFeatureがnullになっている DragはactiveなのでmouseDownでoutかoverの処理をする
		if (!this.mouseFeature) {
			this.mouseFeature = this.layer.getFeatureFromEvent(this.handlers.drag.evt);
			//削除等で消えた下にfeatureが無ければoutFeatureと同等の処理
			if (!this.mouseFeature) {
				this.outFeature();
				return;
			}
			this.mouseFeature.layer = this.layer;
			this.overFeature(this.mouseFeature);
		}
		//console.log("feature "+this.mouseFeature.attributes.name);
		var selected = OpenLayers.Util.indexOf(this.mouseFeature.layer.selectedFeatures, this.mouseFeature) != -1;
		if (selected) {
			//選択されていたらそのままドラッグ
			if (this.handlers.drag.evt[this.toggleKey]) {
				//トグルなら非選択
				this.unselect(this.mouseFeature);
			}
		} else {
			if (this.handlers.drag.evt[this.toggleKey]) {
				//トグルなら非選択
				this.select(this.mouseFeature);
			} else {
				//選択されていない場合は選択
				this.clickFeature(this.mouseFeature);
			}
		}
		this.onStart(this.mouseFeature, pixel, this.handlers.drag.evt[this.toggleKey]);
	},
	
	/**
	 * Method: moveFeature
	 * Called when the drag handler detects a mouse-move.  Also calls the
	 *	   optional onDrag method.
	 * 
	 * Parameters:
	 * pixel - {<OpenLayers.Pixel>} Location of the mouse event.
	 */
	moveFeature: function(pixel) {
		var me = this;
		//console.log("moveFeature");
		var res = this.map.getResolution();
		for (var i=this.layer.selectedFeatures.length-1; i>=0; i--) {
			feature = this.layer.selectedFeatures[i];
			if (feature.geometry) {
				feature.geometry.move(res * (pixel.x - this.lastPixel.x), res * (this.lastPixel.y - pixel.y));
			}
			this.layer.drawFeature(feature);
		}
		this.lastPixel = pixel;
		this.onDrag(pixel);
	},

	/**
	 * Method: upFeature
	 * Called when the drag handler detects a mouse-up.
	 * 
	 * Parameters:
	 * pixel - {<OpenLayers.Pixel>} Location of the mouse event.
	 */
	upFeature: function(pixel) {
		//console.log("upFeature");
		//console.log("feature "+this.mouseFeature.attributes.name);
		if(!this.over) {
			if(!this.isTouchDevice()) this.handlers.drag.deactivate();
		}
	},

	/**
	 * Method: doneDragging
	 * Called when the drag handler is done dragging.
	 *
	 * Parameters:
	 * pixel - {<OpenLayers.Pixel>} The last event pixel location.	If this event
	 *	   came from a mouseout, this may not be in the map viewport.
	 */
	doneDragging: function(pixel) {
		this.onComplete(pixel);
	},

	/**
	 * Method: cancel
	 * Called when the drag handler detects a mouse-out (from the map viewport).
	 */
	cancel: function() {
		//console.log("cancel");
		if(!this.isTouchDevice()) this.handlers.drag.deactivate();
		this.over = false;
	},
	////////////////////////////////
	

	/** 
	 * Method: setMap
	 * Set the map property for the control. 
	 * 
	 * Parameters:
	 * map - {<OpenLayers.Map>} 
	 */
	setMap: function(map) {
		this.handlers.feature.setMap(map);
		this.handlers.drag.setMap(map);
		this.handlers.keyboard.setMap(map);
		if(this.box) this.handlers.box.setMap(map);
		
		OpenLayers.Control.prototype.setMap.apply(this, arguments);
	},
	
	/** クラス名
	 * @final @type String */
	CLASS_NAME: "OpenLayers.Control.SelectDragFeature"
});
/* ======================================================================
    SaigaiTask/Map/view.js
   ====================================================================== */

/**
 * ビューパッケージです.
 * @requires SaigaiTask/Map.js
 */
SaigaiTask.Map.view = {};
/* ======================================================================
    SaigaiTask/Map/view/Popup.js
   ====================================================================== */

/**
 * OpenLayersのポップアップをExtJSを使って表示するクラスです.
 * @class SaigaiTask.Map.view.Popup
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.Popup = new OpenLayers.Class({

	/**
	 * ポップアップ
	 * @type {OpenLayers.Popup}
	 */
	popup: null,

	/**
	 * ポップアップのコンテンツ表示用パネル
	 * @type {Ext.panel.Panel}
	 */
	panel: null,

	initialize: function() {
	},

	/**
	 * ユニークなIDを生成する.
	 * PopupManager が使用する.
	 */
	createPopupId: function() {
		return 'extpopup-'+Ext.id();
	},

	/**
	 * ExtJS のパネル付きでポップアップを表示する
	 * @param {Object<String, *>} options オプション
	 * @param {Object<String, *>} options.searchButtonInfo 検索ボタンのオプション
	 * @param {String} options.searchButtonInfo.url 検索をリクエストするURL
	 * @param {Number} options.searchButtonInfo.mid 検索対象の地図ID
	 * @param {Array<Object.<String, *>>} options.searchButtonInfo.contentsLayers 検索対象の登録情報レイヤ情報の配列
	 * @return {OpenLayer.Popup}
	 */
	showExtPopup: function(options){
		var me = this;
		// オプション
		var map = options.map;
		var stmap = map;
		var olmap = options.olmap;
		var center = options.center;
		var items = options.items;
		var toolbarData = options.toolbarData;
		var panelWidth = options.panelWidth;
		var title = options.title;
		var pinned = (options.pinned==true);
		console.log('options');
		console.log(options);

		// ポップアップ表示
		var popupLonLat = center.clone();
		var size = options.size;
		if(!size) size = new OpenLayers.Size(300,200);
		var popupId = this.createPopupId();
		popupLonLat = popupLonLat.transform(new OpenLayers.Projection("EPSG:4326"), olmap.getProjectionObject());
		var popup = me.popup = new OpenLayers.Popup.FramedCloud("popup", popupLonLat, size, "<div id='"+popupId+"'></div>");
		popup.panMapIfOutOfView = true;
		olmap.addPopup(popup, false);
		popup.hide();
		popup.setSize(size);
		// onmouseup を上書き
		popup.events.un({
			mouseup: popup.onmouseup
		});
		popup.onmouseup = function(evt) {
			if(this.mousedown) {
				this.mousedown = false;
				// イベントを止めるとポップアップ内のExt.Button等が
				// mouseupを検知できなくなりクリックしっぱなしの状態になってしまうため
				// イベントは止めない
				//OpenLayer.Event.stop(evt, true);
			}
		};
		popup.events.on({
			mouseup: popup.onmouseup
		});

		// ポップアップマネージャーに追加
		var popupManager = map.popupManager;
		if(popupManager==null) { // 未定義なら作成
			popupManager = new SaigaiTask.Map.control.PopupManager(map);
		}
		popupManager.add(popup);
		if(pinned) {
			popupManager.pin(popup);
		}

		/**
		 * リンクを開く.
		 * ThickBoxも対応
		 */
		var openLink = function(url, TB_iframe) {
			if(url){
				var urlObj = SaigaiTask.parseURL(url);
				if(typeof urlObj.searchObject.time!="undefined") {
					var time = urlObj.searchObject.time;
					if(time=="") {
						// 時間パラメータの付与
						var time = SaigaiTask.PageURL.getTime();
						if(!!time) {
							var iso8601Time = time.toISOString();
							// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
							if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
								iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
							}
							// url に timeパラメータ付与
							time = iso8601Time;
							urlObj.searchObject.time = iso8601Time;
							url =  urlObj.toURL();
						}
					}
				}

				if(typeof TB_iframe!="undefined"){
					if(TB_iframe){
						if (url.indexOf('?') > 0)
							url = url + "&TB_iframe=false&width=950&height=700";
						else
							url = url + "?TB_iframe=true&width=950&height=700";
					}
					tb_show(/*caption*/"", url);
				}
				else {
					window.open(url);
				}
			}
		};

		// ツールバーの準備
		var toolbar = null;
		if(toolbarData){
			toolbar = new Array();

			// データの準備
			var buttonDataArray = new Array();
			if(jQuery.isArray(toolbarData.buttons)){
				buttonDataArray = buttonDataArray.concat(toolbarData.buttons);
			};

			for(var buttonDataArrayKey in buttonDataArray){
				var buttonData = buttonDataArray[buttonDataArrayKey];
				var opened = false;
				var button = (function(buttonData){
					var button = null;
					switch(buttonData.type){
					case "link":
						var handler = function(){
							openLink(buttonData.url, buttonData.TB_iframe);
						};
						button = Ext.create("Ext.Button", {
							text: buttonData.text,
							iconCls:'file-icon',
							enableToggle: false,
							handler: handler
						});
						// リンクを開くならポップアップを表示しないで処理を抜ける
						if(buttonData.open) {
							handler();
							opened = true;
						}
						break;
					case "search":
						break;
					default:
						button = Ext.create("Ext.Button", buttonData);
						break;
					}
					return button;
				})(buttonData);
				if(opened) return;
				toolbar.push(button);
			}
			// 検索ボタンの作成
			if(SaigaiTask.Map.view.Popup.searchButton) {
				var button = Ext.create("Ext.Button", {
					//text: buttonData.text,
					text: lang.__("Search"),
					iconCls:'search-icon',
					enableToggle: false,

					// 検索ダイアログを表示する
					handler: function() {
						if(stmap.popupManager!=null) {
							stmap.popupManager.closeAll();
						}
						var contentsSearchView = new SaigaiTask.Map.view.ContentsSearch(map);
						contentsSearchView.show({
							searchForm: options
						});
					}
				});
				toolbar.push(button);
			}
		}

		Ext.onReady(function(){
			popup.show();
			popup.panIntoView();

			var margin = 50; // バルーンマージン（バルーン余白分）
			var mapMaxWidth = olmap.getSize().w - margin;
			var mapMaxHeight = olmap.getSize().h - margin - 80; // -80 はバルーンが地物を指している部分の高さ
			var maxWidth = mapMaxWidth;
			var maxHeight = mapMaxHeight;

			// パネルを追加
			me.panel = Ext.create("Ext.panel.Panel", {
				//
				renderTo: popupId,
				width: panelWidth,
				autoScroll: true,
				maxWidth: maxWidth,
				maxHeight: maxHeight<600 ? maxHeight : 600, // バルーンの画像が 600px までしか対応していない
				collapsible: true,
				// headers
				title: (typeof title!="undefined"&&title!=null) ? title : "",//'ポップアップ',
				header: true,
				tools: [{
					type: 'pin',
					hidden: pinned,
					handler: function(event, toolEl, owner, tool) {
						// pin
						popupManager.pin(popup);
						// unpin に切替
						tool.hide();
						owner.child('tool[type=unpin]').show();
					}
				}, {
					type: 'unpin',
					hidden: !pinned,
					handler: function(event, toolEl, owner, tool) {
						// unpin
						popupManager.unpin(popup);
						// pin に切替
						tool.hide();
						owner.child('tool[type=pin]').show();
					}
				}, {
					type: 'close',
					handler: function(event, toolEl, owner, tool) {
						popupManager.close(popup);
					}
				}],
				tbar: toolbar,
				// body
				layout: {
					type: 'vbox',
					align: 'stretch' //,padding: 5
				},
				items: items,
				// listeners
				listeners: {
					// サイズが変わったらポップアップのサイズも変えて表示する
					resize: function(self, width, height, oldWidth, oldHeight, eOpts){
						// ポップアップのサイズを変更する
						var margin = 25;
						var size = new OpenLayers.Size(width+margin, height+margin);
						popup.setSize(size);
						SaigaiTask.Map.util.jQueryUtil.visibility('#'+popup.id, true);
					}
				}
			});

			// div の指定があれば追加する
			if(!options.div==false) {
				me.panel.update($("<div>").append(options.div).html());
			}
		});
		return popup;
	}
});

SaigaiTask.Map.view.Popup.searchButton = true;
/* ======================================================================
    SaigaiTask/Map/view/KMLPopup.js
   ====================================================================== */

/**
 * 1件分のKML情報をポップアップ表示するクラスです.
 * @class SaigaiTask.Map.view.KMLPopup
 * @requires SaigaiTask/Map/view/Popup.js
 * @see eMapBase.openKMLPopup
 */
SaigaiTask.Map.view.KMLPopup = new OpenLayers.Class(SaigaiTask.Map.view.Popup, {

	stmap: null,

	initialize: function(stmap) {
		this.stmap = stmap;
	},

	show: function(feature, layerInfo) {
		var me = this;
		var stmap = me.stmap;
		if(stmap.popupManager!=null) {
			stmap.popupManager.closeAll();
		}

		try {
			var lonlat = feature.geometry.getBounds().getCenterLonLat().clone();
			//<span class="ja">Featureは地図座標なので一旦緯度経度に戻す</span>
			//<span class="en">Because feature is map coordinate, return to longtitude-latitude once </span>
			if (me.stmap.epsg!=4326) lonlat.transform(me.stmap.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));

			var popupDiv = document.createElement('div');
			var div, span;

			//Attrs
			div = document.createElement('div');
			div.className = "popup_attr";
			//<span class="ja">aタグはtargetとhrefのみにする</span><span class="en">Set only 'target' and 'href' for 'A' tag</span>
			if (feature.attributes.description) {
				div.innerHTML = (feature.attributes.name ? "<h3>"+SaigaiTask.Map.util.CommonUtil.escapeXml(feature.attributes.name)+"</h3>" : "")
					+feature.attributes.description.replace(/<\s*a\s+/ig, '<a target="_blank" ').replace(/onclick\s*=\s*"[^"]*"/ig,'');
				//attrDiv.style.width = w+"px";
			} else if (feature.attributes.name) {
				div.innerHTML = "<h3>"+SaigaiTask.Map.util.CommonUtil.escapeXml(feature.attributes.name)+"</h3>";
			}

			try {
				var tbody = null;
				var td;
				for (var key in feature.attributes) {
					if (key != "name" && key != "description" && key != "styleUrl") {
						if (feature.attributes[key].value) {
							if (!tbody) tbody = document.createElement('tbody');
							var attrTr = document.createElement('tr');
							td = document.createElement('td');
							attrTr.appendChild(td);
							td.innerHTML = key;
							td = document.createElement('td');
							td.innerHTML = feature.attributes[key].value;
							attrTr.appendChild(td);
							tbody.appendChild(attrTr);
						}
					}
				}
				if (tbody) {
					table = document.createElement('table');
					table.cellSpacing = 0;
					table.cellPadding = 0;
					table.appendChild(tbody);
					div.appendChild(table);
				}
			} catch (e) {}

			popupDiv.appendChild(div);

			// DIV用のパネル（ヘッダーなし）
			var panel = Ext.create('Ext.panel.Panel', {
				width: 200,
				contentEl: popupDiv
			});

			// ExtPopupのオプション
			var option = {
				map: me.stmap,
				olmap: me.stmap.map,
				center: lonlat,
				items: [panel],
				title: layerInfo.name,
				pinned: false
			};
			//var extPopup = new SaigaiTask.Map.view.Popup();
			//var popup = extPopup.showExtPopup(option);
			me.showExtPopup(option);
		} catch (e) { console.error(e); }
	},

	CLASS_NAME: "SaigaiTask.Map.view.KMLPopup"
});
/* ======================================================================
    SaigaiTask/Map/control.js
   ====================================================================== */


/**
 * コントローラパッケージです.
 * @requires SaigaiTask/Map.js
 */
SaigaiTask.Map.control = {};
/* ======================================================================
    SaigaiTask/Map/control/PdfControl.js
   ====================================================================== */

/**
 * PDFを出力するクラスです.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.PdfControl = new OpenLayers.Class(OpenLayers.Control, {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * 印刷ダイアログ
	 * @type {SaigaiTask.Map.view.PrintWindow}
	 */
	printWindow: null,

	/**
	 * eコミマップベースの印刷プレビュー付き印刷ダイアログ
	 * @type {SaigaiTask.Map.view.PrintPreviewWindow}
	 */
	printPreviewWindow: null,

	initialize: function(stmap) {
		var me = this;
		me.stmap = stmap;
		me.printWindow = new SaigaiTask.Map.view.PrintWindow(me);
		if(location.href.indexOf("http://localhost")==0) {
			me.printWindow = new SaigaiTask.Map.view.PrintPreviewWindow(me);
		}
	},

	/**
	 * 印刷ダイアログを表示します.
	 */
	show: function() {
		var me = this;
		me.printWindow.win.show();
	},

	/**
	 * レイヤ情報からPDF出力リクエストパラメータをビルドする関数の定義
	 * @param {Object} params
	 * @param {SaigaiTask.Map.Layer.LayerInfo} layerInfo
	 */
	buildPdfParams: function(params, layerInfo) {
		var me = this;

		// 時間パラメータ
		var time = SaigaiTask.PageURL.getTime();
		if(!time) time = new Date();
		var iso8601Time = new Date(time).toISOString();
		// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
		if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
			iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
		}

		// レイヤ情報を追加
		switch(layerInfo.type) {
		// TODO: メモ描画の印刷
		// 登録情報の印刷(下から重ねる順に指定、後の方が上)
		// eコミマップ2.4以降では指定順が逆となる(上から重ねる順に指定、前の方が上)
		// contentslayers=c3,c2,c1
		case SaigaiTask.Map.Layer.Type.LOCAL:
			// 表示中の登録情報レイヤを取得
			var contentsLayerInfo = layerInfo;
			if(contentsLayerInfo.visibility==true) {
				// レイヤIDを追加(下から重ねる順に指定)
				//if(0<params.contentslayers.length) params.contentslayers += ",";
				//params.contentslayers += contentsLayerInfo.layerId;
				// レイヤIDを追加(上から重ねる順に指定)
				if(0<params.contentslayers.length) params.contentslayers = "," + params.contentslayers;
				params.contentslayers = contentsLayerInfo.layerId + params.contentslayers;
				// フィルタレイヤならパラメータを設定(フィルタレイヤは１つのみという前提)
				if(contentsLayerInfo.filterkey!=null) {
					params.filterkey = contentsLayerInfo.filterkey;
					params.filterLayerId = contentsLayerInfo.layerId;
				}
				// 登録情報レイヤの時間パラメータ付与
				params.time = iso8601Time;
				// 登録情報レイヤのSLDルールの表示パラメータ付与
				if(typeof contentsLayerInfo.params.rule=="string"
					&& 0<contentsLayerInfo.params.rule.length) {
					params.rule += (0<params.rule.length?",":"")+contentsLayerInfo.params.rule;
				}
			}
			break;
		// KMLレイヤの印刷
		// kmllayers:kml1974:1,kml1981:1,kml1982:1,kml1983:1
		case SaigaiTask.Map.Layer.Type.KML:
			var kmlLayerInfo = layerInfo;
			if(kmlLayerInfo.visibility==true) {
				// レイヤIDを追加
				if(0<params.kmllayers.length) params.kmllayers += ",";
				params.kmllayers += kmlLayerInfo.layerId+":1";
				// 時間パラメータは対象外
			}
			break;
		// 主題図の印刷(下から重ねる順に指定、後の方が上)
		// reflayers:[["ref3",1,"ref3_2,ref3_1,ref3_0"],["ref2",1,"ref2_2,ref2_1,ref2_0"],["ref1",1,"ref1_2,ref1_1,ref1_0"]]
		case SaigaiTask.Map.Layer.Type.REFERENCE_WMS:
			// 配列文字列をオブジェクトに変換
			var reflayers = params.reflayers.length==0 ? [] : JSON.parse(params.reflayers);

			// 表示中の参照レイヤを取得
			var referenceLayerInfo = layerInfo;
			if(referenceLayerInfo.visibility==true) {
				var reflayer = [referenceLayerInfo.layerId, 1, ""];
				reflayers.push(reflayer);
				// 時間パラメータの付与
				params.layertimes += (0<params.layertimes.length?",":"")+referenceLayerInfo.layerId+","+iso8601Time;
			}

			// パラメータを配列文字列で設定
			if(0<reflayers.length) params.reflayers = JSON.stringify(reflayers);
			break;
		case SaigaiTask.Map.Layer.Type.REFERENCE:
			// 配列文字列をオブジェクトに変換
			var reflayers = params.reflayers.length==0 ? [] : JSON.parse(params.reflayers);

			var child = layerInfo;
			if(child.visibility==true) {
				// 親レイヤ情報を検索
				var success = false;
				var reflayer = null;
				for(var idx in reflayers) {
					reflayer = reflayers[idx];
					if(reflayer[0]==child.parentLayerId) {
						var layers = reflayer[2];
						var opacity = reflayer[1];
						// 透明度不一致の場合
						if(child.opacity!=opacity) {
							if(0<layers.length) continue;
							reflayer[1] = child.opacity;
						}
						if(0<layers.length) layers += ",";
						layers+=child.layerId;
						reflayer[2] = layers;
						success = true;
						break;
					}
				}
				// 透明度不一致の場合(主題図の個別透明度の対応)
				if(!success && reflayer[0]==child.parentLayerId) {
					var cloneReflayer = [].concat(reflayer);
					var cloneLayerId = cloneReflayer[0];
					var cloneNum = 1;
					if(cloneLayerId.indexOf("#")!=-1) {
						var cloneLayerIdArray = cloneLayerId.split("#");
						cloneLayerId = cloneLayerIdArray[0];
						cloneNum = parseInt(cloneLayerIdArray[1]) + 1;
					}
					cloneReflayer[0] = cloneLayerId+"#"+cloneNum;
					cloneReflayer[1] = child.opacity;
					cloneReflayer[2] = child.layerId;
					reflayers.push(cloneReflayer);
					success = true;
				}
				
				// エラーログ
				if(success) {
					// パラメータを配列文字列で設定
					if(0<reflayers.length) params.reflayers = JSON.stringify(reflayers);
					// 時間パラメータの付与
					params.layertimes += (0<params.layertimes.length?",":"")+child.layerId+","+iso8601Time;
				}
				else {
					console.log(lang.__("Unable to print {0}. Parent layer info not exist.", child.layerId));
				}
			}
			break;
		default:
			// 主題図(画像)の印刷(下から重ねる順に指定、後の方が上)
			// overlaylayers:wms2:1,wms1:1
			if(SaigaiTask.Map.Layer.Type.isOverlayLayerType(layerInfo.type)) {
				var overlayLayerInfo = layerInfo;
				if(overlayLayerInfo.visibility==true) {
					// レイヤIDを追加
					if(0<params.overlaylayers.length) params.overlaylayers += ",";
					params.overlaylayers += overlayLayerInfo.layerId+":1";
					// 時間パラメータの付与
					params.layertimes += (0<params.layertimes.length?",":"")+overlayLayerInfo.layerId+","+iso8601Time;
				}
				break;
			}
		}

		// 子レイヤ情報がある場合は下から順に再帰
		for(var idx=layerInfo.children.length-1; 0<=idx; idx--) {
			me.buildPdfParams(params, layerInfo.children[idx]);
		}
	},

	createPdfParams: function() {
		var me = this;
		var stmap = me.stmap;
		var ecommap = stmap.ecommaps[0];
		var mapInfo = ecommap.mapInfo;
		
		// PDF 生成パラメータの設定
		var params = me.printWindow.getValues();
		SaigaiTask.Map.copy(params, {
			cid: mapInfo.communityId,
			mid: mapInfo.mapId,
			epsg: stmap.map.getProjection().split(":")[1],
		});
		
		// bbox範囲が指定されていない場合
		if(!params.bbox) {
			// bboxに内接する設定ページ設定の範囲を返却
			params.bbox = map.map.getExtent().toString();
		}

		// パラメータ初期化
		params.memoVisible = false;
		params.contentslayers = "";
		params.kmllayers = "";
		params.reflayers = "";
		params.overlaylayers = "";
		params.layertimes = "";
		params.rule = "";
		var addLayertimes = function(layerId, iso8601Time) {
			params.layertimes += (0<params.layertimes.length?",":"")+layerId+","+iso8601Time;
		}

		//レイヤを表示している下から順にパラメータを生成
		var layerInfoTree = ecommap.layerInfoTree;
		for(var idx=layerInfoTree.length-1; 0<=idx; idx--) {
			me.buildPdfParams(params, layerInfoTree[idx]);
		}

		// 時間パラメータの付与
		var time = SaigaiTask.PageURL.getTime();
		if(!time) time = new Date();
		var toISOString = function(time) {
			var iso8601Time = new Date(time).toISOString();
			// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
			if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
				iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
			}
			return iso8601Time;
		}
		var iso8601Time = toISOString(time);
		
		for(var layerId in ecommap.layerInfoStore) {
			var layerInfo = ecommap.layerInfoStore[layerId];
			if(layerInfo.visibility) {
				// 登録情報レイヤの場合
				if(layerInfo.type==SaigaiTask.Map.Layer.Type.LOCAL) {
					// 登録情報レイヤは個別指定の場合のみ layertimes を指定する（個別指定しない場合は time パラメータ）
					if(layerInfo.time!=null) {
						addLayertimes(layerInfo.layerId, toISOString(new Date(layerInfo.time)));
					}
				}
				// 主題図画像
				else if(SaigaiTask.Map.Layer.Type.isOverlayLayerType(layerInfo.type)) {
					var layertime = layerInfo.time!=null ? toISOString(new Date(layerInfo.time)) : iso8601Time;
					addLayertimes(layerInfo.layerId, layertime);
				}
				// 主題図(項目)
				else if(layerInfo.type==SaigaiTask.Map.Layer.Type.REFERENCE_WMS) {
					var layertime = layerInfo.time!=null ? toISOString(new Date(layerInfo.time)) : iso8601Time;
					addLayertimes(layerInfo.layerId, layertime);
				}
			}
		}
		// 時間情報を追加
		{
			// 印刷日時パラメータを追加
			// [例] 2016/10/11 10:37 印刷
			var printTime = new Date();
			printTime.setMilliseconds(0); // ミリ秒切捨て
			printTime.setSeconds(0); // 秒切捨て
			var printTimeStr = SaigaiTask.Page.Timeslider.formatDate(printTime, {
				dateSplit: "/",
				datetimeSplit: " ",
				timeSplit: ":"
			});
			printTimeStr += " " + lang.__("Print");

			// 表示時間パラメータを追加
			// [例] 2016/10/01 00:00 時点
			var time = SaigaiTask.PageURL.getTime();
			if(time!=null) {
				time.setMilliseconds(0); // ミリ秒切捨て
				var timeStr = SaigaiTask.Page.Timeslider.formatDate(time, {
					dateSplit: "/",
					datetimeSplit: " ",
					timeSplit: ":"
				});
				timeStr += " " + lang.__("As of");
				printTimeStr += " "+timeStr;
			}

			// 時間パラメータを追加
			params.description = printTimeStr + "\n" + params.description;
		}

		// LayerInfoをリクエストパラメータに追加するメソッド
		var getLayerInfoJSON = function(layerInfo) {
			var wmsProxy = "";
			var metadataId = "";
			// 外部サイトの認証情報があれば付与する
			if(layerInfo.wmsproxy && layerInfo.wmsproxy != 0 && layerInfo.wmsproxy != null){
				wmsProxy = layerInfo.wmsproxy;
			}
			if(layerInfo.metadataid && layerInfo.metadataid != "" && layerInfo.metadataid != null){
				metadataId = layerInfo.metadataid;
			}
			return JSON.stringify({
				layerId: layerInfo.layerId,
				name: layerInfo.name,
				type: layerInfo.type,
				opacity: layerInfo.opacity,
				wmsURL: layerInfo.wmsURL,
				wmsFormat: layerInfo.wmsFormat,
				featuretypeId: layerInfo.featuretypeId,
				wmsLegendURL: layerInfo.wmsLegendURL,
				wmsproxy: wmsProxy,
				metadataId: metadataId
			});
		}
		var addLayerInfoParam = function(layerInfo) {
			params["layerInfo."+layerInfo.layerId] = getLayerInfoJSON(layerInfo);
		};

		// 表示中の外部地図レイヤを取得
		var exlayers = [];
		var externalLayerInfos = ecommap.getExternalMapLayerInfos();
		var printExternalLayerInfos = [];
		var cloneNumMap = {};
		var cloneExternalLayerInfo = function(externalLayerInfo) {
			var cloneLayerId = externalLayerInfo.layerId;
			var cloneNum = cloneNumMap.hasOwnProperty(cloneLayerId) ? cloneNumMap[cloneLayerId] : 1;
			cloneNumMap[cloneLayerId] = cloneNum+1;

			var printExternalLayerInfo = JSON.parse(getLayerInfoJSON(externalLayerInfo));
			printExternalLayerInfo.layerId = cloneLayerId+"#"+cloneNum;
			printExternalLayerInfo.children = [];
			printExternalLayerInfo.visibility = externalLayerInfo.visibility;
			printExternalLayerInfos.push(printExternalLayerInfo);
			return printExternalLayerInfo;
		}
		// 透明度個別対応のため印刷用のレイヤ情報を作成する
		for(var idx in externalLayerInfos) {
			var externalLayerInfo = externalLayerInfos[idx];
			var printExternalLayerInfo = cloneExternalLayerInfo(externalLayerInfo);
			if(externalLayerInfo.visibility==true) {
				for(var cidx in externalLayerInfo.children) {
					var child = externalLayerInfo.children[cidx];
					if(child.visibility==true) {
						// 透明度不一致の場合
						if(child.opacity!=opacity) {
							if(0<printExternalLayerInfo.children.length) {
								printExternalLayerInfo = cloneExternalLayerInfo(externalLayerInfo);
							}
							printExternalLayerInfo.opacity = child.opacity;
						}
						printExternalLayerInfo.children.push(child);
					}
				}
			}
		}
		for(var idx in printExternalLayerInfos) {
			var externalLayerInfo = printExternalLayerInfos[idx];
			if(externalLayerInfo.visibility==true) {
				// add exlayers parameter
				var opacity = externalLayerInfo.opacity;
				var exlayer = [externalLayerInfo.layerId, opacity];
				// 時間パラメータの付与
				addLayertimes(externalLayerInfo.layerId, iso8601Time);
				var layers = [];
				for(var cidx in externalLayerInfo.children) {
					var child = externalLayerInfo.children[cidx];
					if(child.visibility==true) {
						// extlayers.layers に追加
						layers.push(child.layerId);
						// add layerInfo parameter
						addLayerInfoParam(child);
						// 時間パラメータの付与
						addLayertimes(child.layerId, iso8601Time);
					}
				}
				exlayer.push(layers.reverse().join(","));
				exlayers.push(exlayer);
				// add layerInfo parameter
				addLayerInfoParam(externalLayerInfo);
			}
		}
		// UTMグリッドを印刷する場合
		if(0<=Number(params.mgrs)) {
			// LayerInfo
			var mgrsLayerInfo = stmap.controls.mgrsControl.layerInfo;
			var exlayer = [mgrsLayerInfo.layerId, 1];
			// add parameter
			var childLayerId = mgrsLayerInfo.layerId+"_";
			exlayer.push(childLayerId); // dummy child layerId ※現状1つしか指定できない
			exlayers.push(exlayer);
			addLayerInfoParam(mgrsLayerInfo);

			// 印刷するMGRSグリッド桁数は印刷ウィンドウで指定したもので上書き
			var featuretypeIds = [];
			var childLayerName = "UTM Grid";
			for(var p=0; p<=Math.min(5, Number(params.mgrs)); p++) {
				featuretypeIds.push("mgrs"+p);
				childLayerName =
					p==0 ? "100km" :
					p==1 ? "10km" :
					p==2 ? "1km" :
					p==3 ? "100m" :
					p==4 ? "10m" : "1m";
			}
			var paramLayerInfo = JSON.parse(params["layerInfo."+mgrsLayerInfo.layerId]);
			paramLayerInfo.featuretypeId = featuretypeIds.join(",");
			params["layerInfo."+mgrsLayerInfo.layerId] = JSON.stringify(paramLayerInfo);
			// dummy child layerInfo
			paramLayerInfo.name = childLayerName;
			params["layerInfo."+childLayerId] = JSON.stringify(paramLayerInfo);
		}
		if(0<exlayers.length) params.exlayers = JSON.stringify(exlayers);
		// 表示中の背景地図を取得
		if(0<params.printBaselayer) {
			var baseLayerInfos = ecommap.getBaseLayerInfos();
			for(var idx in baseLayerInfos) {
				var baseLayerInfo = baseLayerInfos[idx];
				if(baseLayerInfo.visibility == true) {
					params.baselayer = baseLayerInfo.layerId + ":1";
					// 時間パラメータの付与
					addLayertimes(baseLayerInfo.layerId, iso8601Time);
				}
			}
		}
		// 背景地図なしの場合
		else {
			// 凡例を非表示
			params.printlegend = 0;
			// 枠線を非表示
			params.noframe= 1;
			// フッターなし
			params.fpage = 0;    // ページ番号
			params.fmappage = 0; // マップ分割番号
			// 縮尺
			//params.scalealign = -1; // 非表示
		}
		delete params.printBaselayer;
		return params;
	},
	
	/**
	 * 印刷処理を実行します.
	 */
	print: function() {
		var me = this;
		var stmap = me.stmap;
		
		// PDF 生成処理をリクエスト
		var params = me.createPdfParams();
		stmap.api.createPdf(params);

		// PDF生成が終わるまでチェック
		setTimeout(function() {
			me.checkPdfDownload();
		}, 1000);
	},

	/** PDF生成が終わるまでチェック */
	checkPdfDownload : function() {
		var me = this;
		var printWindow = me.printWindow;
		var progressbar = me.printWindow.progressbar;
		$.ajax(SaigaiTask.contextPath+"/PdfServlet", {
			dataType: "json",
			cache: false,
			success: function(data) {
				if (data.name == "Error") {
					console.error(lang.__("An error occurred during the PDF creation process."));
				} else {
					console.debug("Creating pdf: "+ data[0]+ "/" + data[1]);
					var v = data[0]/data[1];
					try {
						if (data[0] == 0 && data[1] == 0) setTimeout( function(){me.checkPdfDownload();}, 1000 );
						else {
							if (data[0] < data[1]) {
								progressbar.updateProgress(v, lang.__('Creating PDF file..')+' '+Math.round(100 * v) + lang.__("%"));
								setTimeout( function(){me.checkPdfDownload();}, 1000 );
							}
							else {
								printWindow.onsuccess();
							}
						}
					} catch (e) {console.warn(e);}
				}
			}
		});
	},

	/**
	 * @param {String} pageType 用紙の版
	 * @return {Object} pageSize
	 * pageSize.width 幅
	 * pageSize.height 高さ
	 */
	getPrintSize: function(pageType) {
		var a0 = {
			width: 841,
			height: 1189
		};
		var b0 = {
			width: 1030,
			height: 1456
		};
		var pageSize = null;
		// A版、B版設定
		var type = pageType[0].toLowerCase();
		if(type=="a") pageSize = a0;
		else if(type=="b") pageSize = b0;
		// 等分する
		var num = Number(pageType[1]);
		while(0<num) {
			pageSize.width  = pageSize.width/2;
			pageSize.height = pageSize.height/2;
			num--;
		}
		return pageSize;
	}
});
/* ======================================================================
    SaigaiTask/Map/Layer/LayerInfo.js
   ====================================================================== */

/**
 * 
 * @requires SaigaiTask/Map/Layer.js
 */
SaigaiTask.Map.Layer.LayerInfo = new OpenLayers.Class({

	/**
	 * eコミマップ情報
	 * @type {SaigaiTask.Map.EcommapInfo}
	 */
	ecommap: null,

	/**
	 * レイヤID
	 * 葉ノードのみ指定します.
	 * @type {String}
	 */
	layerId: null,

	/**
	 * 名称
	 * すべてのノードで指定します.
	 * @type {String}
	 */
	name: null,

	/**
	 * WMSのURL
	 * ルートノードのみ指定します.
	 * @type {String}
	 */
	wmsURL: null,

	/**
	 * WMS画像のフォーマットを指定
	 */
	format: "image/png",

	/**
	 * WMS画像の透過度
	 */
	opacity: 1.0,

	/**
	 * リロード間隔秒数
	 * MapLayerInfoから設定される。
	 * @type {Object}
	 */
	reload: null,

	/**
	 * レイヤ種別
	 * @type {String} SaigaiTask.Map.Layer.Type の中から指定される
	 */
	type: null,

	/**
	 * 新規登録可能フラグ
	 * @type {Boolean}
	 */
	addable: false,

	/**
	 * ポップアップ編集フラグ
	 * @type {Boolean}
	 */
	editable: false,

	/**
	 * 編集時にスナップ可能フラグ
	 * @type {Boolean}
	 */
	snappable: false,

	/**
	 * 折りたたみフラグ
	 * すべてのノードで指定します.
	 * @type {Boolean}
	 */
	expanded: true,

	/**
	 * 表示フラグ
	 * すべてのノードで指定します.
	 * @type {Boolean}
	 */
	visibility: true,

	/**
	 * 検索フラグ
	 * 地図クリック時に検索するかどうかのフラグ
	 */
	searchable: false,

	/**
	 * 常に検索しないフラグ
	 * 地図クリック時に検索するかどうかのフラグ
	 */
	alwaysNotSearch: false,

	/**
	 * WMSのリクエストに付加するパラメータ
	 */
	params: null,
	
	/**
	 * 親レイヤID
	 * ルートノード以外指定します.
	 * @type {String}
	 */
	parentLayerId: null,

	/**
	 * 親レイヤ情報
	 * 親レイヤIDからレイヤ情報を設定します.
	 * @type {SaigaiTask.Map.Layer.LayerInfo}
	 */
	parent: null,

	/**
	 * 子レイヤ情報の配列
	 * 子レイヤ情報の親レイヤ設定のタイミングで親レイヤ側で追加します.
	 * @type {Array<SaigaiTask.Map.Layer.LayerInfo>}
	 */
	children: null,

	/**
	 * レイヤ
	 * @type {OpenLayers.Layer}
	 */
	layer: null,

	/**
	 * 属性情報配列
	 * @type {Array<SaigaiTask.Map.Layer.AttrInfo>}
	 */
	attrInfos: null,

	/**
	 * The transition effect to use when the map is zoomed.
	 * ズーム時のエフェクト.
	 */
	transitionEffect: null,

	/**
	 * フィルタキー
	 * @type {String}
	 */
	filterkey: null,

	/**
	 * グレーアウト(かつ不透明度)
	 * 0だと非表示、1だとそのまま
	 * 0.5は半透明
	 * @type {Number}
	 */
	grayout: null,

	/**
	 * 空間検索範囲レイヤ
	 * @type {SaigaiTask.Map.Layer.WMSLayer}
	 */
	spatialLayer: null,

	/**
	 * 検索範囲に利用するレイヤ条件のJSONオブジェクト配列
	 * @type {Array<Object>}
	 */
	spatialLayers: null,

	/**
	 * WMSをタイルで取得するかどうかのフラグ
	 * @type {Boolean}
	 */
	singleTile: false,

	/**
	 * 切り出しレイヤID
	 * @type {String}
	 */
	intersectionlayerid: null,

	/**
	 * 切り出しレイヤ名
	 * @type {String}
	 */
	intersectionlayername: null,

	/**
	 * 最終更新日時の属性ID
	 * @type {String}
	 */
	updatecolumn: null,

	/**
	 * 震度レイヤフラグ
	 * @type {Boolean}
	 */
	isEarthquakeLayer: false,

	/**
	 * レイヤ個別の時間パラメータ（ISO8601日時文字列）
	 * @type {String}
	 */
	time: null,

	/**
	 * データ表示時間パラメータを取得
	 * @return ISO8601日付文字列（指定がなければ null)
	 */
	getTime: function() {
		var timeStr = this.time;
		return (!!timeStr ? new Date(timeStr) : null);
	},

	/**
	 * コンストラクタ
	 * @param options
	 */
	initialize: function(options) {
		var me = this;
		me.children = [];
		me.params = [];
		// オプションをコピー
		OpenLayers.Util.extend(me, options);

		me.attrInfos = [];
		for(var idx in options.attrInfos) {
			var attrInfo = new SaigaiTask.Map.Layer.AttrInfo(options.attrInfos[idx]);
			me.attrInfos.push(attrInfo);
		}

		// もし、指定がなければ、検索フラグは表示フラグを使う
		if(typeof options.searchable == "undefined" || options.searchable == null) {
			this.searchable = this.visibility;
		}
		// searchable=false で初期化したら、常に検索しない
		else if(options.searchable==false) {
			this.alwaysNotSearch = true;
		}

		// 時間パラメータがあれば SaigaiTask.PageURL からロード
		me.time = SaigaiTask.PageURL.getLayerTime(me.layerId);

		// 凡例別の表示切替対応
		// 初期の visibility をパラメータに反映する
		me.updateRuleParam();
	},

	/**
	 * OpenLayers.Layerを取得します.
	 * 持っていなければ親を辿って探します.
	 * @type {OpenLayers.Layer}
	 */
	getLayer: function() {
		if(this.layer!=null) {
			return this.layer;
		}
		if(this.parent!=null) {
			return this.parent.getLayer();
		}
		return null;
	},

	/**
	 * 子レイヤ情報を追加します.
	 * @param childLayerInfo
	 */
	appendChildLayerInfo: function(childLayerInfo) {
		this.children.push(childLayerInfo);
		childLayerInfo.parent = this;
		childLayerInfo.parentLayerId = this.layerId;
	},

	/**
	 * WMSリクエストのパラメータに指定したパラメータをマージします.
	 */
	mergeParams: function(params) {
		var layerInfo = this;
		for(var paramName in layerInfo.params) {
			var param = layerInfo.params[paramName];
			if(typeof params[paramName]=="undefined") {
				params[paramName] = [];
			}
			// spatiallayer が string のため上書きにする
			if(typeof params[paramName]=="string") {
				params[paramName] = param;
			}
			// LAYERS などの複数のLayerInfoから構成されるパラメータは配列でマージする
			if($.isArray(params[paramName])) {
				params[paramName].push(param);
			}
		}
		// 時間パラメータの個別指定対応
		if(layerInfo.time!=null) {
			// 登録情報レイヤの場合
			if(layerInfo.type==SaigaiTask.Map.Layer.Type.LOCAL) {
				if(typeof params.layertimes=="undefined") params.layertimes = "";
				if(0<params.layertimes.length) params.layertimes += ",";
				params.layertimes += layerInfo.layerId;
				params.layertimes += ",";
				var time = layerInfo.getTime();
				var iso8601Time = time.toISOString();
				// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
				if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
					iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
				}
				params.layertimes += iso8601Time;
			}
		}
	},

	/**
	 * 属性IDから属性情報を取得します.
	 */
	getAttrInfo: function(attrId) {
		var me = this;
		for(var idx in me.attrInfos) {
			var attrInfo = me.attrInfos[idx];
			if(attrId == attrInfo.attrId) {
				return attrInfo;
			}
		}
		return null;
	},

	/**
	 * 表示可能な属性かどうかチェックします.
	 */
	isVisibleAttr: function(attrId) {
		var attrInfo = this.getAttrInfo(attrId);
		if(attrInfo!=null) {
			// ステータスで表示をフィルタ
			var STATUS_SEARCHHIDE = SaigaiTask.Map.Layer.AttrInfo.STATUS_SEARCHHIDE;
			return STATUS_SEARCHHIDE<attrInfo.status;
		}
		return false;
	},

	/**
	 * 編集可能な属性かどうかチェックします.
	 */
	isEditableAttr: function(attrId) {
		var attrInfo = this.getAttrInfo(attrId);
		if(attrInfo!=null) {
			// ステータスで表示をフィルタ
			var STATUS_DEFAULT = SaigaiTask.Map.Layer.AttrInfo.STATUS_DEFAULT;
			return STATUS_DEFAULT==attrInfo.status;
		}
		return false;
	},

	/**
	 * 属性のソートをdisporder順で評価します.
	 * attr1の方が先ならば-1を返す.
	 * attr2の方が先ならば 1を返す.
	 * 同じなら0を返す.
	 */
	evalAttrSort: function(attrId1, attrId2) {
		var attr1 = this.getAttrInfo(attrId1);
		var attr2 = this.getAttrInfo(attrId2);
		if(attr1==null && attr2==null) return 0;
		if(attr2==null || attr1.disporder < attr2.disporder) return -1;
		if(attr1==null || attr2.disporder < attr1.disporder) return  1;
		return 0;
	},

	/**
	 * 非表示のレイヤIDを配列で取得します.
	 * @param {Array<String>} hiddenLayerIds 非表示レイヤIDを追加する配列
	 * @return {Array<String>}
	 */
	getHiddenLayerIds: function(hiddenLayerIds) {
		var layerInfo = this;
		// 非表示なら追加する
		if(layerInfo.visibility==false) {
			if(layerInfo.layerId!=null) {
				hiddenLayerIds.push(layerInfo.layerId);
			}
		}
		// 子の非表示をチェック
		if(layerInfo.children!=null) {
			for(var idx in layerInfo.children) {
				var child = layerInfo.children[idx];
				child.getHiddenLayerIds(hiddenLayerIds);
			}
		}
		return hiddenLayerIds;
	},

	/**
	 * 空間検索条件レイヤを持つかどうかチェックします.
	 * @return 空間検索条件があれば true
	 */
	hasSpatialLayer: function() {
		var me = this;
		return me.spatialLayers!=null;
	},

	/**
	 * WMSのGetMapリクエストのグレーアウトパラメータを設定します.
	 * レイヤ情報の方は透明度を残しておくため更新しません.
	 * @param {Number} grayout
	 */
	setGrayout: function(grayout) {
		var me = this;
		//me.grayout = grayout;
		var layer = me.getLayer();
		if(layer!=null) {
			var layerInfo = layer.layerInfo;
			if(layerInfo!=null) {
				layerInfo.params.grayout = grayout;
				layer.refreshParams({
					nocache: true
				});
			}
		}
	},

	/**
	 * 空間検索範囲レイヤを作成する
	 */
	createSpatialLayer: function() {
		var layerInfo = this;
		var ecommap = layerInfo.ecommap;
		var stmap = ecommap.stmap;
		var olmap = stmap.map;
		var spatialLayerInfo = ecommap.createContentsLayerInfo();
		spatialLayerInfo.singleTile = true;
		spatialLayerInfo.appendChildLayerInfo(layerInfo);
		spatialLayerInfo.params.filterlayer = layerInfo.layerId;
		spatialLayerInfo.params.filterkey = layerInfo.filterkey;
		spatialLayerInfo.params.spatiallayer = 1;
		spatialLayerInfo.params.spatiallayers = JSON.stringify(layerInfo.spatialLayers);
		
		// 時間パラメータの付与
		var time = SaigaiTask.PageURL.getTime();
		if(!!time) {
			var iso8601Time = time.toISOString();
			// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
			if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
				iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
			}
			spatialLayerInfo.params.time = iso8601Time;
		}

		spatialLayerInfo.params.spatiallayers = JSON.stringify(layerInfo.spatialLayers);
		var spatialLayer = new SaigaiTask.Map.Layer.WMSLayer(spatialLayerInfo);
		// 地図が表示されていない状態でSingleTileのレイヤを表示しようとすると、
		// OpenLayers.Tileにlayerが渡らず、nullになって地図が真っ白になるため、
		// デフォルトで非表示とし、地図表示後に必要であれば表示させること.
		spatialLayer.setVisibility(false);
		olmap.addLayer(spatialLayer);
		layerInfo.spatialLayer = spatialLayer;
	},

	/**
	 * セッションに保存された外部地図レイヤかどうか判定します.
	 * @return {Boolean}
	 */
	isSessionExternalMapLayer: function() {
		var layerInfo = this;
		return (layerInfo.type==SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS || layerInfo.type==SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS_LAYERS) && (layerInfo.layerId.indexOf("extmap_session")==0)		
	},


	/**
	 * 削除可能なセッションに保存された外部地図レイヤかどうか判定します.
	 * @return {Boolean}
	 */
	isDeletableSessionExternalMapLayer: function() {
		var layerInfo = this;
		if(!layerInfo.isSessionExternalMapLayer()) return false;
		
		if(layerInfo.type==SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS) return true;
		
		if(layerInfo.type==SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS_LAYERS) {
			var children = layerInfo.parent.children;
			for(var idx in children) {
				var child = children[idx];
				if(child==layerInfo) continue;
				if(child.metadataid==layerInfo.metadataid) {
					return false;
				}
			}
		}

		return true;
	},

	/**
	 * @return {String} 時間パラメータ
	 */
	getTimeParam: function() {
		var me = this;
		// レイヤ個別で時間パラメータが指定されていたら優先
		if(me.time!=null) return me.time;
		// 全体共通の時間パラメータ
		return me.getLayer().params.time;
	},

	/**
	 * ruleパラメータを再構築
	 */
	updateRuleParam: function() {
		var me = this;
		var layerInfo = me;
		if(!!me.legendrules && 2<me.legendrules.length) {
			// 表示するルールを取得
			var visibleRules = [];
			var allHide = true;
			for(var legendrulesIdx in layerInfo.legendrules) {
				var rule = layerInfo.legendrules[legendrulesIdx];
				if(rule.visibility) {
					visibleRules.push(rule.ruleId);
				}
				// すべてのルールが非表示フラグ
				if(allHide && rule.visibility) allHide = false;
			}

			// パラメータ更新
			// 全表示ならルールを指定しない
			if(visibleRules.length==0 || visibleRules.length==layerInfo.legendrules.length) {
				me.params.rule = null;
			}
			else {
				me.params.rule = me.layerId+":"+visibleRules.join(":");
			}

			// すべてのルールが非表示の場合はレイヤ非表示
			if(allHide) {
				layerInfo.visibility = false;
				layerInfo.searchable = false;
			}
		}
	},

	CLASS_NAME: "SaigaiTask.Map.Layer.LayerInfo"
});
/* ======================================================================
    SaigaiTask/Map/model.js
   ====================================================================== */

/**
 * データモデルパッケージです.
 * @requires SaigaiTask/Map.js
 */
SaigaiTask.Map.model = {};


/**
 * 地図の初期化オプションのデータモデルです.
 */
SaigaiTask.Map.model.InitOptions = function(){};
SaigaiTask.Map.model.InitOptions.prototype = {
	/**
	 * 官民協働危機管理クラウドシステムのコンテキストパス
	 * @type {String}
	 */
	contextPath: null,

	/**
	 * AJAXのAPIクラスを指定します.
	 * デフォルトは {SaigaiTask.Map.SaigaiTaskAPI} です.
	 * @type {SaigaiTask.Map.API}
	 */
	api: null,

	/**
	 * 地図アイコンのクラスを指定します.
	 * @type {SaigaiTask.Map.Icon}
	 */
	icon: null,

	/**
	 * 凡例パネルの表示
	 * @type {Boolean}
	 */
	showLegend: false,

	/**
	 * 右クリックメニューのオプション
	 * @type {SaigaiTask.Map.model.ShowMenuOptions}
	 */
	showMenuOptions: null,

	/**
	 * OpenLayersの投影法
	 * @type {Number}
	 */
	epsg: 4326
};

/**
 * コンテキストメニューの表示オプションのデータモデルです.
 */
SaigaiTask.Map.model.ShowMenuOptions = function(){};
SaigaiTask.Map.model.ShowMenuOptions.prototype = {
	/**
	 * 新規登録メニュー
	 */
	addContentsMenu: false,
	/**
	 * レイヤ削除メニュー
	 * @type {Boolean}
	 */
	deleteLayerMenu: false,
	/**
	 * 透明度変更メニュー
	 */
	transparencyLayerMenu: false
};

/**
 * 避難所検索オプションのデータモデルです.
 */
SaigaiTask.Map.model.ShelterSearchOptions = function(){};
SaigaiTask.Map.model.ShelterSearchOptions.prototype = {
	/**
	 * レイヤID
	 * @type {String}
	 */
	layerId: null,

	/**
	 * フィーチャID
	 * @type {Array<Number>}
	 */
	featureId: null
};

/**
 * eコミマップ情報のデータモデルです.
 */
SaigaiTask.Map.model.Ecommap = function(){};
SaigaiTask.Map.model.Ecommap.prototype = {

	/**
	 * ベースレイヤ配列
	 * @type {Array.<SaigaiTask.Map.model.Layer>}
	 */
	baseLayers: null,

	/**
	 * 登録情報レイヤ配列
	 * @type {Array.<SaigaiTask.Map.model.Layer>}
	 */
	contentsLayers: null,

	/**
	 * オーバレイレイヤ配列
	 * @type {Array.<SaigaiTask.Map.model.Layer>}
	 */
	overlayLayers: null,

	/**
	 * 参照レイヤ配列
	 * @type {Array.<SaigaiTask.Map.model.Layer>}
	 */
	referenceLayers: null
};

/**
 * レイヤのデータモデルです.
 * @class SaigaiTask.Map.model.Layer
 */
SaigaiTask.Map.model.Layer = function(){};
SaigaiTask.Map.model.Layer.prototype = {

	/**
	 * レイヤID
	 * @type {String}
	 */
	id: null,

	/**
	 * レイヤ名称
	 * @type {String}
	 */
	name: null,

	/**
	 * レイヤ説明
	 */
	description: null,

	/**
	 * 属性配列
	 * @type {Array.<SaigaiTask.Map.model.Attribute>}
	 */
	attributes: null
};

/**
 * フィーチャのデータモデルです.
 * @class SaigaiTask.Map.model.Feature
 */
SaigaiTask.Map.model.Feature = function(){};
SaigaiTask.Map.model.Feature.prototype = {

	/**
	 * レイヤID
	 * @type {String}
	 */
	layerId: null,

	/**
	 * フィーチャID
	 * レイヤID.フィーチャIDで取得するには{@link #getFeatureId()}メソッドを利用してください.
	 * @type {number}
	 */
	featureId: null,

	/**
	 * ジオメトリ
	 * TODO: @type {SaigaiTask.Map.model.Geometry}
	 */
	geometry: null,

	/**
	 * 属性の配列
	 * @type {Array.<SaigaiTask.Map.model.Attribute>}
	 */
	attributes: null,

	/**
	 * ファイル情報の配列
	 * TODO: @type {Object}
	 */
	files: null,

	/**
	 * メタデータ情報の配列
	 * TODO: @type {Object}
	 */
	metadata: null,

	/**
	 * "レイヤID.フィーチャID" の形式でフィーチャIDを取得します.
	 * @return {String} なければ null
	 */
	getFeatureId: function() {

		var fid = null;
		if(layerId&&featureId) {
			fid = layerId+"."+featureId;
		}
		return fid;
	},

	/**
	 * 属性名を配列で取得します.
	 * @return {Array.<String>}
	 */
	getAttributeNames: function() {
		var names = [];
		if(this.attributes) {
			for(var idx in this.attributes) {
				names.push(this.attributes[idx].name);
			}
		}
		return names;
	},

	/**
	 * 属性値を配列で取得します.
	 * @return {Array.<*>}
	 */
	getAttributeValues: function() {
		var values = [];
		if(this.attributes) {
			for(var idx in this.attributes) {
				values.push(this.attributes[idx].value);
			}
		}
		return values;
	}
};

/**
 * ジオメトリのデータモデルです.
 * @class SaigaiTask.Map.model.Geometry
 */
SaigaiTask.Map.model.Geometry = function(){};
SaigaiTask.Map.model.Geometry.prototype = {
	/**
	 * WKT
	 * @type {String}
	 */
	wkt: null
};

/**
 * フィーチャの属性のデータモデルです.
 * @class SaigaiTask.Map.model.Attribute
 */
SaigaiTask.Map.model.Attribute = function(){};
SaigaiTask.Map.model.Attribute.prototype = {

	/**
	 * 属性ID
	 * @type {String}
	 */
	id: null,

	/**
	 * 属性名
	 * @type {String}
	 */
	name: null,

	/**
	 * 属性値
	 * @type {*}
	 */
	value: null
};

/**
 * 空間検索の検索パラメータのデータモデルです.
 * @class SaigaiTask.Map.model.SearchParams 空間検索パラメータ
 */
SaigaiTask.Map.model.SearchParams = function(){};
SaigaiTask.Map.model.SearchParams.prototype = {

	/**
	 * 検索範囲のバッファ
	 * @type {Number}
	 */
	buffer: 0,

	/**
	 *  検索範囲のフィーチャの配列
	 * フィーチャは "[レイヤID].[フィーチャID]" の書式とします.
	 * @type {Array.<String>}
	 */
	features: ["c127.3"],

	/**
	 * 検索対象のレイヤID
	 * @type {String}
	 */
	layerId: "c127",

	/**
	 * 検索対象の地図ID
	 * @type {Number}
	 */
	mapId: 42,

	/**
	 * 検索範囲の検索方法ID
	 * @type {Number}
	 */
	spatialType: 1
};

/**
 * 空間検索結果のデータモデルです.
 * @class SaigaiTask.Map.model.SearchResult 空間検索結果
 */
SaigaiTask.Map.model.SearchResult = function(){};
SaigaiTask.Map.model.SearchResult.prototype = {

	/**
	 * 検索が成功したか
	 * @type {boolean}
	 */
	success: false,

	/**
	 * 検索結果数情報のオブジェクト
	 * @type {SaigaiTask.Map.model.ResultCount}
	 */
	counts: null,

	/**
	 * 検索されたフィーチャの配列
	 * @type {Array.<SaigaiTask.Map.model.Feature>}
	 */
	features: null,

	/**
	 * 検索結果のJSONの生データ
	 * @type {Object.<*, *>}
	 */
	raw: null
};

/**
 * 検索結果の結果数のデータモデルです.
 * @class SaigaiTask.Map.model.ResultCount 空間検索結果の結果数
 */
SaigaiTask.Map.model.ResultCount = function(){};
SaigaiTask.Map.model.ResultCount.prototype = {

	/**
	 * 検索条件に対応するデータ全件数
	 * @type {Number}
	 */
	total: 0,

	/**
	 * 検索結果一覧を取得したときのLimit
	 * @type {Number}
	 */
	limit: 0,

	/**
	 * 検索結果一覧を取得したときのOffset
	 * @type {Number}
	 */
	offset: 0
};
/* ======================================================================
    SaigaiTask/Map/Layer/XYZLayer.js
   ====================================================================== */

/**
 * XYZ Layer
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 */
SaigaiTask.Map.Layer.XYZLayer = new OpenLayers.Class(OpenLayers.Layer.XYZZoom, {
	layerInfo: null,
	initialize: function(layerInfo) {
		this.layerInfo = layerInfo;
		var options = {
			reprojection: true,
			isBaseLayer: layerInfo.type==SaigaiTask.Map.Layer.Type.BASE_XYZ,
			buffer: 0,
			opacity: layerInfo.opacity,
			alpha: true,
			visibility: layerInfo.visibility,
			attribution: layerInfo.attribution
		};

		options.maxZoomLevel = layerInfo.maxZoomLevel;

		OpenLayers.Layer.XYZZoom.prototype.initialize.apply(this, [layerInfo.name, layerInfo.wmsURL, options]);

		layerInfo.layer = this;
	}
});

SaigaiTask.Map.Layer.XYZLayer.type = [SaigaiTask.Map.Layer.Type.BASE_XYZ, SaigaiTask.Map.Layer.Type.OVERLAY_XYZ, SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_XYZ]
/* ======================================================================
    SaigaiTask/Map/Layer/TileCacheLayer.js
   ====================================================================== */

/**
 * TileCacheレイヤ
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 */
SaigaiTask.Map.Layer.TileCacheLayer = new OpenLayers.Class(OpenLayers.Layer.TileCache, {
	/**
	 * OSMレイヤ情報
	 */
	layerInfo: null,

	/**
	 *
	 * @param layerInfo referenceLayerInfo
	 */
	initialize: function(layerInfo) {
		// 引数を処理
		var me = this;
		me.layerInfo = layerInfo;

		var options = {
			visibility: layerInfo.visibility,
			buffer: 0,
			alpha: true,
			opacity: 1.0,
			isBaseLayer: true
		};

		options.format = layerInfo.wmsFormat;
		OpenLayers.Layer.TileCache.prototype.initialize.apply(this, [layerInfo.name, layerInfo.wmsURL, layerInfo.featuretypeId, options]);
	}
});

SaigaiTask.Map.Layer.TileCacheLayer.type = SaigaiTask.Map.Layer.Type.TILECACHE;
/* ======================================================================
    SaigaiTask/Map/control/SessionLayout.js
   ====================================================================== */

/**
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.SessionLayout = new OpenLayers.Class(OpenLayers.Control, {

	/**
	 * APIProperty: events {<OpenLayers.Events>}
	 *
	 * Supported map event types (in addition to those from
	 * <OpenLayers.Layer.events>): layoutloaded- レイアウト読み込み後にトリガーする.
	 */

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * AJAXリクエストのアボート用
	 */
	xhr: null,

	initialize: function(stmap, options) {
		var me = this;
		me.stmap = stmap;

		// 表示状態をサーバに保存するイベントの初期化.
		var handler = function(evt){
			me.saveLayout();
		};
		stmap.events.on({
			"legenditemexpanded": handler,
			"legendcheckchange": handler
		});
		stmap.map.events.on({
			"zoomend": handler,
			"moveend": handler
		});

		OpenLayers.Control.prototype.initialize.apply(this, [options]);
	},

	/**
	 * 表示状態をサーバから取得する.
	 */
	loadLayout: function(callback, blayer){
		if(this.active) {
			var sessionLayout = this;
			var me = this.stmap;
			var map = me.map;
			var data = {
				mapDivId: me.div
			};
			me.api.loadLayout(data, function(layout) {
				if(layout!=null){
					// FIXME: eコミのサイト投影法をメルカトルからWGS84に変更した際にセッションに保存したレイアウトをロードすると地図が真っ白になる不具合を修正する
					// ズーム
					var zoom = layout.zoom;
					if(typeof zoom!="undefined") {
						map.zoomTo(zoom);
					}
					// center
					if(typeof layout.center!="undefined") {
						var center = new OpenLayers.LonLat.fromString(layout.center);
						me.setCenter(center);
					}
					// 凡例
					if(typeof layout.layers!="undefined" && blayer) {
						// 読み込んだプロパティを設定
						var layerMap = me.getLayerMap();
						var idx = null;
						for(idx in layout.layers) {
							// TODO* 現状の構造に合わせて変更する
							var layerLayout = layout.layers[idx];
							var layerId = layerLayout.id;
							var layer = layerMap[layerId];
							if(layer!=null) {
								layer.expanded = layerLayout.expanded;
								layer.visibility = layerLayout.visibility;
								layer.searchable = layerLayout.visibility;
							}
						}
						me.redrawContentsLayer(0);
					}
				}
				sessionLayout.events.triggerEvent("layoutloaded");
				if(typeof callback=="function") callback();
			});
		}
		else {
			if(typeof callback=="function") callback();
		}
	},

	/**
	 * 表示状態をサーバに保存する.
	 */
	saveLayout: function(){
		if(this.active!=true) return;
		var me = this.stmap;
		var map = me.map;
		// 送信中のリクエストがあれば中断する
		if(this.xhr!=null) this.xhr.abort();
		var allLayers = me.getAllLayers();
		var layers = [];
		for(var allLayersIdx in allLayers) {
			var layer = allLayers[allLayersIdx];
			layers[layers.length] = {
				id: layer.layerId,
				expanded: layer.expanded==true,
				visibility: layer.visibility
			};
		}
		// リクエストを送信する
		var data = {
			mapDivId: me.div,
			"zoom": map.zoom,
			"center": map.getCenter().clone().transform(map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326")).toShortString(),
			"layers": layers
		};
		this.xhr = me.api.saveLayout(data);
	}
});
/* ======================================================================
    SaigaiTask/Map/view/PrintPreviewWindow.js
   ====================================================================== */

/**
 * @class SaigaiTask.Map.view.PrintPreviewWindow
 * eコミマップベースの印刷プレビュー付き印刷ダイアログです.
 * @requires SaigaiTask/Map/view.js
 * @see /map/map/PdfWriter.js (ecommap)
 */
SaigaiTask.Map.view.PrintPreviewWindow = function() {
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.PrintPreviewWindow.prototype = {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	pdfControl: null,

	contentsContainer: null,

	formPanel: null,

	/**
	 * 詳細設定から簡単設定に切り替えた際に、
	 * 簡単設定にない設定項目が消えてしまうので、
	 * ここですべての設定値を保持する。
	 */
	values: null,

	previewMapImageContainer: null,

	/**
	 * PDF範囲レイヤ
	 * @type {SaigaiTask.Map.Layer.PdfRangeLayer}
	 */
	pdfRangeLayer: null,

	progressbar: null,
	progressbarInitText: lang.__('Creating PDF file..'),

	exportButton: null,
	exportImageButton: null,
	downloadButton: null,

	win: null,
	topToolbar: null,

	initialize: function(pdfControl) {
		var me = this;
		me.pdfControl = pdfControl;
		var stmap = me.stmap = pdfControl.stmap;

		// デフォルト設定値
		me.values = {
			printBaselayer: "1", // 背景地図出力
			cols: 1,
			rows: 1,
			printmap: 1,
			printlegend: 1
		};

		// 印刷ダイアログ初期化
		me.createWindow({
			easy: true
		});

		// 印刷範囲レイヤを初期化
		me.pdfRangeLayer = new SaigaiTask.Map.Layer.PdfRangeLayer(me);
	},

	// BEGIN createWindow:
	createWindow: function(opt) {
		var me = this;
		var stmap = me.stmap;
		var easy = opt.easy;

		// コンテンツHBox
		var winWidth = 0;
		var hbox = {
			xtype: 'container',
			layout: "hbox",
			style: {
				background: "white"
			},
			items: []
		};
		var hboxContainerObj = Ext.create('Ext.container.Container', hbox);
		me.contentsContainer = hboxContainerObj;

		// 印刷プレビュー
		var previewContainer = null;
		{
			// プレビューコンテナ生成
			previewContainer = {
				xtype: 'container', cls: 'first-container', border: 1,
				margin: 5,
				layout: 'vbox', // テキストエリア最大化
				items: [{
					xtype: "label",
					html: lang.__("印刷プレビュー")+'<span style="font-size:.8em">'+lang.__("（登録情報のみ）")+'</span>'
				}, {
					xtype: "label",
					html: '<span style="font-size:.8em">'+lang.__("表示ページ")+'&nbsp;'+lang.__("縦")+'&nbsp;'+lang.__("横")+'</span>'
				}]
			};

			// プレビュー画像
			{
				// 画像のコンテナを生成
				var imgContainerWidth = 256; // ポップアップウィンドウの画像の幅はいくつにする？
				var extImgContainer = {
					xtype: 'container',
					width: imgContainerWidth,
					style: {
						'text-align': 'center',
						cursor: 'pointer'
					}
				};
				var extImgContainerObj = Ext.create('Ext.container.Container', extImgContainer);
				me.previewMapImageContainer = extImgContainerObj;

				winWidth += extImgContainer.width;
			}
			previewContainer.items.push(extImgContainerObj);

			// HBoxに配置する
			hboxContainerObj.add(previewContainer);
		}

		// 印刷設定フォーム
		//formPanel.render('form-ct'); // for debug
		var formPanel = easy ? me.createEasyFormPanel() : me.createDetailFormPanel();
		me.formPanel = formPanel;
		// HBoxに配置する
		hboxContainerObj.add(formPanel);
		winWidth += formPanel.width;
		winWidth += 30; // マージン調整用

		// プログレスバー
		var progressbar =  Ext.create('Ext.ProgressBar', {
			hidden: true,
			text : me.progressbarInitText
		});
		me.progressbar = progressbar;

		// PDF出力ボタン
		var exportButton = Ext.create("Ext.Button", {
			text: lang.__("マップのPDFを出力"),
			icon: stmap.icon.getURL("printIconURL"),
			disabled: !me.isExportable(),
			tooltip: !me.isExportable() ? lang.__("出力内容を１つ以上選択してください。") : "",
			handler: function() {
				// 電子国土の場合、用紙サイズをA4までに制限する
				if(formPanel.form.isValid()) {
					me.onexport();
				}
				else {
					Ext.MessageBox.show({
						title : lang.__('PDF output error'),
						msg : lang.__('Setting is incorrect.\n Check input content.'),
						buttons : Ext.MessageBox.OK,
						animateTarget : exportButton.getEl(),
						icon : Ext.MessageBox.ERROR
					});
				}
			}
		});
		me.exportButton = exportButton;

		// 画像出力ボタン
		var exportImageButton = Ext.create("Ext.Button", {
			text: lang.__("地図画像を出力"),
			icon: stmap.icon.getURL("downloadMapIconURL"),
			handler: function() {
				// 電子国土の場合、用紙サイズをA4までに制限する
				if(formPanel.form.isValid()) {
					me.onexport();
				}
				else {
					Ext.MessageBox.show({
						title : lang.__('PDF output error'),
						msg : lang.__('Setting is incorrect.\n Check input content.'),
						buttons : Ext.MessageBox.OK,
						animateTarget : exportButton.getEl(),
						icon : Ext.MessageBox.ERROR
					});
				}
			}
		});
		me.exportImageButton = exportImageButton;

		// ダウンロードボタン
		var downloadButton = Ext.create("Ext.Button", {
			text: lang.__("Download"),
			icon: stmap.icon.getURL("downloadIconURL"),
			href: SaigaiTask.contextPath+"/PdfServlet?download",
			hidden: true
		});
		me.downloadButton = downloadButton;

		// 印刷ダイアログ
		var win = Ext.create("Ext.Window", {
			cls: "printPreviewWindow",
			closeAction: "hide",
			title: lang.__("Print dialog"),
			width: winWidth,
			dockedItems: [{
				xtype: 'toolbar',
				dock: 'top',
				padding: "10 0 3 0",
			    style: {
			    	background: "white",
			    },
			    items: [{
					xtype: "tbtext",
					text: lang.__("マップとして印刷可能なPDFファイルに出力します。"),
					style: {
				    	fontSize: "12px"
					}
				}, {
					xtype: 'tbfill'
				}, {
					xtype: 'button',
					icon: stmap.icon.getURL("rangeIconURL"),
					text: lang.__("範囲設定"),
					padding: 0,
					style: {
				    	fontSize: "12px"
					},
					handler: function() {
						// 印刷ダイアログを一旦非表示にする
						me.hideWithoutReset();
						// 印刷範囲変更ダイアログを表示
						me.pdfRangeLayer.showPdfRangeDialog();
					}
				}, {
					xtype: 'button',
					text: lang.__("保存"),
					padding: 0,
					style: {
				    	fontSize: "12px"
					},
					handler: function() {
						alert("実装中");
					}
				}, {
					xtype: 'button',
					text: lang.__("読み込み"),
					padding: 0,
					style: {
				    	fontSize: "12px"
					},
					handler: function() {
						// 印刷ダイアログを一旦非表示にする
						me.hideWithoutReset();
						// 印刷範囲一覧ダイアログを表示
						me.pdfRangeLayer.showRangeListDialog();
					}
				}, {
					xtype: 'button',
					icon: stmap.icon.getURL("reloadIconURL"),
					text: easy ? lang.__("詳細設定") : lang.__("かんたん設定"),
					padding: 0,
					style: {
				    	fontSize: "12px"
					},
					handler: function() {
						// 現在の設定値を取得し、保存する
						var values = me.getValues();
						// ウィンドウを削除し、再作成
						me.win.destroy();
						me.createWindow({
							easy: !easy
						});
						// 設定を反映して、表示
						me.formPanel.form.setValues(values);
						me.win.show();
					}
			    }]
			}],
			//items: [formPanel, progressbar],
			items: [hboxContainerObj, progressbar],
			fbar: [downloadButton, exportButton, exportImageButton],
			listeners: {
				show: function(window, eOpts) {
					// 地図画面の中央に表示
					var x = -win.getWidth()/2;
					var y = -win.getHeight()/2;
					win.alignTo("map", "c", [x, y]);

					// プレビュー画像を表示
					me.showPreview();

					// 印刷範囲レイヤを表示
					me.showPrintRange();

					// MGRSグリッド表示の設定を初期化
					var mgrsField = formPanel.form.findField("mgrs");
					if(mgrsField.getValue()==null) {
						var value = ""+(stmap.controls.mgrsControl.layer.getVisibility() ? stmap.controls.mgrsControl.layerInfo.params.precision : "-1");
						mgrsField.setValue(value);
					}
					
					// プログレスバーの幅を調整
					progressbar.setWidth(win.getWidth()-10);
				},

				hide: function(window, eOpts) {
					// ユーザが印刷ダイアログを閉じた場合は終了処理を行う
					me.onHideDialog();
				}
			}
		});
		me.win = win;
		me.topToolbar = win.getDockedItems("toolbar[dock='top']")[0];
	},
	// END createWindow:

	resetOnHide: true,

	hideWithoutReset: function() {
		var me = this;
		me.resetOnHide = false;
		me.win.hide();
		me.resetOnHide = true;
	},

	createEasyFormPanel: function() {
		var me = this;
		var stmap = me.stmap;
		var formPanel = Ext.create('Ext.form.Panel', {
			frame : false,
			border: false,
			width : 380,
			bodyPadding : 5,

			fieldDefaults : {
				labelAlign : 'left',
				anchor : '100%'
			},

			items : [{
				xtype: 'container', cls: 'first-container', border: 1,
				layout: 'fit', // テキストエリア最大化
		        items: [{
					xtype : 'textareafield',
					name : 'maptitle',
					fieldLabel : lang.__('Map title'),
					labelAlign: "top",
					rows: 2,
					value : "",
					//allowBlank: false // 未入力だと地図タイトルが自動で挿入される（非表示にできない）
					allowBlank: true // 現在は未入力だと非表示にできるのでオプション入力に変更
		        }, { // saigaitask.page.map で初期値セットするので必要
					xtype : 'hiddenfield',
					name : 'description',
					value : ""
		        }]
			}, {
				xtype: 'container', cls: 'first-container', border: 1,
		        layout: 'hbox',
		        items: [{
					flex: 1,
					xtype:  'combo',
					fieldLabel: lang.__("Paper size"),
					labelWidth: '80px',
					store: new Ext.data.SimpleStore({
						fields: ['value', 'display'],
						data: [
							["a0", "A0"],
							["a1", "A1"],
							["a2", "A2"],
							["a3", "A3"],
							["a4", "A4"],
							["a5", "A5"],
							["b0", "B0"],
							["b1", "B1"],
							["b2", "B2"],
							["b3", "B3"],
							["b4", "B4"],
							["b5", "B5"]
						],
						autoLoad: false
					}),
					displayField: 'display',
					valueField: 'value',
					name: "pagesize",
					value: "a4",
					editable: false, // 自由入力不可
					//selectOnFocus: true, // editable:false の combo は selectOnFocus:false であるべき
					validator: function(value) {
						value = this.getRawValue();
						var baseLayerInfo = stmap.map.baseLayer.layerInfo;
						/*
						if(typeof baseLayerInfo!="undefined" && baseLayerInfo.type==SaigaiTask.Map.Layer.Type.WEBTIS) {
							// 地理院タイルの場合はA3サイズまで
							var a3 = pdfControl.getPrintSize("a3");
							var selected = pdfControl.getPrintSize(value);
							if(selected.width <= a3.width && selected.height <= a3.height) {
								return true;
							}
							else return lang.__("Paper size of the Geographical Survey Institute tile is up to A3.");
						}
						*/
						return true;
					}
				}, {
		            xtype: 'splitter'
		        }, {
					flex: 1,
					xtype : 'radiogroup',
					fieldLabel : lang.__('Paper orientation'),
					labelWidth: '60px',
					columns: 2,
					items : [{
						name : 'rotate',
						inputValue : '1',
						boxLabel : lang.__('Horizontal'),
						checked: true
					}, {
						name : 'rotate',
						inputValue : '0',
						boxLabel : lang.__('Vertical')
					}],
					listeners: {
						change: function(radiogroup, newValue, oldValue, eOpts) {
							me.onchangePaperField();
						}
					}
		        }]
			}, {
				xtype: 'container', cls: 'first-container', border: 1,
				layout: 'hbox',
				defaultMargins: { top:5,bottom:5,left:5,right:5 },
				items: [{
					flex: 1,
					xtype:  'combo',
					fieldLabel : lang.__('分割印刷(縦x横)'),
					labelAlign: "top",
					store: new Ext.data.SimpleStore({
						fields: ['value', 'display'],
						data: [
							["1,1", "1 x 1"],
							["2,1", "2 x 1"],
							["1,2", "1 x 2"],
							["2,2", "2 x 2"],
							["3,3", "3 x 3"],
							["4,4", "4 x 4"]
						],
						autoLoad: false
					}),
					displayField: 'display',
					valueField: 'value',
					name: "splitprint",
					value: "1,1",
					editable: false, // 自由入力不可
					//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
					listeners: {
						"change": function(field, newValue, oldValue, eOpts) {
							var cr = newValue.split(',');
							me.values.rows = cr[0]; 
							me.values.cols = cr[1]; 
							me.onchangePaperField();
							// TODO: pdf.setPreviewPageNum(f.cols.value, f.rows.value);
						}
					}
				}, {
					flex: 2,
					xtype: "displayfield",
					margin: 5,
					value: lang.__("地図を複数ページに分割して印刷します。 拡大した地図が印刷できます。")
				}]
			}, {
				xtype: 'container', cls: 'first-container', border: 1,
		        layout: 'fit',
		        items: [{
					xtype:  'combo',
					fieldLabel: lang.__("UTM grid"),
					store: new Ext.data.SimpleStore({
						fields: ['value', 'display'],
						data: [
							["-1", lang.__("Hide")],
							["0", lang.__("0 digit: 100km")],
							["1", lang.__("Single digit: 10km")],
							["2", lang.__("The second digit: 1km")],
							["3", lang.__("The third digit: 100m")],
							["4", lang.__("The forth digit: 10m")]
							//"1m(5桁)"
						],
						autoLoad: false
					}),
					displayField: 'display',
					valueField: 'value',
					name: "mgrs",
					editable: false // 自由入力不可
					//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
		        }]
			}, {
				xtype: 'container', cls: 'first-container', border: 1,
				layout: 'hbox',
				items: [{
					flex: 1,
					xtype:  'combo',
					fieldLabel : lang.__('凡例サイズ'),
					labelAlign: "top",
					store: new Ext.data.SimpleStore({
						fields: ['value', 'display'],
						data: [
							["1.8",  lang.__("特大")],
							["1.35", lang.__("大きい")],
							["1.0",  lang.__("普通")],
							["0.8",  lang.__("小さい")],
							["0.5",  lang.__("特小")]
						],
						autoLoad: false
					}),
					displayField: 'display',
					valueField: 'value',
					name: "legendrate",
					value: "1.0",
					editable: false // 自由入力不可
					//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
				}, {
					flex: 2,
					xtype: 'container',
					layout: 'vbox',
					margin: "5 5 0 5", // bottom:0
					items: [{
						xtype:  'checkbox',
						name: "legendpos",
						boxLabel : lang.__("凡例を別ページに表示"),
						margin: 0,
						inputValue : "0"
					}, {
						xtype:  'checkbox',
						name: "legenddisplay",
						boxLabel : lang.__("全ての登録情報の凡例を表示する"),
						margin: 0,
						inputValue : "0"
					}]
				}]
			}, {
				xtype: 'container', cls: 'first-container', border: 1,
				layout: 'hbox',
				items: [{
					xtype:  'checkbox',
					name: "index_enabled",
					fieldLabel : lang.__('外枠索引'),
					boxLabel: lang.__("表示する"),
					inputValue: "1"
				}, {
					xtype:  'checkbox',
					name: "printindex",
					boxLabel: lang.__("インデックス地図出力"),
					margin: "0 0 0 10",
					inputValue: "1"
				}]
			}]
		});
		return formPanel;
	},

	createDetailFormPanel: function() {
		var me = this;
		var stmap = me.stmap;
		var formPanel = Ext.create('Ext.form.Panel', {
			frame : false,
			border: false,
			width : 460,
			bodyPadding : 5,

			fieldDefaults : {
				labelAlign : 'left',
				anchor : '100%'
			},

			items : [{
				xtype: 'tabpanel',
				defaults: {
					padding: 5
				},
				items : [{
					// BEGIN 詳細設定:印刷タブ
					id: "print-tab",
					title: lang.__("印刷"),
					items: [{
						xtype: 'container', cls: 'first-container', border: 1,
						layout: 'hbox',
						items: [{
							xtype:  'checkbox',
							name: "printmap",
							fieldLabel : lang.__('出力内容'),
							labelWidth: "60px",
							boxLabel: lang.__("マップ"),
							inputValue: "1",
							listeners: {
								change: function ( field, newValue, oldValue, eOpts ) {
									// チェック状態に応じてタブを表示・非表示する
									var printPreviewWindow = me;
									var tabpanel = printPreviewWindow.formPanel.child("tabpanel");
									var maptabpanel = tabpanel.child("#map-tab");
									if(field.checked) maptabpanel.tab.show();
									else maptabpanel.tab.hide();

									// PDF出力ボタンの有効化状態を更新
									me.updateExportButtonEnabled();
								}
							}
						}, {
							xtype:  'checkbox',
							name: "printlegend",
							boxLabel: lang.__("凡例"),
							margin: "0 0 0 10",
							inputValue: "1",
							listeners: {
								change: function ( field, newValue, oldValue, eOpts ) {
									// チェック状態に応じてタブを表示・非表示する
									var printPreviewWindow = me;
									var tabpanel = printPreviewWindow.formPanel.child("tabpanel");
									var legendtabpanel = tabpanel.child("#legend-tab");
									if(field.checked) legendtabpanel.tab.show();
									else legendtabpanel.tab.hide();

									// PDF出力ボタンの有効化状態を更新
									me.updateExportButtonEnabled();
								}
							}
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						layout: 'fit', // テキストエリア最大化コンテナ
						items: [{
							xtype: 'container', layout: 'fit', // テキストエリア最大化コンテナ
							items: [{
								xtype : 'textareafield',
								name : 'maptitle',
								fieldLabel : lang.__('Map title'),
								labelAlign: "top",
								rows: 2,
								value : "",
								//allowBlank: false // 未入力だと地図タイトルが自動で挿入される（非表示にできない）
								allowBlank: true // 現在は未入力だと非表示にできるのでオプション入力に変更
							}]
						}, {
							xtype: 'container', layout: 'fit', // テキストエリア最大化コンテナ
							items: [{
								xtype : 'textareafield',
								name : 'description',
								fieldLabel : lang.__('Explanation, annotations'),
								labelAlign: "top",
								rows: 3,
								value : ""
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						items: [{
							xtype: 'container',
							layout: 'hbox',
							items: [{
								flex: 1,
								xtype:  'combo',
								fieldLabel: lang.__("Paper size"),
								labelWidth: '80px',
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["a0", "A0"],
										["a1", "A1"],
										["a2", "A2"],
										["a3", "A3"],
										["a4", "A4"],
										["a5", "A5"],
										["b0", "B0"],
										["b1", "B1"],
										["b2", "B2"],
										["b3", "B3"],
										["b4", "B4"],
										["b5", "B5"]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "pagesize",
								value: "a4",
								editable: false, // 自由入力不可
								//selectOnFocus: true, // editable:false の combo は selectOnFocus:false であるべき
								validator: function(value) {
									value = this.getRawValue();
									var baseLayerInfo = stmap.map.baseLayer.layerInfo;
									/*
									if(typeof baseLayerInfo!="undefined" && baseLayerInfo.type==SaigaiTask.Map.Layer.Type.WEBTIS) {
										// 地理院タイルの場合はA3サイズまで
										var a3 = pdfControl.getPrintSize("a3");
										var selected = pdfControl.getPrintSize(value);
										if(selected.width <= a3.width && selected.height <= a3.height) {
											return true;
										}
										else return lang.__("Paper size of the Geographical Survey Institute tile is up to A3.");
									}
									*/
									return true;
								}
							}, {
								xtype: 'splitter'
							}, {
								flex: 1,
								xtype : 'radiogroup',
								fieldLabel : lang.__('Paper orientation'),
								labelWidth: '60px',
								columns: 2,
								items : [{
									name : 'rotate',
									inputValue : '1',
									boxLabel : lang.__('Horizontal'),
									checked: true
								}, {
									name : 'rotate',
									inputValue : '0',
									boxLabel : lang.__('Vertical')
								}],
								listeners: {
									change: function(radiogroup, newValue, oldValue, eOpts) {
										me.onchangePaperField();
									}
								}
							}]
						}, {
							xtype: "container",
							layout: "hbox",
							items: [{
								xtype:  'combo',
								fieldLabel : lang.__('マップ出力サイズ'),
								labelWidth: "110px",
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["0", "A0"],
										["1", "A1"],
										["2", "A2"],
										["3", "A3"],
										["4", "A4"],
										["5", "A5"]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "mapsize_a",
								value: "4",
								width: 150,
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}, {
								xtype: 'displayfield',
								value: lang.__("（")+lang.__("縦")
							}, {
								xtype:  'combo',
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["1", "1"],
										["2", "2"],
										["3", "3"],
										["4", "4"],
										["5", "5"],
										["6", "6"],
										["7", "7"],
										["8", "8"],
										["10", "10"],
										["12", "12"],
										["14", "14"],
										["16", "16"]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "rows",
								value: "1",
								width: 50,
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}, {
								xtype: 'displayfield',
								value: 'x'+lang.__("横")
							}, {
								xtype:  'combo',
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["1", "1"],
										["2", "2"],
										["3", "3"],
										["4", "4"],
										["5", "5"],
										["6", "6"],
										["7", "7"],
										["8", "8"],
										["10", "10"],
										["12", "12"],
										["14", "14"],
										["16", "16"]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "cols",
								value: "1",
								width: 50,
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}, {
								xtype: 'displayfield',
								value: lang.__("ページ")+lang.__("）")
							}]
						}]
					}]
				// END   詳細設定:印刷タブ
				// BEGIN 詳細設定:マップタブ
				}, {
					id: "map-tab",
					title: lang.__("マップ"),
					hidden: me.values.printmap=="0",
					items: [{
						xtype: 'container', cls: 'first-container', border: 1,
						layout: "hbox",
						items: [{
							xtype: 'displayfield',
							fieldLabel: lang.__("ページ余白(mm)")
						}, {
							xtype: 'textfield',
							fieldLabel: lang.__("上"),
							labelWidth: "20px",
							width: 60,
							name: "mapmt",
							value: "5"
						}, {
							xtype: 'textfield',
							fieldLabel: lang.__("下"),
							labelWidth: "20px",
							width: 60,
							name: "mapmb",
							value: "5"
						}, {
							xtype: 'textfield',
							fieldLabel: lang.__("左"),
							labelWidth: "20px",
							width: 60,
							name: "mapml",
							value: "5"
						}, {
							xtype: 'textfield',
							fieldLabel: lang.__("右"),
							labelWidth: "20px",
							width: 60,
							name: "mapmr",
							value: "5"
						}, {
							xtype: 'splitter'
						}, {
							xtype: 'checkbox',
							boxLabel : lang.__("余白なし"),
							width: 80,
							name: "noframe",
							inputValue: "1"
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						items: [{
							xtype: 'container',
							layout: "hbox",
							items: [{
								xtype:  'combo',
								fieldLabel: lang.__("タイトル配置"),
								labelWidth: "95px",
								width: 180,
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["-1", lang.__("表示しない")],
										["0", lang.__("左寄せ")],
										["1", lang.__("中央")],
										["2", lang.__("右寄せ")]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "titlealign",
								value: "0",
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}, {
								xtype: 'splitter'
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("文字サイズ"),
								labelWidth: "75px",
								width: 100,
								name: "titlefontsize",
								value: "32"
							}, {
								xtype: 'displayfield',
								value: "pt"
							}, {
								xtype: 'splitter'
							}, {
								xtype: 'checkbox',
								boxLabel : lang.__("自動"),
								width: 80,
								name: "titlefontauto",
								inputValue: "1"
							}]
						}, {
							xtype: 'container',
							layout: "hbox",
							items: [{
								xtype:  'combo',
								fieldLabel: lang.__("説明・注釈配置"),
								labelWidth: "95px",
								width: 180,
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["-1", lang.__("表示しない")],
										["1", lang.__("左上")],
										["3", lang.__("左下")],
										["2", lang.__("右上")],
										["4", lang.__("右下")]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "descalign",
								value: "2",
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}, {
								xtype: 'splitter'
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("文字サイズ"),
								labelWidth: "75px",
								width: 100,
								name: "descfontsize",
								value: "16"
							}, {
								xtype: 'displayfield',
								value: "pt"
							}, {
								xtype: 'splitter'
							}, {
								xtype: 'checkbox',
								boxLabel : lang.__("自動"),
								width: 80,
								name: "descfontauto",
								inputValue: "1"
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						items: [{
							xtype: 'container',
							layout: "hbox",
							items: [{
								xtype: 'displayfield',
								fieldLabel: lang.__("登録情報の\n印刷サイズ"),
								labelWidth: "80px"
							}, {
								xtype: 'splitter',
							}, {
								xtype: 'container',
								defaults: { // 子要素のデフォルト
									labelWidth: "95px",
									width: 160
								},
								items: [{
									xtype:  'combo',
									fieldLabel: lang.__("アイコン・文字"),
									store: new Ext.data.SimpleStore({
										fields: ['value', 'display'],
										data: [
											["0.3", lang.__("特小")],
											["0.66", lang.__("小さい")],
											["1.0", lang.__("普通")],
											["1.5", lang.__("1.5倍")],
											["2.0", lang.__("2倍")],
											["3.0", lang.__("3倍")],
											["4.0", lang.__("4倍")],
											["6.0", lang.__("6倍")],
											["8.0", lang.__("8倍")],
											["10.0", lang.__("10倍")]
										],
										autoLoad: false
									}),
									displayField: 'display',
									valueField: 'value',
									name: "iconrate",
									value: "1.0",
									editable: false // 自由入力不可
									//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
								}, {
									xtype:  'combo',
									fieldLabel: lang.__("線の太さ"),
									store: new Ext.data.SimpleStore({
										fields: ['value', 'display'],
										data: [
											["0.66", lang.__("細い")],
											["1.0", lang.__("普通")],
											["1.5", lang.__("1.5倍")],
											["2.0", lang.__("2倍")],
											["3.0", lang.__("3倍")],
											["4.0", lang.__("4倍")],
											["6.0", lang.__("6倍")],
											["8.0", lang.__("8倍")],
											["10.0", lang.__("10倍")]
										],
										autoLoad: false
									}),
									displayField: 'display',
									valueField: 'value',
									name: "linerate",
									value: "1.0",
									editable: false // 自由入力不可
									//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
								}]
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						items: [{
							xtype: 'container',
							layout: "hbox",
							items: [{
								xtype:  'combo',
								fieldLabel: lang.__("縮尺位置"),
								labelWidth: "60px",
								width: 145,
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["-1", lang.__("表示しない")],
										["3", lang.__("左下")],
										["4", lang.__("右下")]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "scalealign",
								value: "4",
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}, {
								xtype: "splitter"
							}, {
								xtype: 'checkbox',
								fieldLabel : lang.__("複数ページ"),
								labelWidth: "80px",
								boxLabel : lang.__("全ページに表示"),
								name: "scalepages",
								inputValue: "1"
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						layout: 'fit',
						items: [{
							xtype:  'combo',
							fieldLabel: lang.__("UTM grid"),
							store: new Ext.data.SimpleStore({
								fields: ['value', 'display'],
								data: [
									["-1", lang.__("Hide")],
									["0", lang.__("0 digit: 100km")],
									["1", lang.__("Single digit: 10km")],
									["2", lang.__("The second digit: 1km")],
									["3", lang.__("The third digit: 100m")],
									["4", lang.__("The forth digit: 10m")]
									//"1m(5桁)"
								],
								autoLoad: false
							}),
							displayField: 'display',
							valueField: 'value',
							name: "mgrs",
							editable: false // 自由入力不可
							//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
						}]
					}]
				// END   詳細設定:マップタブ
				// BEGIN 詳細設定:凡例タブ
				}, {
					id: "legend-tab",
					title: lang.__("凡例"),
					hidden: me.values.printlegend=="0",
					items: [{
						xtype: 'container', cls: 'first-container', border: 1,
						items: [{
							xtype: 'container',
							layout: "hbox",
							items: [{
								xtype: 'checkbox',
								fieldLabel : lang.__("列の幅"),
								labelWidth: "50px",
								boxLabel : lang.__("自動"),
								name: "legendcolauto",
								inputValue: "1",
								checked: true
							}, {
								xtype: "splitter"
							}, {
								xtype: "displayfield",
								value: "1/"
							}, {
								xtype:  'combo',
								width: 40,
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["2", "2"],
										["3", "3"],
										["4", "4"],
										["5", "5"],
										["6", "6"],
										["7", "7"],
										["8", "8"],
										["9", "9"],
										["10", "10"]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "legendcols",
								value: "2",
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						layout: 'hbox',
						items: [{
							xtype: 'displayfield',
							fieldLabel : lang.__('凡例サイズ'),
							labelWidth: "80px"
						}, {
							xtype: 'container',
							items: [{
								xtype:  'combo',
								width: 80,
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["1.8",  lang.__("特大")],
										["1.35", lang.__("大きい")],
										["1.0",  lang.__("普通")],
										["0.8",  lang.__("小さい")],
										["0.5",  lang.__("特小")]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "legendrate",
								value: "1.0",
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}, {
								xtype:  'checkbox',
								name: "legenddisplay",
								boxLabel : lang.__("全ての登録情報の凡例を表示する"),
								margin: 0,
								inputValue : 0
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						items: [{
							xtype: 'container',
							layout: 'hbox',
							items: [{
								xtype:  'combo',
								fieldLabel : lang.__('凡例表示位置'),
								labelWidth: "90px",
								width: 200,
								store: new Ext.data.SimpleStore({
									fields: ['value', 'display'],
									data: [
										["1",  lang.__("マップ内 左上")],
										["3",  lang.__("マップ内 左下")],
										["2",  lang.__("マップ内 右上")],
										["4",  lang.__("マップ内 右下")],
										["0",  lang.__("別ページ")]
									],
									autoLoad: false
								}),
								displayField: 'display',
								valueField: 'value',
								name: "legendpos",
								value: "3",
								editable: false // 自由入力不可
								//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
							}, {
								xtype:  'splitter',
							}, {
								xtype:  'checkbox',
								name: "legendposchk",
								boxLabel : lang.__("個別に指定"),
								margin: 0,
								inputValue : 0
							}]
						}, {
							xtype: 'container',
							layout: "hbox",
							margin: "5 0 5 0",
							items: [{
								xtype: 'displayfield',
								fieldLabel: lang.__("マップ内余白(mm)"),
								labelWidth: "120px"
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("上"),
								labelWidth: "20px",
								width: 60,
								name: "legendmapmt",
								value: "3"
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("下"),
								labelWidth: "20px",
								width: 60,
								name: "legendmapmb",
								value: "3"
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("左"),
								labelWidth: "20px",
								width: 60,
								name: "legendmapml",
								value: "3"
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("右"),
								labelWidth: "20px",
								width: 60,
								name: "legendmapmr",
								value: "3"
							}]
						}, {
							xtype: 'container',
							layout: "hbox",
							margin: "5 0 5 0",
							items: [{
								xtype: 'displayfield',
								fieldLabel: lang.__("別ページ余白(mm)"),
								labelWidth: "120px"
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("上"),
								labelWidth: "20px",
								width: 60,
								name: "legendmt",
								value: "10"
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("下"),
								labelWidth: "20px",
								width: 60,
								name: "legendmb",
								value: "10"
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("左"),
								labelWidth: "20px",
								width: 60,
								name: "legendml",
								value: "10"
							}, {
								xtype: 'textfield',
								fieldLabel: lang.__("右"),
								labelWidth: "20px",
								width: 60,
								name: "legendmr",
								value: "10"
							}, {
								xtype: 'splitter'
							}, {
								xtype: 'checkbox',
								boxLabel : lang.__("余白なし"),
								width: 80,
								name: "legendnoframe",
								inputValue: "1"
							}]
						}]
					}]
				}, {
					id: "headerfooter-tab",
					title: lang.__("ヘッダフッタ"),
					items: [{
						xtype: 'container', cls: 'first-container', border: 1,
						layout: 'hbox',
						items: [{
							xtype : 'radiogroup',
							fieldLabel : lang.__('ヘッダ<br>左'),
							labelWidth: '50px',
							columns: 2,
							items : [{
								xtype: 'container',
								layout: 'hbox',
								items: [{
									xtype: 'radio',
									name : 'header_l',
									inputValue : null,
									fieldStyle: {
										"margin-top": "15px"
									},
									boxLabel : lang.__('なし'),
									checked: true
								}, {
									xtype: 'container',
									margin: "0 0 0 10",
									items: [{
										xtype: 'radio',
										margin: 0,
										name : 'header_l',
										inputValue : "title",
										boxLabel : lang.__('タイトル')
									}, {
										xtype: 'container',
										layout: "hbox",
										padding: "0 0 3 0",
										items: [{
											xtype: 'radio',
											margin: 0,
											name : 'header_l',
											inputValue : "text",
											boxLabel : lang.__('文字列')+"&nbsp;"
										}, {
											xtype: 'textfield',
											name: "header_l_text"
										}]
									}]
								}]
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						layout: 'hbox',
						items: [{
							xtype : 'radiogroup',
							fieldLabel : lang.__('ヘッダ<br>&nbsp;&nbsp;中央'),
							labelWidth: '50px',
							columns: 2,
							items : [{
								xtype: 'container',
								layout: 'hbox',
								items: [{
									xtype: 'radio',
									name : 'header_c',
									inputValue : null,
									fieldStyle: {
										"margin-top": "15px"
									},
									boxLabel : lang.__('なし'),
									checked: true
								}, {
									xtype: 'container',
									margin: "0 0 0 10",
									items: [{
										xtype: 'radio',
										margin: 0,
										name : 'header_c',
										inputValue : "title",
										boxLabel : lang.__('タイトル')
									}, {
										xtype: 'container',
										layout: "hbox",
										padding: "0 0 3 0",
										items: [{
											xtype: 'radio',
											margin: 0,
											name : 'header_c',
											inputValue : "text",
											boxLabel : lang.__('文字列')+"&nbsp;"
										}, {
											xtype: 'textfield',
											name: "header_c_text"
										}]
									}]
								}]
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						layout: 'hbox',
						items: [{
							xtype : 'radiogroup',
							fieldLabel : lang.__('ヘッダ<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;右'),
							labelWidth: '50px',
							columns: 2,
							items : [{
								xtype: 'container',
								layout: 'hbox',
								items: [{
									xtype: 'radio',
									name : 'header_r',
									inputValue : null,
									fieldStyle: {
										"margin-top": "15px"
									},
									boxLabel : lang.__('なし'),
									checked: true
								}, {
									xtype: 'container',
									margin: "0 0 0 10",
									items: [{
										xtype: 'container',
										layout: "hbox",
										items: [{
											xtype: 'radio',
											margin: 0,
											name : 'header_r',
											inputValue : "date",
											boxLabel : lang.__('印刷日・データ日')
										}, {
											xtype: 'displayfield',
											value: "&nbsp;&nbsp;&nbsp;"
										}, {
											xtype: 'radio',
											margin: 0,
											name : 'header_r',
											inputValue : "time",
											boxLabel : lang.__('印刷日時・データ日時')
										}]
									}, {
										xtype: 'container',
										layout: "hbox",
										padding: "0 0 3 0",
										items: [{
											xtype: 'radio',
											margin: 0,
											name : 'header_r',
											inputValue : "text",
											boxLabel : lang.__('文字列')+"&nbsp;"
										}, {
											xtype: 'textfield',
											name: "header_r_text"
										}]
									}]
								}]
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						layout: 'hbox',
						items: [{
							xtype:  'checkbox',
							name: "fpage",
							fieldLabel : lang.__('フッタ'),
							labelWidth: "60px",
							boxLabel: lang.__("ページ番号"),
							inputValue: "1"
						}, {
							xtype:  'checkbox',
							name: "fmappage",
							boxLabel: lang.__("マップ分割番号"),
							margin: "0 0 0 10",
							inputValue: "1"
						}]
					}]
				}, {
					id: "index-tab",
					title: lang.__("外枠索引"),
					items: [{
						xtype: 'container', cls: 'first-container', border: 1,
						items: [{
							xtype: "fieldcontainer",
							fieldLabel : lang.__('外枠索引'),
							labelWidth: 60,
							items: [{
								xtype:  'checkbox',
								name: "index_enabled",
								boxLabel: lang.__("表示する"),
								inputValue: "1"
							}, {
								xtype: "container",
								layout: "hbox",
								width: 300,
								items: [{
									xtype:  'combo',
									fieldLabel : lang.__('横'),
									labelWidth: 20,
									width: 150,
									store: new Ext.data.SimpleStore({
										fields: ['value', 'display'],
										data: [
											["1",  lang.__("数字 (1、2、3..)")],
											["2",  lang.__("英字 (A、B、C..)")]
										],
										autoLoad: false
									}),
									displayField: 'display',
									valueField: 'value',
									name: "index_h",
									value: "2",
									editable: false // 自由入力不可
									//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
								}, {
									xtype: "displayfield",
									value: "&nbsp;&nbsp;"
								}, {
									xtype:  'combo',
									width: 40,
									store: new Ext.data.SimpleStore({
										fields: ['value', 'display'],
										data: [
											["1",  "1"],
											["2",  "2"],
											["3",  "3"],
											["4",  "4"],
											["5",  "5"],
											["6",  "6"],
											["7",  "7"],
											["8",  "8"],
											["9",  "9"],
											["10",  "10"]
										],
										autoLoad: false
									}),
									displayField: 'display',
									valueField: 'value',
									name: "index_cols",
									value: "6",
									editable: false // 自由入力不可
									//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
								}, {
									xtype: "displayfield",
									value: lang.__("分割")
								}]
							}, {
								xtype: "container",
								layout: "hbox",
								width: 300,
								items: [{
									xtype:  'combo',
									fieldLabel : lang.__('縦'),
									labelWidth: 20,
									width: 150,
									store: new Ext.data.SimpleStore({
										fields: ['value', 'display'],
										data: [
											["1",  lang.__("数字 (1、2、3..)")],
											["2",  lang.__("英字 (A、B、C..)")]
										],
										autoLoad: false
									}),
									displayField: 'display',
									valueField: 'value',
									name: "index_v",
									value: "1",
									editable: false // 自由入力不可
									//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
								}, {
									xtype: "displayfield",
									value: "&nbsp;&nbsp;"
								}, {
									xtype:  'combo',
									width: 40,
									store: new Ext.data.SimpleStore({
										fields: ['value', 'display'],
										data: [
											["1",  "1"],
											["2",  "2"],
											["3",  "3"],
											["4",  "4"],
											["5",  "5"],
											["6",  "6"],
											["7",  "7"],
											["8",  "8"],
											["9",  "9"],
											["10",  "10"]
										],
										autoLoad: false
									}),
									displayField: 'display',
									valueField: 'value',
									name: "index_cols",
									value: "6",
									editable: false // 自由入力不可
									//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
								}, {
									xtype: "displayfield",
									value: lang.__("分割")
								}]
							}, {
								xtype:  'textfield',
								name: "index_size",
								fieldLabel : lang.__('幅(mm)'),
								labelWidth: 50,
								width: 95,
								value: "5"
							}]
						}]
					}, {
						xtype: 'container', cls: 'first-container', border: 1,
						items: [{
							xtype:  'checkbox',
							name: "printindex",
							fieldLabel : lang.__("インデックス地図"),
							boxLabel: lang.__("出力する(マップ出力時のみ)"),
							inputValue: "1"
						}]
					}]
				}]
			}]
		});
		return formPanel;
	},

	onHideDialog : function()
	{
		var me = this;
		if(me.resetOnHide) {
			//範囲レイヤ非表示
			this.pdfRangeLayer.onHideDialog();
		}
	},

	onchangePaperField: function() {
		var me = this;
		me.values.bbox = null; // 一旦リセット
		me.showPrintRange();
		me.showPreview();
	},

	showPrintRange: function() {
		var me = this;
		var bounds = null;
		var bbox = me.values.bbox;
		if(!!bbox && (bbox=bbox.split(",")).length==4) {
			bounds = new OpenLayers.Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);
		}
		me.pdfRangeLayer.showPrintRange(bounds);
	},

	showPreview: function() {
		var me = this;
		var stmap = me.stmap;
		var pdfControl = me.pdfControl;
		// PDF 生成処理をリクエスト
		var params = pdfControl.createPdfParams();
		params.preview = "1"; // プレビューフラグをたてる
		stmap.api.createPdf(params, function(data) {
			var info = data;
			me._showPreview(info);
		});
	},

	// eコミマップのPdfWriterから移植
	/** <span class="ja">プレビュー表示</span><span class="en">Display preview</span> */
	_showPreview : function(info)
	{
		var me = this;
		var stmap = me.stmap;
		try {
/*
			var preview = dijit.byId('pdf_preview');
			if (!preview) return;

			var w = preview.domNode.offsetWidth;
			var h = preview.domNode.offsetHeight;
			var div = document.createElement('div');
			div.className = "pdf_preview_div";
*/

			var pdfW = info.pageWidth;
			var pdfH = info.pageHeight;

			if (pdfW && pdfH) {
/*
				var pageDiv = document.createElement('div');
				pageDiv.className = "preview_page";
				var pageX = 0;
				var pageY = 0;
				var pageW = w-4;
				var pageH = h-4;
				if (pdfW/pdfH > w/h) {
					pageH = pageW/pdfW * pdfH;
					pageY = (h-pageH)/2;
				} else {
					pageW = pageH/pdfH * pdfW;
					pageX = (w-pageW)/2;
				}
				this._setStyleRect(pageDiv.style, pageX, pageY, pageW, pageH);
				div.appendChild(pageDiv);
*/
				//<span class="ja">地図画像</span>
				//<span class="en">Map image</span>
				if (info.map) {
/*
					var mapDiv = this._createPreviewDiv(lang._('Map '), "preview_map", info.map, pdfW, pdfH, pageX, pageY, pageW, pageH);
					div.appendChild(mapDiv);
*/
					//<span class="ja">地図画像URLを設定</span>
					//<span class="en">Setting for map image URL</span>
					//var wmsUrl = this.eMap.getContentsWmsURL();

					var wmsUrl = null;
					var layerIds = stmap.getVisibleLayerIds();
					if(layerIds.length) {
						wmsUrl  = SaigaiTask.contextPath+"/page/map/wmsAuth/?SERVICE=WMS";
						var mapInfo = map.ecommaps[0].mapInfo;
						wmsUrl += "&mid="+mapInfo.mapId+"&cid="+mapInfo.communityId;
						wmsUrl += "&LAYERS="+stmap.getVisibleLayerIds().reverse().join(",");
					}
					if (wmsUrl) {
						var previewURL = wmsUrl+"&REQUEST=GetMap&FORMAT=image/png";
						previewURL += "&BBOX="+info.bbox.join(',');
						// FIXME: preview WIDTH/HEIGHT/pagerate/iconrate/linerate
						/*+"&WIDTH="+Math.floor(info.map[2]/pdfW*pageW)+"&HEIGHT="+Math.floor(info.map[3]/pdfH*pageH)
							+"&pagerate="+(pdfW/pageW)+"&iconrate="+(pageW/pdfW*info.iconRate)+"&linerate="+(pageW/pdfW*info.lineRate)
							*/
						previewURL += "&WIDTH=256&HEIGHT=256";
						previewURL += "&SRS=EPSG:"+stmap.epsg + "&epsg="+stmap.epsg;
						previewURL += "&"+new Date().getTime();

						var previewMapImageContainer = me.previewMapImageContainer;

						// 最大幅は画像コンテナの幅
						var maxw = previewMapImageContainer.width;
						// 最大高さはhboxコンテナの高さ
						var maxh = maxw;

						var extImgObj = stmap.createImg(previewURL, lang.__("印刷プレビュー（登録情報のみ）"), maxw, maxh);
						previewMapImageContainer.removeAll();
						previewMapImageContainer.add(extImgObj);

						// プレビュー画像の枠をセット
						if(!!extImgObj) extImgObj.getEl().setStyle("border", "1px solid lightgray");
					}
				}

				//index
				if (info.index_h) div.appendChild(this._createPreviewDiv(lang._('Index'), "preview_index_h", info.index_h, pdfW, pdfH, pageX, pageY, pageW, pageH));
				if (info.index_v) div.appendChild(this._createPreviewDiv(lang._('Index'), "preview_index_v", info.index_v, pdfW, pdfH, pageX, pageY, pageW, pageH));

				//<span class="ja">枠</span>
				//<span class="en">Frame</span>
				div.appendChild(this._createPreviewDiv(lang._('Map Frame'), "preview_frame", info.frame, pdfW, pdfH, pageX, pageY, pageW, pageH));

				//TODO marker

				//title
				if (info.title) div.appendChild(this._createPreviewDiv(lang._('Map Title'), "preview_title", info.title, pdfW, pdfH, pageX, pageY, pageW, pageH));
				//legend
				if (info.legend) div.appendChild(this._createPreviewDiv(lang._('Legend<!--2-->'), "preview_legend", info.legend, pdfW, pdfH, pageX, pageY, pageW, pageH));
				//scale
				if (info.scale) div.appendChild(this._createPreviewDiv(lang._('Scale'), "preview_scale", info.scale, pdfW, pdfH, pageX, pageY, pageW, pageH));
				//description
				if (info.description) div.appendChild(this._createPreviewDiv(lang._('Explanation and Comment'), "preview_description", info.description, pdfW, pdfH, pageX, pageY, pageW, pageH));
				//attribution
				if (info.attribution) div.appendChild(this._createPreviewDiv(lang._('Author Info'), "preview_attribution", info.attribution, pdfW, pdfH, pageX, pageY, pageW, pageH));
				//feature
				if (info.feature) div.appendChild(this._createPreviewDiv(lang._('Spot Description'), "preview_feature", info.feature, pdfW, pdfH, pageX, pageY, pageW, pageH));

				//TODO header
				//TODO footer
			}
			preview.set('content',div);

		} catch (e) { console.error(e); }
	},

	getValues: function() {
		var me = this;

		// 簡単設定のformPanelには一部の設定値しかないので、
		// me.values にすべての設定値を保持するようにする
		var values = me.formPanel.getValues();
		{
			var fields = me.formPanel.form.getFields().items;
			for(var idx in fields) {
				var field = fields[idx];
				if(field.xtype=="radiofield") {
					// radioの場合、チェック中の値だけ取得する
					if(field.checked) {
						var name = field.name;
						var val = field.inputValue;
						values[name] = val;
					}
				}
				else if(field.xtype=="checkbox") {
					// checkboxの場合、チェック中の値だけ取得する
					var name = field.name;
					var val = field.inputValue;
					if(field.checked) {
						values[name] = val;
					}
					else {
						values[name] = 0;
						//delete me.values[name];
					}
				}
			}

		}
		Ext.apply(me.values, values);

		//<span class="ja">範囲設定</span>
		//<span class="en">Setting the range</span>
		if(me.pdfRangeLayer!=null) {
			me.values.bbox = me.pdfRangeLayer.getBBOX();
		}

		// コピーを返却
		return Ext.apply({}, me.values);
	},

	isExportable: function() {
		var me = this;
		var values = me.getValues();
		return ! (values.printmap==0 && values.printlegend==0);
	},
	
	updateExportButtonEnabled : function() {
		var me = this;
		// 出力内容でマップと凡例のどちらも出力しない場合はエクスポート不可
		if(me.isExportable()) {
			me.exportButton.setTooltip("");
			me.exportButton.enable();
		}
		else {
			me.exportButton.setTooltip(lang.__("出力内容を１つ以上選択してください。"));
			me.exportButton.disable();
		}
	},

	/**
	 * 印刷実行時の処理
	 */
	onexport: function() {
		var me = this;
		me.progressbar.show();
		me.downloadButton.hide();
		//me.formPanel.hide(); // 再表示するとレイアウトが崩れる？
		me.exportButton.hide();
		me.exportImageButton.hide();

		me.pdfControl.print();

		// パラメータを取得してからformを無効にする
		//me.formPanel.disable();
		me.topToolbar.disable();
		me.contentsContainer.disable();
	},

	/**
	 * 印刷成功時の処理
	 */
	onsuccess: function() {
		var me = this;
		me.progressbar.reset(true);
		me.progressbar.text = me.progressbarInitText;
		me.progressbar.hide();
		me.downloadButton.show();
		//me.formPanel.enable();
		//me.formPanel.show();
		me.topToolbar.enable();
		me.contentsContainer.enable();
		me.exportButton.show();
		me.exportImageButton.show();
	}
};
/* ======================================================================
    SaigaiTask/Map/util.js
   ====================================================================== */

/**
 * Utilパッケージ
 * @requires SaigaiTask/Map.js
 */
SaigaiTask.Map.util = {};
/* ======================================================================
    SaigaiTask/Map/util/jQueryUtil.js
   ====================================================================== */

/**
 * @class SaigaiTask.Map.util.jQueryUtil
 * @static
 * @requires SaigaiTask/Map/util.js
 */
SaigaiTask.Map.util.jQueryUtil = {
	//=====================================================================
	// Form 操作
	//=====================================================================
	/**
	 * フォームからパラメータを取得します.
	 * @param {String} selector
	 * @return {Array<String>}
	 */
	getFormParams: function(selector) {
		var form = $(selector);
		// form のパラメータを配列に保存する
		var params = new Array(); // パラメータ配列 {'name=value'}
		var tags = new Array("input","select");
		for(var k in tags){
			var param = $.param(form.find(tags[k]));
			params = params.concat(param.split("&"));
		}
		// チェックされていないチェックボックスはパラメータから削除する
		$.each(form.find("input[type='checkbox']"), function(){
			var cb = $(this);
			if(cb.is(":checked")==false){
				params.splice( jQuery.inArray($.param(cb), params),1);
			}
		});
		return params;
	},

	/**
	 * form をAjaxで送信する
	 * input, select のみ対応。
	 * @param selector フォームのセレクタ
	 * @return responseText
	 */
	submitForm: function(selector, submitOption){
		// オプション設定
		var option = {
			async: false,
			data: SaigaiTask.Map.util.jQueryUtil.getFormParams(selector).join("&") // パラメータ文字列 name=value&name=value
		};
		SaigaiTask.Map.extend(option, submitOption);

		// メソッドに合わせて URL とデータを準備する
		var form = $(selector);
		option.url = form.attr("action");
		option.type = form.attr("method");
		return $.ajax(option).responseText;
	},

	//=====================================================================
	// CSS
	//=====================================================================
	/**
	 * 要素のvisibilityプロパティをセットする
	 * visibilityを指定しない場合は現在の値を取得する
	 */
	visibility: function(selector,visibility){
		var name = 'visibility';
		if( typeof visibility=='undefined') return $(selector).css(name);
		else return $(selector).css(name,(visibility?'visible':'hidden'));
	}
};

/* ======================================================================
    SaigaiTask/Map/view/DrawToolbar.js
   ====================================================================== */

/**
 *
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.DrawToolbar = function() {
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.DrawToolbar.prototype = {

	/**
	 * @type {SaigaiTask.Map}
	 */
	map: null,
	tbar: null,
	tbarItems: null,

	/**
	 * @type {SaigaiTask.Map.Layer.DrawLayer}
	 */
	drawLayer: null,

	options: null,

	initialize: function(map, toolbarOptions) {
		var me = this;
		me.map = map;
		me.drawLayer = new SaigaiTask.Map.Layer.DrawLayer(map);
		me.tbarItems = me.initDrawToolbarItems(toolbarOptions);
		if(me.options.init) {
			me.tbar = me.getSimpleToolbar();
		}

		me.loadFeatureGeometry();
	},

	/**
	 * ツールバーの描画
	 */
	getSimpleToolbar: function() {
		var me = this;
		if(me.tbar==null) {
			me.tb = Ext.create("Ext.toolbar.Toolbar", {
				items: me.tbarItems,
				renderTo: me.options.renderTo
			});
		}
		return me.tb;
	},

	/**
	 * 描画用ツールバーを表示します.
	 * @param {Object} toolbarOptions
	 * @return {Ext.toolbar.Toolbar} ツールバー
	 */
	initDrawToolbarItems: function(toolbarOptions) {
		var me = this;
		var map = me.map;
		var olmap = map.map;
		// オプションの読み込み
		var options = {};
		Ext.applyIf(options, toolbarOptions);

		// 未定義オプションはデフォルトを設定する
		var defaultOptions = {
			init: true,
			renderTo: document.body,
			label: null,
			drawPoint: false,
			drawLine: false,
			drawPolygon: false,
			drawCircle: false,
			strokeColor: false,
			modifyFeature: true,
			dragFeature: true,
			removeFeature: true,
			maxDrawNum: 1
		};
		Ext.applyIf(options, defaultOptions);
		me.options = options;

		var geomType = options.geomType;

		// ツールバーのアイテム配列
		var buttons = me.buttons = {
			drawPointButton: null,
			drawLineButton: null,
			drawPolygonButton: null,
			modifyFeatureButton: null,
			dragFeatureButton: null
		};
		var items = [];

		var maxDrawNum = options.maxDrawNum;

		/**
		 * @param drawFeatureOptions
		 */
		var drawFeature = function(drawFeatureOptions) {
			var options = {};
			Ext.applyIf(options, drawFeatureOptions);

			var defaultOptions = {
				button: null,
				map: null,
				drawKey: "point",
				maxDrawNum: 1
			};
			Ext.applyIf(options, defaultOptions);

			var button = options.button;
			var map = options.map;
			var drawKey = options.drawKey;
			var maxDrawNum = options.maxDrawNum;

			// 描画コントローラを取得
			var drawLayer = me.drawLayer;
			var drawControl = drawLayer.getDrawControl(drawKey);
			var layer = drawLayer.layer;
			var currentDrawNum = layer.features.length;

			if(currentDrawNum<maxDrawNum) {
				var onFeatureAdded = null;
				onFeatureAdded = function(){
					// 指定数描画したら
					if(maxDrawNum<=layer.features.length) {
						drawLayer.deactivateDrawControl(drawKey);
						drawControl.events.unregister("featureadded", map, onFeatureAdded);
						map.toFront(layer);
						map.setNavigationControlActivation(true);
						map.events.triggerEvent(map.EventType.afterdraw, {
							drawKey: drawKey
						});
						// ボタン押下状態にしない
						if(button!=null) {
							button.toggle(false);
						}
					}
				};
				drawControl.events.register("featureadded", map, onFeatureAdded);

				// 描画を有効にする
				drawLayer.activateDrawControl(drawKey);
				map.toFront(layer);
			}
		};

		// ラベル追加
		if(options.label) {
			items.push(options.label);
		}

		// ポイント描画ボタン
		if(options.drawPoint) {
			// UI作成
			var drawPointButton = buttons.drawPointButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Point"),
				iconCls: "draw-point-icon",
				tooltip: lang.__("Draw a point."),
				toggleGroup: "draw-button",
				enableToggle: true,
				drawToolbarType: "drawPoint"
			});
			items.push(drawPointButton);

			// 点描画イベント
			drawPointButton.on("click", function(button, e, eOpts){
				var drawKey = "point";

				// 描画コントローラを取得
				var drawLayer = me.drawLayer;
				drawLayer.deactivateCurrentDrawControl();
				var drawControl = drawLayer.getDrawControl(drawKey);
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				// 描画最大数を超えた場合は有効をキャンセルする
				if(maxDrawNum<=currentDrawNum) {
					button.toggle(false);
					alert(lang.__("This feature can register {0} {1} or less.", drawPointButton.text, maxDrawNum));
				}
				else if(button.pressed) {
					// 有効処理
					drawFeature({
						button: button,
						map: map,
						drawKey: drawKey,
						drawNum: 1,
						maxDrawNum: maxDrawNum
					});
				}
				else {
					map.setNavigationControlActivation(true);
				}
			});

			// コントローラの有効/無効にボタンを連動させる
			me.bindButtonControlActivation(drawPointButton, "point");
		}

		// ポリゴン描画ボタン
		if(options.drawPolygon) {
			// UI作成
			var drawPolygonButton = buttons.drawPolygonButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Surface"),
				iconCls: "draw-polygon-icon",
				tooltip: lang.__("Draw surface."),
				toggleGroup: "draw-button",
				enableToggle: true,
				drawToolbarType: "drawPolygon"
			});
			items.push(drawPolygonButton);

			// ポリゴン描画イベント
			drawPolygonButton.on("click", function(button, e, eOpts){
				var drawKey = "polygon";

				// 描画コントローラを取得
				var drawLayer = me.drawLayer;
				drawLayer.deactivateCurrentDrawControl();
				var drawControl = drawLayer.getDrawControl(drawKey);
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				// 描画最大数を超えた場合は有効をキャンセルする
				if(maxDrawNum<=currentDrawNum) {
					button.toggle(false);
					alert(lang.__("This feature can register {0} {1} or less.", drawPolygonButton.text, maxDrawNum));
				}
				else if(button.pressed) {
					// 有効処理
					drawFeature({
						button: button,
						map: map,
						drawKey: drawKey,
						drawNum: 1,
						maxDrawNum: maxDrawNum
					});
				}
				else {
					map.setNavigationControlActivation(true);
				}

				// コントローラの有効/無効にボタンを連動させる
				me.bindButtonControlActivation(drawPolygonButton, "polygon");
			});
		}

		// 円描画ボタン
		if(options.drawCircle) {
			// UI作成
			var drawCircleButton = buttons.drawCircleButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Circle"),
				iconCls: "draw-circle-icon",
				tooltip: lang.__("Draw a circle."),
				toggleGroup: "draw-button",
				enableToggle: true,
				drawToolbarType: "drawCircle"
			});
			items.push(drawCircleButton);

			// ポリゴン描画イベント
			drawCircleButton.on("click", function(button, e, eOpts){
				var drawKey = "circle";

				// 描画コントローラを取得
				var drawLayer = me.drawLayer;
				drawLayer.deactivateCurrentDrawControl();
				var drawControl = drawLayer.getDrawControl(drawKey);
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				// 描画最大数を超えた場合は有効をキャンセルする
				if(maxDrawNum<=currentDrawNum) {
					button.toggle(false);
					alert(lang.__("This feature can register {0} {1} or less.", drawCircleButton.text, maxDrawNum));
				}
				else if(button.pressed) {
					// 有効処理
					drawFeature({
						button: button,
						map: map,
						drawKey: drawKey,
						drawNum: 1,
						maxDrawNum: maxDrawNum
					});
				}
				else {
					map.setNavigationControlActivation(true);
				}

				// コントローラの有効/無効にボタンを連動させる
				me.bindButtonControlActivation(drawCircleButton, "circle");
			});
		}

		// ライン描画ボタン
		if(options.drawLine) {
			// UI作成
			var drawLineButton = buttons.drawLineButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Line"),
				iconCls: "draw-line-icon",
				tooltip: lang.__("Draw line."),
				toggleGroup: "draw-button",
				enableToggle: true,
				drawToolbarType: "drawLine"
			});
			items.push(drawLineButton);

			// ライン描画イベント
			drawLineButton.on("click", function(button, e, eOpts){
				var drawKey = "line";
				// 描画コントローラを取得
				var drawLayer = me.drawLayer;
				drawLayer.deactivateCurrentDrawControl();
				var drawControl = drawLayer.getDrawControl(drawKey);
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				// 描画最大数を超えた場合は有効をキャンセルする
				if(maxDrawNum<=currentDrawNum) {
					// ボタン押下状態にしない
					button.toggle(false);
					alert(lang.__("This feature can register {0} {1} or less.", drawLineButton.text, maxDrawNum));
				}
				else if(button.pressed) {
					// 有効処理
					drawFeature({
						button: button,
						map: map,
						drawKey: drawKey,
						drawNum: 1,
						maxDrawNum: maxDrawNum
					});
				}
				else {
					map.setNavigationControlActivation(true);
				}
			});

			// コントローラの有効/無効にボタンを連動させる
			me.bindButtonControlActivation(drawLineButton, "line");
		}

		// 手書きライン描画ボタン
		if(options.drawFreeLine) {
			// UI作成
			var drawFreeLineButton = buttons.drawFreeLineButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Line by hand"),
				iconCls: "draw-freeline-icon",
				tooltip: lang.__("Draw line by hand"),
				toggleGroup: "draw-button",
				enableToggle: true,
				drawToolbarType: "drawFreeLine"
			});
			items.push(drawFreeLineButton);

			// ライン描画イベント
			drawFreeLineButton.on("click", function(button, e, eOpts){
				var drawKey = "freeline";
				// 描画コントローラを取得
				var drawLayer = me.drawLayer;
				drawLayer.deactivateCurrentDrawControl();
				var drawControl = drawLayer.getDrawControl(drawKey);
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				// 描画最大数を超えた場合は有効をキャンセルする
				if(maxDrawNum<=currentDrawNum) {
					// ボタン押下状態にしない
					button.toggle(false);
					alert(lang.__("This feature can register {0} {1} or less.", drawFreeLineButton.text, maxDrawNum));
				}
				else if(button.pressed) {
					// 有効処理
					drawFeature({
						button: button,
						map: map,
						drawKey: drawKey,
						drawNum: 1,
						maxDrawNum: maxDrawNum
					});
				}
				else {
					map.setNavigationControlActivation(true);
				}
			});

			// コントローラの有効/無効にボタンを連動させる
			me.bindButtonControlActivation(drawFreeLineButton, "freeline");
		}

		// テキスト描画ボタン ※メモ機能専用、登録情報では利用不可
		if(options.drawText) {
			// UI作成
			var drawTextButton = buttons.drawTextButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Text<!--1-->"),
				iconCls: "draw-text-icon",
				tooltip: lang.__("Draw text"),
				toggleGroup: "draw-button",
				enableToggle: true,
				drawToolbarType: "drawText"
			});
			items.push(drawTextButton);

			// テキスト描画イベント
			drawTextButton.on("click", function(button, e, eOpts){
				var drawKey = "text";
				// 描画コントローラを取得
				var drawLayer = me.drawLayer;
				drawLayer.deactivateCurrentDrawControl();
				var drawControl = drawLayer.getDrawControl(drawKey);
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				if(button.pressed) {
					// 有効処理
					drawFeature({
						button: button,
						map: map,
						drawKey: drawKey,
						drawNum: 1,
						maxDrawNum: maxDrawNum
					});
				}
				else {
					map.setNavigationControlActivation(true);
				}
			});

			// コントローラの有効/無効にボタンを連動させる
			me.bindButtonControlActivation(drawTextButton, "text");
		}

		items.push("-");

		//
		// スタイルの変更ボタン
		//

		// 線の色
		if(options.strokeColor) {
			var colorMenu = Ext.create("Ext.menu.ColorPicker", {
				handler: function(cm, color) {
					//Ext.Msg.alert('Color Selected', '<span style="color:#' + color + ';">You choose '+color+'.</span>');
					// フィーチャ用の線の色を変更
					me.drawLayer.layer.styleMap.styles['default'].defaultStyle.strokeColor = "#"+color;
					me.drawLayer.userStyle.strokeColor = "#"+color;
					// 描画時のスタイルを変更
					me.drawLayer.layer.styleMap.styles['temporary'].defaultStyle.strokeColor = "#"+color;
					// ボタンの色も変更
					buttonEl = buttons.strokeColorButton.getEl();
					buttonIconEl = buttonEl.select(".x-btn-icon");
					buttonIconEl.setStyle("background-color", "#"+color);

					// 選択した地物があれば、線の色を変更する
					//<span class="ja">選択済みのFeatureの色を設定</span><span class="en">Set color for the Features which are already selected</span>
					me.drawLayer.setSelectedFeatureStyle(function(f) {
						f.style.strokeColor = "#"+color;
					});
				}
			});

			var menu = Ext.create("Ext.menu.Menu", {
				style: {
					//overflow: 'visible'
				},
				items: [{
					menu: colorMenu
				}]
			});

			var strokeColorButton = buttons.strokeColorButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Line color"),
				iconCls: "draw-freeline-icon",
				tooltip: lang.__("Change line color."),
				menu: colorMenu,
				drawToolbarType: "strokeColor"
			});
			items.push(strokeColorButton);
		}

		// 線の太さ
		if(!!options.strokeWidth) {
			var defaultStrokeWidth = me.drawLayer.layer.styleMap.styles.default.defaultStyle.strokeWidth;
			var data = [];
			var strokeWidthMenuItems = [];
			for(var strokeWidth=0; strokeWidth<=10; strokeWidth++) {
				data.push({
					display: strokeWidth+"px",
					value: strokeWidth
				});
				var getStrokeWidthIconUrl = function(strokeWidth) {
					return map.icon.baseURL+"/icons/stroke_width/line_width_"+strokeWidth+".png";
				}
				var iconUrl = getStrokeWidthIconUrl(strokeWidth);
				var handler = (function(strokeWidth) {
					return function(item, e) {
						// メニューの選択状態を変更する
						var menuItem = $(item.getEl().dom);
						menuItem.siblings().removeClass("selected-menu");
						menuItem.addClass("selected-menu");
						
						// 線の太さを変更
						me.drawLayer.layer.styleMap.styles['default'].defaultStyle.strokeWidth = strokeWidth;
						me.drawLayer.userStyle.strokeWidth = strokeWidth;
						// 描画時のスタイルを変更
						me.drawLayer.layer.styleMap.styles['temporary'].defaultStyle.strokeWidth = strokeWidth;
						var iconUrl = getStrokeWidthIconUrl(strokeWidth);
						// ボタンのアイコンも変更
						buttonEl = buttons.strokeWidthButton.getEl();
						buttonIconEl = buttonEl.select(".x-btn-icon");
						buttonIconEl.setStyle("background-image", "url('"+iconUrl+"')");

						// 選択した地物があれば、線の太さを変更する
						me.drawLayer.setSelectedFeatureStyle(function(f) {
							f.style.strokeWidth = strokeWidth;
						});
					}
				})(strokeWidth);
				strokeWidthMenuItems.push({
					text: strokeWidth+"px",
					icon: iconUrl,
					handler: handler,
					cls: strokeWidth==defaultStrokeWidth ? "selected-menu" : ""
				});
			}
			var icon = getStrokeWidthIconUrl(defaultStrokeWidth);
			var strokeWidthButton = buttons.strokeWidthButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Thickness of the line"),
				icon: icon,
				tooltip: lang.__("Change thickness of the line."),
				menu: strokeWidthMenuItems,
				drawToolbarType: "strokeWidth"
			});
			items.push(strokeWidthButton);
		}

		// 塗りつぶしの色
		if(options.fillColor) {
			var colorMenu = Ext.create("Ext.menu.ColorPicker", {
				handler: function(cm, color) {
					//Ext.Msg.alert('Color Selected', '<span style="color:#' + color + ';">You choose '+color+'.</span>');
					// フィーチャ用の塗りつぶしの色を変更
					me.drawLayer.layer.styleMap.styles['default'].defaultStyle.fillColor = "#"+color;
					me.drawLayer.userStyle.fillColor = "#"+color;
					// 描画時のスタイルを変更
					me.drawLayer.layer.styleMap.styles['temporary'].defaultStyle.fillColor = "#"+color;
					// ボタンの色も変更
					buttonEl = buttons.fillColorButton.getEl();
					buttonIconEl = buttonEl.select(".x-btn-icon");
					buttonIconEl.setStyle("background-color", "#"+color);

					// 選択した地物があれば、塗りつぶしの色を変更する
					me.drawLayer.setSelectedFeatureStyle(function(f) {
						f.style.fillColor = "#"+color;
					});
				}
			});

			// 透明度スライダーHBoxコンテナ
			var fieldContainer = Ext.create('Ext.form.FieldContainer', {
		        hideLabel: true,
				layout: {
					type: "hbox",
					align: "stretch"
				},
				defaults: {
					flex: 1
				},
				items: [{
			        xtype: 'displayfield',
			        style: {
			            "text-align": 'left',
			        },
			        value: lang.__("0%(nontransparent)")
/*			    }, {
			        xtype: 'displayfield',
			        style: {
			            "text-align": 'center',
			        },
			        value: lang.__("Transparency")*/
			    }, {
			        xtype: 'displayfield',
			        style: {
			            "text-align": 'right',
			        },
			        value: '100%'
			    }]
			});
			colorMenu.add(fieldContainer);

			// 透明度スライダー
			var opacitySlider = Ext.create('Ext.slider.Single', {
		        hideLabel: true,
		        increment: 10,
		        minValue: 0,
		        maxValue: 100,
		        value: me.drawLayer.modifyStyleMap.styles['default'].defaultStyle.fillOpacity*100, // @see DrawLayerSelectDrag.js modifyStyleMap.fillOpacity
		        tipText: function(sliderThumb) {
		        	if(sliderThumb.value==0) return lang.__("Transparency")+lang.__("0%(nontransparent)");
		        	return lang.__("Transparency")+sliderThumb.value+"%";
		        },
		        listeners: {
		        	changecomplete: function(slider, newValue, thumb, eOpts) {
		        		var opacity = Math.abs(100 - thumb.value)/100;
						// フィーチャ用の塗りつぶしの透明度を変更
						me.drawLayer.layer.styleMap.styles['default'].defaultStyle.fillOpacity= opacity;
						me.drawLayer.userStyle.fillOpacity = opacity;
						// 描画時のスタイルを変更
						me.drawLayer.layer.styleMap.styles['temporary'].defaultStyle.fillOpacity = opacity;
						/*
						// ボタンの色も変更
						buttonEl = buttons.fillColorButton.getEl();
						buttonIconEl = buttonEl.select(".x-btn-icon");
						buttonIconEl.setStyle("opacity", opacity);
						*/

						// 選択した地物があれば、塗りつぶしの透明度を変更する
						me.drawLayer.setSelectedFeatureStyle(function(f) {
							f.style.fillOpacity = opacity;
						});		        		
		        	}
		        }
		    });
			colorMenu.add(opacitySlider);

			var menu = Ext.create("Ext.menu.Menu", {
				style: {
					//overflow: 'visible'
				},
				items: [{
					menu: colorMenu
				}]
			});

			var fillColorButton = buttons.fillColorButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Fill color"),
				iconCls: "paintcan-icon",
				tooltip: lang.__("Change fill color."),
				menu: colorMenu,
				drawToolbarType: "fillColor"
			});
			items.push(fillColorButton);
		}

		// 文字の色
		if(options.fontColor) {
			var colorMenu = Ext.create("Ext.menu.ColorPicker", {
				handler: function(cm, color) {
					//Ext.Msg.alert('Color Selected', '<span style="color:#' + color + ';">You choose '+color+'.</span>');
					// フィーチャ用の文字の色を変更
					me.drawLayer.layer.styleMap.styles['default'].defaultStyle.fontColor = "#"+color;
					me.drawLayer.userStyle.fontColor = "#"+color;
					// 描画時のスタイルを変更
					me.drawLayer.layer.styleMap.styles['temporary'].defaultStyle.fontColor = "#"+color;
					// ボタンの色も変更
					buttonEl = buttons.fontColorButton.getEl();
					buttonIconEl = buttonEl.select(".x-btn-icon");
					buttonIconEl.setStyle("background-color", "#"+color);

					// 選択した地物があれば、文字の色を変更する
					me.drawLayer.setSelectedFeatureStyle(function(f) {
						f.style.fontColor = "#"+color;
					});
				}
			});

			var menu = Ext.create("Ext.menu.Menu", {
				style: {
					//overflow: 'visible'
				},
				items: [{
					menu: colorMenu
				}]
			});

			var fontColorButton = buttons.fontColorButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Font color"),
				iconCls: "draw-text-icon",
				tooltip: lang.__("Change font color."),
				menu: colorMenu,
				drawToolbarType: "fontColor"
			});
			items.push(fontColorButton);
		}

		// 文字のサイズ
		if(!!options.fontSize) {
			var defaultFontSize = me.drawLayer.layer.styleMap.styles.default.defaultStyle.fontSize;
			var data = [];
			var fontSizeMenuItems = [];
			var fontSizes = [10, 12, 14, 18, 22, 28];
			for(var idx in fontSizes) {
				fontSize=fontSizes[idx];
				data.push({
					display: fontSize+"px",
					value: fontSize
				});
				var getFontSizeIconUrl = function(fontSize) {
					var pt = fontSize;
					switch(fontSize) {
					case 10: pt=8; break; 
					case 12: pt=10; break; 
					case 14: pt=12; break; 
					case 18: pt=14; break; 
					case 22: pt=18; break; 
					case 28: pt=21; break;
					}
					return map.icon.baseURL+"/icons/font_size/font_size_"+pt+"pt.png";
				}
				var iconUrl = getFontSizeIconUrl(fontSize);
				var handler = (function(fontSize) {
					return function(item, e) {
						// メニューの選択状態を変更する
						var menuItem = $(item.getEl().dom);
						menuItem.siblings().removeClass("selected-menu");
						menuItem.addClass("selected-menu");
						
						// 文字のサイズを変更
						me.drawLayer.layer.styleMap.styles['default'].defaultStyle.fontSize = fontSize;
						me.drawLayer.userStyle.fontSize = fontSize;
						// 描画時のスタイルを変更
						me.drawLayer.layer.styleMap.styles['temporary'].defaultStyle.fontSize = fontSize;
						var iconUrl = getFontSizeIconUrl(fontSize);
						// ボタンのアイコンも変更
						buttonEl = buttons.fontSizeButton.getEl();
						buttonIconEl = buttonEl.select(".x-btn-icon");
						buttonIconEl.setStyle("background-image", "url('"+iconUrl+"')");

						// 選択した地物があれば、文字のサイズを変更する
						me.drawLayer.setSelectedFeatureStyle(function(f) {
							f.style.fontSize = fontSize;
							me.drawLayer.setLabelBackground(f);
						});
					}
				})(fontSize);
				fontSizeMenuItems.push({
					text: fontSize+"px",
					icon: iconUrl,
					handler: handler,
					cls: fontSize==defaultFontSize? "selected-menu" : ""
				});
			}
			var icon = getFontSizeIconUrl(defaultFontSize);
			var fontSizeButton = buttons.fontSizeButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Font Size"),
				icon: icon,
				tooltip: lang.__("Change size of the font."),
				menu: fontSizeMenuItems,
				drawToolbarType: "fontSize"
			});
			items.push(fontSizeButton);
		}

		items.push("-");

		// フィーチャ編集
		if(options.modifyFeature) {
			// UI作成
			var modifyFeatureButton = buttons.modifyFeatureButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Edit"),
				iconCls: "modify-feature-icon",
				tooltip: lang.__("Edit vertex of the line and face."),
				toggleGroup: "draw-button",
				enableToggle: true,
				drawToolbarType: "modifyFeature"
			});
			items.push(modifyFeatureButton);

			// フィーチャ編集イベント
			modifyFeatureButton.on("click", function(button, e, eOpts) {
				// 描画コントローラを取得
				var drawLayer = me.drawLayer;
				drawLayer.deactivateCurrentDrawControl();
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				if(button.pressed&&0<currentDrawNum) {
					drawLayer.setModifyFeatureControlActivation(true);
					map.toFront(layer);
				}
				else {
					button.toggle(false);
					map.setNavigationControlActivation(true);
				}
			});

			// コントローラの有効/無効にボタンを連動させる
			me.bindButtonControlActivation(modifyFeatureButton, "modifyFeature");
		}

		// フィーチャ移動
		if(options.dragFeature) {
			var drawLayer = me.drawLayer;
			// UI作成
			var dragFeatureButton = buttons.dragFeatureButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Move"),
				iconCls: "drag-feature-icon",
				tooltip: lang.__("Move point, line, surface."),
				toggleGroup: "draw-button",
				pressed: drawLayer.getDragFeatureControlActivation(),
				enableToggle: true,
				drawToolbarType: "dragFeature"
			});
			items.push(dragFeatureButton);

			// フィーチャ移動イベント
			dragFeatureButton.on("click", function(button, e, eOpts){
				drawLayer.deactivateCurrentDrawControl();
				// 描画コントローラを取得
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				if(button.pressed&&0<currentDrawNum) {
					drawLayer.setDragFeatureControlActivation(true);
					map.toFront(layer);
				}
				else {
					drawLayer.setDragFeatureControlActivation(false);
					map.setNavigationControlActivation(true);
				}
			});
			// コントローラの有効/無効にボタンを連動させる
			me.bindButtonControlActivation(dragFeatureButton, "dragFeature");
		}

		// フィーチャ選択
		if(options.selectDragFeature) {
			var drawLayer = me.drawLayer;
			// UI作成
			var selectDragFeatureButton = buttons.selectDragFeatureButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Select"),
				iconCls: "cursor-icon",
				tooltip: lang.__("Select feature by clicking.")+"<br/>"
				        +lang.__("To select more than one, press Ctrl key.")+"<br/>"
				        +lang.__("Delete selected features by DELETE key.")+"<br/>"
				        +lang.__("Move selected features by arrow keys.")+"<br/>"
				        +lang.__("Move feature by dragging.")+"<br/>"
				        +lang.__("Edit text by double-click."),
				toggleGroup: "draw-button",
				pressed: drawLayer.getSelectDragFeatureControlActivation(),
				enableToggle: true,
				drawToolbarType: "selectDragFeature"
			});
			items.push(selectDragFeatureButton);

			// フィーチャ選択イベント
			selectDragFeatureButton.on("click", function(button, e, eOpts){
				drawLayer.deactivateCurrentDrawControl();
				// 描画コントローラを取得
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				if(button.pressed&&0<currentDrawNum) {
					drawLayer.setSelectDragFeatureControlActivation(true);
				}
				else {
					drawLayer.setSelectDragFeatureControlActivation(false);
					map.setNavigationControlActivation(true);
				}
			});
			// コントローラの有効/無効にボタンを連動させる
			me.bindButtonControlActivation(selectDragFeatureButton, "selectDragFeature");
		}

		// フィーチャ範囲選択
		if(options.selectRangeFeature) {
			var drawLayer = me.drawLayer;
			// UI作成
			var selectRangeFeatureButton = buttons.selectRangeFeatureButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Range Select"),
				iconCls: "range-icon",
				tooltip: lang.__("Select feature by box."),
				toggleGroup: "draw-button",
				pressed: drawLayer.getBoxSelectDragFeatureControlActivation(),
				enableToggle: true,
				drawToolbarType: "selectRangeFeature"
			});
			items.push(selectRangeFeatureButton);

			// フィーチャ選択イベント
			selectRangeFeatureButton.on("click", function(button, e, eOpts){
				drawLayer.deactivateCurrentDrawControl();
				// 描画コントローラを取得
				var layer = drawLayer.layer;
				var currentDrawNum = layer.features.length;
				if(button.pressed&&0<currentDrawNum) {
					drawLayer.setBoxSelectDragFeatureControlActivation(true);
				}
				else {
					drawLayer.setBoxSelectDragFeatureControlActivation(false);
					map.setNavigationControlActivation(true);
				}
			});
			// コントローラの有効/無効にボタンを連動させる
			me.bindButtonControlActivation(selectRangeFeatureButton, "selectDragFeatureBox");
		}

		// イベント定義
		if(options.removeSelectedFeature) {
			// UI作成
			var removeSelectedFeatureButton = Ext.create("Ext.button.Button", {
				text: lang.__("Delete"),
				iconCls: "removeselected-feature-icon",
				tooltip: lang.__("Delete selected note."),
				drawToolbarType: "removeSelectedFeature"
				//toggleGroup: "draw-button",
				//enableToggle: true
			});
			items.push(removeSelectedFeatureButton);

			// フィーチャ削除イベント
			removeSelectedFeatureButton.on("click", function(button, e, eOpts){

				// フィーチャが複数ある場合は確認する
				if(0<drawLayer.layer.selectedFeatures.length) {
					Ext.MessageBox.confirm("", lang.__("Delete selected note?"),
						function(btn) {
							if(btn=="yes") {
								me.drawLayer.removeSelectedFeature(true);
							}
						}
					);
				}
			});
		}
		if(options.removeFeature) {
			// UI作成
			var removeAllFeatureButton = Ext.create("Ext.button.Button", {
				text: lang.__("Delete all<!--2-->"),
				iconCls: "removeall-feature-icon",
				tooltip: lang.__("Delete all drawn objects."),
				drawToolbarType: "removeFeature"
				//toggleGroup: "draw-button",
				//enableToggle: true
			});
			items.push(removeAllFeatureButton);

			// フィーチャ削除イベント
			removeAllFeatureButton.on("click", function(button, e, eOpts){

				// フィーチャが複数ある場合は確認する
				if(1<drawLayer.layer.features.length) {
					Ext.MessageBox.confirm(lang.__("Confirmation of all Delete"), lang.__("Are you sure to delete all drawn objects?"),
						function(btn) {
							if(btn=="yes") {
								// 地物をすべて削除
								me.drawLayer.layer.removeAllFeatures();
							}
						}
					);
				}
				else {
					// 地物をすべて削除
					me.drawLayer.layer.removeAllFeatures();
				}
			});
		}

		// 切り出しボタン
		if(options.intersectLayerId!=null) {
			var intersectLayerId = options.intersectLayerId;
			var intersectButton = Ext.create("Ext.button.Button", {
				text: lang.__("Crop"),
				iconCls: "intersection-feature-icon",
				tooltip: lang.__("Crop and shape drawing."),
				drawToolbarType: "intersect"
			});
			items.push(intersectButton);

			intersectButton.on("click", function(button, e, eOpts) {
				var feature = null;
				try{
					feature = me.getDrawFeature(geomType);
				} catch (e) {
					alert(lang.__("Invalid graphic. Please correct that graphics do not cross."));
				}
				var feature = me.getDrawFeature(geomType);
				if(feature==null) {
					alert(lang.__("No shape drawn."));
				}
				else {
					Ext.MessageBox.confirm(
						lang.__("Confirmation of cropping"),
						lang.__("Cropping by {0}.<br/>Are you sure ?", options.intersectLayerName),
						function(btn) {
							if(btn=="yes") {
								try{
									feature = feature.clone();
									var geometry = feature.geometry;
									var wkt = null;
									feature.geometry.transform(olmap.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));
									var wktFormat = new OpenLayers.Format.WKT();
									wkt = wktFormat.write(feature);
									console.log("wkt");
									console.log(wkt);
									var result = map.api.intersection(wkt, intersectLayerId);
									console.log("result");
									console.log(result);
									// 結果が返ってきたら描画しなおす
									if(result!=null && typeof result.wkt=="string") {
										var drawLayer = me.drawLayer;
										var layer = drawLayer.layer;
										// 全削除
										layer.removeAllFeatures();

										var features = wktFormat.read(result.wkt);
										if(typeof features=="undefined") {
											alert(lang.__("Shape empty."));
										}
										else {
											var geometry = features.geometry;
											var resultGeomType = geometry.CLASS_NAME.split(".")[2].toUpperCase();
											if(geomType.indexOf(resultGeomType)==-1) {
												var getGeomName = function(geomType) {
													var type = geomType.toUpperCase();
													var name =
														type.indexOf("POINT")!= -1 ? lang.__("Point"):
														type.indexOf("LINESTRING")!=-1 ? lang.__("Line"):
														type.indexOf("POLYGON")!=-1 ? lang.__("Surface"):
														lang.__("Unknown");
													if(type.indexOf("MULTI")==0) name+=lang.__("(Multiple)");
													return name;
												};
												var message = lang.__("Shape type not the same.");
												message += "\n";
												message += lang.__("Unable to draw {0} in {1}.", getGeomName(resultGeomType), getGeomName(geomType));
												alert(message);
											}
											else {
												drawLayer.drawFeatureByGeometry(geometry);
												layer.redraw(true);
											}
										}
									}
								} catch (e) {
									Ext.MessageBox.alert(lang.__("Failed to crop"), e);
								}
							}
						}
					);
				}
			});
		}

		items.push("-");

		// 元に戻す
		if(!!options.undo) {
			// UI作成
			var undoButton = buttons.undoButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Restore"),
				icon: map.icon.getURL("undoIconURL"),
				tooltip: lang.__("Restore drawing."),
				drawToolbarType: "undo"
				//toggleGroup: "draw-button",
				//enableToggle: true
			});
			// undo イベント
			undoButton.on("click", function(button, e, eOpts) {
				me.drawLayer.historyControl.undo();
			});
			items.push(undoButton);
			me.drawLayer.layer.events.on({
				"historychange": function(args) {
					var historyControl = args.historyControl;
					enable = 0<=historyControl.stackIndex;
					undoButton.setDisabled(!enable);
					console.log("undoButton: "+(enable?"enabled":"disabled")+" stackIndex:"+historyControl.stackIndex);
				}
			});
		}
		// やり直す
		if(!!options.redo) {
			// UI作成
			var redoButton = buttons.redoButton =
			Ext.create("Ext.button.Button", {
				text: lang.__("Redo"),
				icon: map.icon.getURL("redoIconURL"),
				tooltip: lang.__("Redo drawing."),
				drawToolbarType: "redo"
				//toggleGroup: "draw-button",
				//enableToggle: true
			});
			// redo イベント
			redoButton.on("click", function(button, e, eOpts) {
				me.drawLayer.historyControl.redo();
			});
			items.push(redoButton);
			me.drawLayer.layer.events.on({
				"historychange": function(args) {
					var historyControl = args.historyControl;
					enable = historyControl.stackIndex+1 < historyControl.stack.length;
					redoButton.setDisabled(!enable);
					console.log("undoButton: "+(enable?"enabled":"disabled")+" stackIndex:"+historyControl.stackIndex);
				}
			});
		}

		var splitItem = function(items) {
			var maxRowNum = 6;
			// itemの総数が1行あたりの最大個数をこえているか
			if(maxRowNum<=items.length) {
				// "-" があればそこで分割
				if(-1<items.indexOf("-")) {

				}
			}
		}

		return items;
	},

	/**
	 * 描画したフィーチャを１つのフィーチャとして取得します.
	 * @return {OpenLayers.Feature.Vector}
	 */
	getDrawFeature: function(geomType, option) {
		var me = this;
		var drawLayer = me.drawLayer;
		var layer = drawLayer.layer;
		var features = layer.features;
		if(features.length==0) return null;
		// フィーチャをコピーする
		// コピーせずにオリジナルを変換してしまうと、
		// Invalid Geometryが発生すると、変換が２回はいってしまうため
		copy = [];
		for(var featuresIdx in features) {
			copy.push(features[featuresIdx].clone());
		}
		features = copy;
		// 擬似ジオメトリOKなら変換する
		if(option && option.pseudo) {
			for(var featuresIdx in features) {
				var feature = features[featuresIdx];
				var pseudoGeom = me.convertPseudoGeometry(geomType, feature.geometry);
				if(pseudoGeom!=null) feature.geometry = pseudoGeom;
			}
		}
		return me.mergeFeatures(features, geomType);
	},

	/**
	 * features を指定したジオメトリに擬似的に変換する。
	 * @params {String} geomType 擬似ジオメトリタイプ
	 *  (MULTI)POLYGON: "POINT"は y座標を上下0.5cmずつずらす
	 * @params {OpenLayers.Geometry} geometry 変換対象ジオメトリ
	 */
	convertPseudoGeometry: function(geomType, geometry) {
		var me = this;
		var drawLayer = me.drawLayer;
		var layer = drawLayer.layer;
		// MULTI を外して、擬似ジオメトリタイプを取得
		var pseudoGeomType = (-1<geomType.indexOf("MULTI") ? geomType.substring(geomType.indexOf("MULTI")+5) : geomType);

		// 擬似ジオメトリに変換する
		switch(pseudoGeomType) {
		case "POINT" :
			// todo: pseudo Point
			break;
		case "LINESTRING" :
			// todo: pseudo LineString
			break;
		// 擬似ポリゴン
		case "POLYGON" :
			// ポリゴンレイヤでの擬似ポイントに変換
			var pseudoPointDiffMeter = 0.01; // 擬似ポイントのポリゴンは, 1cm ずらしたポリゴンとする
			var meterProj = new OpenLayers.Projection("EPSG:900913");
			if(geometry.CLASS_NAME=="OpenLayers.Geometry.Point") {
				// x座標は変えずに、y座標だけ上下に 1cm ずつずらした 擬似ポイントのポリゴンにする
				var northPoint = null;
				var southPoint = null;
				{
					var p = geometry.clone();
					// メートル座標系に変換する
					p.transform(layer.projection, meterProj);
					// x座標は変えない
					// y座標のみずらす
					var northPoint = p.clone();
					northPoint.y = p.y+(pseudoPointDiffMeter/2);
					var southPoint = p.clone();
					southPoint.y = p.y-(pseudoPointDiffMeter/2);
					// もとの座標系に戻す
					northPoint.transform(meterProj, layer.projection);
					southPoint.transform(meterProj, layer.projection);
				}
				var ring = new OpenLayers.Geometry.LinearRing([southPoint, northPoint, northPoint, southPoint]);
				var polygon = new OpenLayers.Geometry.Polygon([ring]);
				return polygon;
			}
			// ポリゴンレイヤでの擬似ラインに変換
			else if(geometry.CLASS_NAME=="OpenLayers.Geometry.LineString") {
				var points = [].concat(geometry.components).concat([].concat(geometry.components).reverse());
				var ring = new OpenLayers.Geometry.LinearRing(points);
				var polygon = new OpenLayers.Geometry.Polygon([ring]);
				return polygon;
			}
			// Polygon が擬似ポイントなら元に戻す
			else if(geometry.CLASS_NAME=="OpenLayers.Geometry.Polygon") {
				// 擬似ポイント
				var isPseudoPoint = function(polygon) {
					if(polygon.components.length!=1) return false;
					var line = polygon.components[0];
					var southPoint = line.components[0].clone();
					var northPoint = line.components[1].clone();
					if(line.components.length!=4) return false;
					if(southPoint.equals(line.components[3])==false) return false; // assert 最初と最後の点が同じ
					if(northPoint.equals(line.components[2])==false) return false; // assert 間の点も同じ
					if(southPoint.x!=northPoint.x) return false; // assert x座標が同じ
					northPoint.transform(layer.projection, meterProj);
					southPoint.transform(layer.projection, meterProj);
					if(pseudoPointDiffMeter*2<(northPoint.y-southPoint.y)) return false; // assert y座標の距離が 2cm 以下(誤差を考慮して2倍する)
					return true;
				}
				// 擬似ライン
				var isPseudoLineString = function(polygon) {
					if(polygon.components.length!=1) return false;
					var line = polygon.components[0];
					// ラインの点を逆にするため、偶数であるはず
					if(line.components.length%2!=0) return false;

					// 2つの線を取り出して、ラインの点を逆にして各点の位置が同じかチェックする
					var pointsNum = line.components.length/2;
					var line1 = new OpenLayers.Geometry.LineString(line.components.slice(0, pointsNum));
					var line2 = new OpenLayers.Geometry.LineString(line.components.slice(pointsNum).reverse());
					return line1.equals(line2);
				}
				if(isPseudoPoint(geometry)) {
					var line = geometry.components[0];
					var southPoint = line.components[0];
					var northPoint = line.components[1];
					point = southPoint.clone();
					point.y = (southPoint.y + northPoint.y)/2;
					return point;
				}
				else if(isPseudoLineString(geometry)) {
					var line = geometry.components[0];
					var pointsNum = line.components.length/2;
					var line1 = new OpenLayers.Geometry.LineString(line.components.slice(0, pointsNum));
					return line1;
				}
			}
			break;
		}

		return null;
	},

	/**
	 * 複数のFeatureをマルチやコレクションのFeatureにまとめる
	 * @param {Array<OpenLayers.Feature.Vector>} features
	 * @param {String} geomType
	 * @return {OpenLayers.Feature.Vector}
	 */
	mergeFeatures : function(features, geomType) {
		var feature;
		if (geomType.match(/^MULTI/)) {
			switch(geomType) {
			case "MULTIPOINT" :
				feature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.MultiPoint(features[0].geometry));
				break;
			case "MULTILINESTRING" :
				feature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.MultiLineString(features[0].geometry));
				break;
			case "MULTIPOLYGON" :
				if(features[0].geometry.CLASS_NAME=="OpenLayers.Geometry.MultiPolygon") {
					feature = features[0];
				}
				else {
					feature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.MultiPolygon(features[0].geometry));
				}
				break;
			/*case this.GEOMETRYCOLLECTION :
				feature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.Collection(features[0].geometry));
				break;*/
			}
			//<span class="ja">マルチポリゴンの重なりチェック</span><span class="en">Check the multiple polygon overlap</span>
			if (geomType == "MULTIPOLYGON") {
				for (var i=1; i<features.length; i++) {
					if (!features[i]._sketch) {
						for (var j=0; j<i; j++) {
							if (!features[j]._sketch && features[i].geometry.intersects(features[j].geometry)) throw "Invalid Geometry";
						}
					}
				}
			}

			//<span class="ja">追加</span><span class="en">Insert</span>
			for (var i=1; i<features.length; i++) {
				if (!features[i]._sketch) feature.geometry.addComponents(features[i].geometry);
			}
			feature.fid = features[0].fid;
			feature.layer = features[0].layer;

		} else {
			feature = features[0];
		}
		return feature;
	},

	/**
	 * 0番目のジオメトリの値を読み込む
	 */
	loadFeatureGeometry: function() {
		console.log("loadFeatureGeometry");
		var me = this;
		var stmap = me.map;
		var drawLayer = me.drawLayer;
		var selector = "."+drawLayer.getFeatureIDPrefix()+"0";
		var features = stmap.readFeatureGeometryValue(selector);
		if(features!=null){
			var geometry = features.geometry;
			geometry.transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:"+stmap.epsg));
			var gClass = geometry.CLASS_NAME;
			switch(gClass){
			case "OpenLayers.Geometry.Point":
				var lonlat = new OpenLayers.LonLat(geometry.x, geometry.y);
				drawLayer.moveSinglePoint(lonlat);
				break;
			case "OpenLayers.Geometry.LineString":
			case "OpenLayers.Geometry.MultiLineString":
				drawLayer.drawFeature("line", geometry);
				break;
			case "OpenLayers.Geometry.Polygon":
			case "OpenLayers.Geometry.MultiPolygon":
				drawLayer.drawFeature("polygon", geometry);
				break;
			default:
				console.warn(lang.__("Not support.({0})", gClass));
				break;
			}
		}
	},

	/**
	 * コントローラの有効/無効にボタンを連動させる
	 */
	bindButtonControlActivation: function(button, drawKey) {
		var me = this;
		var control = me.drawLayer.getDrawControl(drawKey);
		control.events.register("activate", null, function() {
			button.toggle(true);
		});
		control.events.register("deactivate", null, function() {
			button.toggle(false);
		});
	}
};
/* ======================================================================
    SaigaiTask/Map/VectorLayer.js
   ====================================================================== */

/**
 * 
 * @requires SaigaiTask/Map.js
 */
SaigaiTask.Map.VectorLayer = function(){
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.VectorLayer.prototype = {

	/**
	 * @type {SaigaiTask.Map}
	 */
	map: null,

	/**
	 * eコミマップの地図ID
	 * @type {Number}
	 */
	mapId: null,

	/**
	 * eコミマップでのレイヤID
	 * @type {String}
	 */
	layerId: null,

	/**
	 * 避難所ベクタレイヤ
	 * @type {OpenLayers.Layer.Vector}
	 */
	layer: null,

	/**
	 * 選択フィーチャの配列
	 * @type {Array<Number>}
	 */
	selectedFeatureIds: [],

	/**
	 * コンストラクタに渡したオプション
	 */
	options: null,

	/**
	 * 検索実行時のjQuery.ajaxのオプション
	 * 前回の検索Ajaxのオプションを保存.
	 * @type {Object}
	 */
	option: null,

	/**
	 * OpenLayersのイベントクラス
	 * @type {OpenLayers.Events}
	 */
	events: null,

	/**
	 * Mapクラスのイベントタイプ
	 * @type {Object<String, String>}
	 */
	EventType: {
		/** 選択前 */
		beforeselected: "beforeselected"
	},

	/**
	 * コンストラクタ
	 * @param {SaigaiTask.Map} map
	 * @param {Object<String, *>} options オプション
	 * @param {String} options.sld スタイルオプション
	 */
	initialize: function(map, options) {
		var me = this;
		me.map = map;
		var olmap = map.map;

		// オプションの保存
		me.options = options;
		me.mapId = options.mapId;
		var layerId = me.layerId = options.layerId;

		// WMSの方は非表示にする
		map.switchContentsLayer(layerId, false);
		map.setLayerSearchable(layerId, true);

		// レイヤの準備
		var layer = me.layer = new OpenLayers.Layer.Vector(me.layerId + " Vector Layer", {
			projection: olmap.displayProjection,
			preFeatureInsert: function(feature) {
				feature.geometry.transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:"+map.epsg));
			}
		});
		olmap.addLayer(layer);

		// SLD
		var sldXML = options.sld;
		if(sldXML!=null) {
			var sldFormat = new OpenLayers.Format.SLD();
			var sld = sldFormat.read(sldXML);
			for(var l in sld.namedLayers){
				var styles = sld.namedLayers[l].userStyles;
				me.layer.styleMap = styles[0];
			}
		}

		// styleMap
		var styleMap = options.styleMap;
		if(styleMap!=null) {
			me.layer.styleMap = styleMap;
		}

		// フィーチャをhoverしたときのスタイル
		var highlightFeature = me.highlightFeatureControl = new OpenLayers.Control.SelectFeature(layer, {
			hover: true,
			highlightOnly: true,
			renderIntent: "temporary",
			eventListeners: {
				featurehighlighted: function(e) {
				},
				featureunhighlighted: function(e) {
				}
			}
		});
		map.addControl(highlightFeature);

		// フィーチャをクリックしたときのスタイル
		var selectFeature = me.selectFeatureControl = new OpenLayers.Control.SelectFeature(layer, {
			clickout: false,
			toggle: true,
			multiple: true,
			toggleKey: "ctrlKey",
			multipleKey: "shiftKey",
			renderIntent: "select",
			eventListeners: {
				featurehighlighted: function(e) {
					var feature = e.feature;
					var attributes = feature.attributes;
					me.select(attributes);
				},
				featureunhighlighted: function(e) {
					var feature = e.feature;
					var attributes = feature.attributes;
					var id = attributes.id;
					// テーブルから削除する
					me.remove(id);
				}
			}
		});
		map.addControl(selectFeature);

		me.events = new OpenLayers.Events(me);
	},

	load: function(json) {
		var me = this;
		var map = me.map;
		var layer = me.layer;
		var layerId = me.layerId;

		var count = json.count;
		layer.removeAllFeatures();
		if(0<count) {
			// フィーチャの追加
			var records = json.records;
			var recordsIdx = null, record, wkt;
			var wktFormat = new OpenLayers.Format.WKT(), features = [], feature;
			var filter = [];
			for(recordsIdx in records) {
				record = records[recordsIdx];
				// フィーチャ
				wkt = record.wkt;
				if(wkt!=null) {
					feature = wktFormat.read(wkt);
					feature.attributes = record;
					features.push(feature);
					// フィルタするフィーチャID
					filter.push(record.featureid);
				}
			}
			layer.addFeatures(features);
			// 選択済みフィーチャは選択済みで表示する
			for(var selectedFeatureIdsIdx in me.selectedFeatureIds) {
				var selectedFeatureId = me.selectedFeatureIds[selectedFeatureIdsIdx];
				var feature = me.getFeature(selectedFeatureId);
				if(feature!=null) {
					me.selectFeatureControl.select(feature);
				}
			}
			// フィルタの更新
			if(map.searchFilter==null) map.searchFilter={};
			map.searchFilter[layerId] = filter;
			// レイヤのZ-Indexを更新する
			map.toFront(layer);
		}
	},

	search: function(formSelector) {
		var me = this;
		var form = $(formSelector);
		var option = {};
		option.url = form.attr("action");
		option.type = form.attr("method");
		option.data = SaigaiTask.Map.util.jQueryUtil.getFormParams(formSelector).join("&"); // パラメータ文字列 name=value&name=value
		option.async = true;
		option.success = function(json) {
			me.load(json);
		};
		me.option = option;
		$.ajax(option);
	},

	research: function() {
		var me = this;
		$.ajax(me.option);
	},

	/**
	 * 属性情報で選択済みにします.
	 */
	select: function(attributes) {
		var me = this;

		var cont = me.events.triggerEvent(me.EventType.beforeselected, {
			attributes: attributes
		});
		if(cont==false) return;

		// 選択済みフィーチャの配列に登録
		var id = attributes.id;
		if(jQuery.inArray(id, me.selectedFeatureIds)==-1) {
			me.selectedFeatureIds.push(id);
		}

		// フィーチャがあれば選択状態にする
		var feature = me.getFeature(id);
		if(feature!=null) {
			if(me.isSelected(feature)==false) {
				me.selectFeatureControl.select(feature);
			}
		}
	},

	selectByGeometry: function(geometry) {
		var me = this;
		if(geometry!=null) {
			var features = me.layer.features;
			for(var featuresIdx in features) {
				var feature = features[featuresIdx];
				var point = feature.geometry.getCentroid();
				if(point.intersects(geometry)) {
					var attributes = feature.attributes;
					me.select(attributes);
				}
			}
		}
	},

	unselect: function(id) {
		var me = this;

		// 選択済みID配列から削除する
		var index = jQuery.inArray(id, me.selectedFeatureIds);
		if(index!=-1) {
			me.selectedFeatureIds.splice(index, 1);
		}

		// フィーチャがあれば未選択にする
		var feature = me.getFeature(id);
		if(feature!=null) {
			me.selectFeatureControl.unselect(feature);
		}
	},

	/**
	 * 選択済みから外します.
	 * @param {Number} id ID
	 */
	remove: function(id) {
		var me = this;

		// 選択済みID配列から削除する
		var index = jQuery.inArray(id, me.selectedFeatureIds);
		if(index!=-1) {
			me.selectedFeatureIds.splice(index, 1);
		}
	},

	/**
	 * レイヤからID指定でフィーチャを取得します.
	 * @param {Number} id ID
	 * @return {OpenLayers.Feature.Vector}
	 */
	getFeature: function(id) {
		var me = this;
		var features = me.layer.getFeaturesByAttribute("id", id);
		var feature = null;
		if(0<features.length) {
			feature = features[0];
		}
		return feature;
	},

	/**
	 * 指定フィーチャが選択済みかどうかチェックします.
	 * @return {Boolean}
	 */
	isSelected: function(feature) {
		var me = this;
		var selectedFeatures = me.layer.selectedFeatures;
		return jQuery.inArray(feature, selectedFeatures)!=-1;
	}
};

/* ======================================================================
    SaigaiTask/Map/view/ContentsFileFormPanel.js
   ====================================================================== */

/**
 * @require SaigaiTask/Map/view.js
 * @returns {SaigaiTask.Map.view.CotnentsFileFormPanel}
 */
SaigaiTask.Map.view.ContentsFileFormPanel = function() {
	this.initialize.apply(this, arguments);
};

SaigaiTask.Map.view.ContentsFileFormPanel.prototype = {

	/**
	 * 地図
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * @type {Ext.Form.Panel}
	 */
	formPanel: null,

	/**
	 * 画像一覧ビュー
	 * @type {Ext.view.View}
	 */
	imageView: null,

	/** ファイル情報ストア */
	store: null,

	/**
	 * 地図ID
	 * @type {Number}
	 */
	mid: null,

	/**
	 * レイヤID
	 * @type {String}
	 */
	layerId: null,

	/**
	 * フィーチャID
	 * @type {Number}
	 */
	fid: null,

	/**
	 * 登録情報登録ウィンドウを表示します.
	 * @param content 登録情報
	 * @param options.mid 地図ID
	 * @param options.layerId レイヤID
	 * @param options.fid フィーチャID
	 */
	initialize: function(stmap, content, options) {

		var me = this;
		me.stmap = stmap;
		me.mid = options.mid;
		me.layerId = options.layerId;
		me.fid = options.fid;
		if(options.editable == 'undefined') options.editable = true;

		var ecommapURL = me.stmap.ecommaps[0].ecommapURL;

		// ファイル情報データモデルを定義
		ImageModel = Ext.define('ImageModel', {
			extend: 'Ext.data.Model',
			fields: [
			   {name: 'title'},
			   {name: 'url'},
			   {name: 'thumbnail'}
			]
		});

		// ファイル情報からデータを生成
		var data = [];
		if(content!=null) {
			var files = content.files;
			if(files && 0<files.length ) {
				var filesIdx = 0;
				while(filesIdx<files.length) {
					// 画像URLのサーバ名を動的に取得する
					var server = stmap.ecommaps[0].ecommapURL+'/..';

					// 画像URL
					var fileURL = files[filesIdx];
					if(fileURL.indexOf('http')==-1) fileURL = server + fileURL;
					var fileTitle = files[filesIdx+1];

					// サムネイル画像
					var url = fileURL;
					var ext = FalUtil.getFileExt(url);
					var thumbnail = url;
					// 画像以外のファイルの場合はアイコン表示
					if (! ext.match(/jpg|gif|png|jpeg|file/)) {
						thumbnail = ecommapURL+"/map/fileicons/"+ext+".png";
					}

					data.push({
						title: fileTitle,
						url: fileURL,
						thumbnail: thumbnail
					})
					filesIdx += 2;
				}
			}
		}

		// データストアを生成
		var store = me.store = Ext.create('Ext.data.Store', {
			model: 'ImageModel',
			data: data
		});

		// 画像一覧ビュー
		var imageView = me.imageView = Ext.create('Ext.view.View', {
			store: store,
			tpl: [
				'<tpl for=".">',
				'<div class="thumb-wrap" id="{title:stripTags}" style="'+(options.editable?"":"cursor:pointer;")+'">',
				//'<div class="thumb"><img src="{thumbnail}" title="{title:htmlEncode}"></div>',
				// 幅は固定で86px。1920x1080の16:9の比率の場合、最適な高さは48.375pxとなるので49pxとする。つまり画像サイズは86x49。 
				'<div class="thumb" style="height:49px; background-image: url(\'{thumbnail}\'); background-size:contain; background-repeat:no-repeat;background-position:center center;"></div>',
				'<span class="x- editable">{shortName:htmlEncode}</span>',
				'</div>',
				'</tpl>',
				'<div class="x-clear"></div>'
			],
			multiSelect: false,
			//maxHeight: 310,
			trackOver: true,
			overItemCls: 'x-item-over',
			itemSelector: 'div.thumb-wrap',
			emptyText: lang.__('The file is not registered.'),
			plugins: [
				Ext.create('Ext.ux.DataView.DragSelector', {}),
				Ext.create('Ext.ux.DataView.LabelEditor', {dataIndex: 'title'})
			],
			prepareData: function(data) {
				Ext.apply(data, {
					shortName: Ext.util.Format.ellipsis(data.title, 15)
				});
				return data;
			},
			listeners: {
				selectionchange: function(dv, nodes ){
					//FalUtil.showImageWindow(dv.lastSelected.data.url);
				},
				itemclick: function( dv, record, item, index, e, eOpts ) {
					// 閲覧時はクリックして 拡大表示 or ダウンロード
					if(!options.editable) {
						var url = record.data.url;
						var ext = FalUtil.getFileExt(url);
						// 画像の場合はプレビュー表示
						if (ext.match(/jpg|gif|png|jpeg|file/)) {
							FalUtil.showImageWindow(url);
						} else {
							//img.src = "/map/map/fileicons/"+ext+".png";
							FalUtil.downloadFile({
								url: url
							});
						}
					}
				}
			},
			fbar: [{
				xtype: "button",
				text: lang.__("Add<!--2-->")
			}]
		});

		// 添付ファイルフォームを生成
		var formPanel = me.formPanel = Ext.create("Ext.form.Panel", {
			//xtype: "panel",
			// id指定すると、同時に２以上表示したときにデータが新しい方に移ってしまうので、cls指定とする
			//id: 'images-view',
			cls: 'images-view',
			autoScroll: true,
			frame: false,
			collapsible: true,
			header: false,
			tbar: !options.editable ? null : {
				//style: "border-Color: transparent; background-Color: transparent; background-Image: none;",
				items: [{
					xtype: "button",
					text: lang.__("Add<!--2-->"),
					icon: stmap.icon.getURL("addIconURL"),
					handler: function() {
						me.showAddFileWindow();
					}
				}, {
					xtype: "button",
					text: lang.__("Delete"),
					icon: stmap.icon.getURL("deleteIconURL"),
					handler: function() {
						var selection = imageView.getSelectionModel().getSelection();
						if (0<selection.length) {

							store.remove(selection);
						}
						else alert(lang.__("Click after select file that you want to delete."));
					}
				}]
			},
			items: imageView
		});

	},

	showAddFileWindow: function() {
		var me = contentsFileFormPanel = this;
		var stmap = me.stmap;
		// 登録情報の添付ファイル登録フォームを表示
		// TODO: ファイルアップロードフォームとURL入力フォームをユーザが選べるようにする。
		// 以下のURL入力フォームは動作確認済みであとはタブかなにかで選べるようにするだけ。。。
		// URL入力フォームを生成
		var formPanel = Ext.create("Ext.form.Panel", {
			autoScroll: true,
			border: false,
			fieldDefaults: {
				labelWidth: 100,
				anchor: '100%'
			},
			defaultType: 'textfield',
			bodyPadding: 5,
			items: [{
				xtype: "textfield",
				fieldLabel: lang.__("Title<!--2-->"),
				name: "title",
				allowBlank: false
			}, {
				xtype: "textfield",
				fieldLabel: "URL",
				name: "url",
				vtype: 'url',
				allowBlank: false
//			}, {
//				xtype: "filefield",
//				name: "file",
//				fieldLabel: "ファイル",
//				msgTarget: "side",
//				buttonText: "ファイルを選択"
			}],
			/**
			 * データストアに入力値を追加します.
			 */
			appendData: function() {
				var formValues = formPanel.form.getValues();
				var title = formValues["title"];
				var url = formValues["url"];
				me.store.loadRawData([{
					title: title,
					url: url
				}], true);
			}
		});
		// ファイルアップロードフォームを生成
		formPanel = Ext.create("Ext.form.Panel", {
			fileUpload: true,
			autoScroll: true,
			border: false,
			fieldDefaults: {
				labelWidth: 100,
				anchor: '100%'
			},
			defaultType: 'textfield',
			bodyPadding: 5,
			items: [{
				xtype: "hidden",
				name: "mid",
				value: me.mid
			}, {
				xtype: "hidden",
				name: "layer",
				value: me.layerId
			}, /*{
				xtype: "hidden",
				name: "fid",
				value: me.fid
			},*/ {
				xtype: "textfield",
				fieldLabel: lang.__("Title<!--2-->"),
				name: "files[0].title"
				//allowBlank: false
//			}, {
//				xtype: "textfield",
//				fieldLabel: "URL",
//				name: "url",
//				vtype: 'url'
			}, {
				xtype: "filefield",
				name: "files[0].formFile",
				fieldLabel: lang.__("File"),
				msgTarget: "side",
				buttonText: lang.__("Choose file"),
				allowBlank: false
			}],
			/**
			 * ファイルアップロードを実行します.
			 */
			upload: function() {
				var me = this;
				var ecommapURL = stmap.ecommaps[0].ecommapURL;
				var form = me.getForm();
				if(form.isValid()) {
					form.submit({
						url: SaigaiTask.contextPath+"/page/map/ecommap/contents/uploadFile/",
						params: '&_csrf='+SaigaiTask.ajaxcsrfToken,
						waitMsg: lang.__("Uploading file.."),
						success: function(form, action) {
							var fileList = action.result.fileList;
							if(0<fileList.length) {
								for(var key in fileList) {
									var values = fileList[key];
									if(values.length==2) {
										var fileUrl = values[0];
										var fileTitle = values[1];
										var ext = FalUtil.getFileExt(fileUrl);
										var thumbnail = fileUrl;
										// 画像以外のファイルの場合はアイコン表示
										if (! ext.match(/jpg|gif|png|jpeg|file/)) {
											thumbnail = ecommapURL+"/map/fileicons/"+ext+".png";
										}
										contentsFileFormPanel.store.loadRawData([{
											title: fileTitle,
											url: fileUrl,
											thumbnail: thumbnail
										}], true);
									}
								}
							}
							win.close();
						},
						failure: function(form, action) {
							win.close();

							var msg = lang.__("Failed to upload file.");
							try{
								var result = Ext.decode(action.response.responseText);
								if(typeof result.msg!="undefined") {
									msg += "</br>" + result.msg;
								}
							} catch(e) {
								// do nothing
							}
							var msgwin = Ext.Msg.show({
								title: lang.__("Error"),
								msg: msg,
								buttons: Ext.MessageBox.OK,
								icon: Ext.MessageBox.ERROR
							});
						}
					})
				}
			}
		});
		// フォームのウィンドウを生成
		var win = null;
		win = me.window = Ext.create('Ext.window.Window', {
			title: lang.__('Attachment registration form'),
			width: 500,
			maxWidth: document.body.clientWidth,
			maxHeight: document.body.clientHeight,
			collapsible: false,
			modal: true,
			layout: 'fit',
			items: formPanel,
			buttons: [{
				text: 'OK',
				handler: function() {
					formPanel.upload();
					//win.close();
				}
			}, {
				text: lang.__('Cancel'),
				handler: function(){ win.close(); }
			}]
		});
		win.show();
	},

	/**
	 * ファイルの登録数に応じて、
	 * 1件もない場合は、
	 * ・追加ボタンを押してから、画像パネルを出す
	 * 登録があれば、
	 * ・最初から画像パネルを出す
	 * ような、アイテムを返す
	 */
	getFieldSetItems: function() {
		var me = this;
		var items = null;
		if(me.store.getCount()==0) {
			items = [{
				xtype: "button",
				text: lang.__("Add<!--2-->"),
				handler: function(button, e) {
					// 存在するかチェックする
					//button.ownerCt.getComponent("images-view");
					// 添付ファイル登録パネルを追加
					button.ownerCt.add(me.formPanel);
					// 追加ボタンを削除
					button.ownerCt.remove(button);
					// 登録ウィンドウを表示
					me.showAddFileWindow();
				}
			}];
		}
		else {
			items = me.formPanel;
		}
		return items;
	},

	/**
	 * ファイルパラメータをJSON配列で取得します.
	 * @type {JSONArray}
	 */
	getJSONArray: function() {
		var me = this;
		var array = [];
		var data = me.store.data;
		for(var key in data.items) {
			var item = data.items[key];
			array.push([item.data.url, item.data.title]);
		}
		return array;
	}
};
/* ======================================================================
    SaigaiTask/Map/Layer/GoogleLayer.js
   ====================================================================== */

/**
 * Google Layer
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 */
SaigaiTask.Map.Layer.GoogleLayer = new OpenLayers.Class(OpenLayers.Layer.Google, {
	layerInfo: null,
	initialize: function(layerInfo) {
		this.layerInfo = layerInfo;
		var options = {
			reprojection: true,
			isBaseLayer: true,
			buffer: 0,
			opacity: layerInfo.opacity,
			alpha: true,
			visibility: true,
			attribution: layerInfo.attribution
		};

		if("SATELLITE"==layerInfo.featuretypeId){
			options.type = google.maps.MapTypeId.SATELLITE;
		} else if("HYBRID"==layerInfo.featuretypeId){
			options.type = google.maps.MapTypeId.HYBRID;
		} else if("PHYSICAL"==layerInfo.featuretypeId || "TERRAIN"==layerInfo.featuretypeId){
			options.type = google.maps.MapTypeId.TERRAIN;
		}
		options.sphericalMercator = true;

		var name = "Google_"+layerInfo.featuretypeId;
		OpenLayers.Layer.Google.prototype.initialize.apply(this, [name, options]);
	}
});

SaigaiTask.Map.Layer.GoogleLayer.type = SaigaiTask.Map.Layer.Type.GOOGLE;
/* ======================================================================
    SaigaiTask/Map/EcommapInfo.js
   ====================================================================== */

/**
 * eコミマップ情報
 * @requires SaigaiTask/Map.js
 */
SaigaiTask.Map.EcommapInfo = new OpenLayers.Class({

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * eコミのURL
	 */
	ecommapURL: null,

	/**
	 * WMSのURL
	 * 指定しなければ自動生成します.
	 * @type {String}
	 */
	wmsAuthURL: null,

	/**
	 * 登録情報レイヤのルートレイヤ情報.
	 */
	contentsLayerInfo: null,

	/**
	 * 登録情報レイヤのレイヤ情報配列.
	 * @type {Array<SaigaiTask.Map.LayerInfo>}
	 */
	contentsLayerInfos: null,

	/**
	 * レイヤIDをキーにしてレイヤ情報を保存します.
	 * @type {Object<String, SaigaiTask.Map.Layer.LayerInfo>}
	 */
	layerInfoStore: {},

	/**
	 * レイヤ情報をツリー構造で保存します.
	 */
	layerInfoTree: [],

	initialize: function(options) {
		var me = this;
		// オプションをコピー
		OpenLayers.Util.extend(this, options);
		var ecommap = this;
		// レイヤ情報ストアを作成
		var layerInfos = [].concat(
			ecommap.contentsLayers,
			ecommap.groupContentsLayers,
			ecommap.kmlLayers,
			ecommap.referenceLayers,
			ecommap.overlayLayers,
			ecommap.externalMapLayers,
			ecommap.baseLayers
		);
		ecommap.layerInfoStore = {};
		for(var key in layerInfos) {
			var layerInfo = layerInfos[key];
			if(typeof layerInfo=="undefined") continue;
			layerInfo.ecommap = ecommap;
			layerInfo = new SaigaiTask.Map.Layer.LayerInfo(layerInfo);
			ecommap.layerInfoStore[layerInfo.layerId] = layerInfo;
			switch(layerInfo.type) {
			case SaigaiTask.Map.Layer.Type.LOCAL:
				layerInfo.params.LAYERS = layerInfo.layerId;
				layerInfo.params.keys = layerInfo.authkey;
				break;
			case SaigaiTask.Map.Layer.Type.OVERLAY_WMS:
			case SaigaiTask.Map.Layer.Type.OVERLAY_WMS_SINGLE:
			case SaigaiTask.Map.Layer.Type.OVERLAY_TILED:
			case SaigaiTask.Map.Layer.Type.OVERLAY_TILECACHE:
			case SaigaiTask.Map.Layer.Type.OVERLAY_OSM:
				layerInfo.params.LAYERS = [layerInfo.featuretypeId];
				break;
			case SaigaiTask.Map.Layer.Type.REFERENCE_WMS:
			case SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS:
				layerInfo.params.LAYERS = [];
				break;
			case SaigaiTask.Map.Layer.Type.REFERENCE:
			case SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS_LAYERS:
			case SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_ARCGIS_LAYERS:
				layerInfo.params.LAYERS = layerInfo.featuretypeId;
				break;
			}
		}
		// 登録情報レイヤのレイヤ情報を作成
		var contentsLayerInfo = me.createContentsLayerInfo();
		// MapLayerInfoでレイヤの表示順を設定
		ecommap.layerInfoTree = [];
		ecommap.contentsLayerInfos = [];
		var mapLayerInfos = ecommap.mapInfo.MapLayerInfo;
		for(var mapLayerInfosIdx in mapLayerInfos) {
			var mapLayerInfo = mapLayerInfos[mapLayerInfosIdx];
			var layerId = mapLayerInfo.layerId;
			var layerInfo = ecommap.layerInfoStore[layerId];
			if(typeof layerInfo =="undefined") {
				continue;
			}
			layerInfo.opacity = mapLayerInfo.opacity;
			// layer_closedから値を取得する
			if(typeof layerInfo.expanded == null) {
				layerInfo.expanded = ! mapLayerInfo.closed;
			}
			if(!!mapLayerInfo.reload) layerInfo.reload = mapLayerInfo.reload;
			// 親レイヤIDを取得
			var parent = null;
			if(layerInfo.parent != null) {
				parent = layerInfo.parent;
				if(typeof parent=="object") {
					parent = parent.layerId;
				}
			}
			// 親がいれば親レイヤの下に追加
			var append = false;
			if(parent!=null) {
				var parentLayerInfo = ecommap.layerInfoStore[parent];
				if(typeof parentLayerInfo=="object") {
					parentLayerInfo.appendChildLayerInfo(layerInfo);
					append = true;
				}
			}
			// 親がいない場合
			if(append==false){
				// 登録情報の場合
				if(layerInfo.type==SaigaiTask.Map.Layer.Type.LOCAL||
					layerInfo.type==SaigaiTask.Map.Layer.Type.LOCAL_GROUP) {
					contentsLayerInfo.appendChildLayerInfo(layerInfo);
					ecommap.contentsLayerInfos.push(layerInfo);
				}
				else {
					// ルートノードをlayerInfoTreeに保存
					ecommap.layerInfoTree.push(layerInfo);
					console.log("add layerInfoTree "+layerInfo.name);
				}
			}
		}

		// 外部地図のレイヤ情報を作成
		if(typeof ecommap.externalMapLayers!="undefined") {
			for (var i  =  0; i < ecommap.externalMapLayers.length; i++) {
				layerInfo = ecommap.layerInfoStore[ecommap.externalMapLayers[i].layerId];
				// 親がいれば親レイヤの下に追加
				var append = false;
				if (layerInfo.parent != null) {
					var parent = ecommap.layerInfoStore[layerInfo.parent];
					if(typeof parent=="object") {
						parent.appendChildLayerInfo(layerInfo);
						//layerInfo.expanded = false;
						append = true;
					}
				}
				// 親がいない場合
				if(append==false) {
					// ルートノードをlayerInfoTreeに保存
					ecommap.layerInfoTree.push(layerInfo);
				}
			}
		}

		// 登録情報レイヤがあれば先頭に追加する
		if(0<contentsLayerInfo.children.length) {
			ecommap.layerInfoTree.unshift(contentsLayerInfo);
			me.contentsLayerInfo = contentsLayerInfo;
		}

		// 背景地図の初期表示設定
		var baselayerInfos = me.getBaseLayerInfos();
		if(0<baselayerInfos.length) {
			// 初期表示 true のものが存在するかチェック
			var exist = false;
			for(var idx in baselayerInfos) {
				var baselayerInfo = baselayerInfos[idx];
				if(baselayerInfo.visibility) {
					exist = true;
					break;
				}
			}
			// なければ最後のものを初期表示する
			if(exist==false) {
				baselayerInfos[baselayerInfos.length-1].visibility = true;
			}
		}
	},

	createContentsLayerInfo: function() {
		return new SaigaiTask.Map.Layer.LayerInfo({
			name: lang.__("Registration info"),
			wmsURL: this.wmsAuthURL,
			visibility: true,
			_olSalt: Math.random(), //キャッシュ不使用パラメータキー生成
			tiled: true,
			tilesOrigin: "0,0",
			params: {
				cid: this.mapInfo.communityId,
				mid: this.mapInfo.mapId,
				FORMAT: "image/png",
				TRANSPARENT: true,
				LAYERS: [],
				keys: []
			}
		});
	},

	isBaseLayerInfo: function(layerInfo) {
		return SaigaiTask.Map.Layer.Type.isBaseLayerType(layerInfo.type);
	},

	/**
	 * ベースレイヤのレイヤ情報を配列で取得します.
	 * @returns {Array<SaigaiTask.Map.Layer.LayerInfo>}
	 */
	getBaseLayerInfos: function() {
		var types = SaigaiTask.Map.Layer.Type.getBaseLayerTypes();
		return this.getLayerInfosByTypes(types);
	},

	getOverlayLayerInfos: function() {
		var types = SaigaiTask.Map.Layer.Type.getOverlayLayerTypes();
		return this.getLayerInfosByTypes(types);
	},

	getReferenceLayerTypes: function() {
		return [SaigaiTask.Map.Layer.Type.REFERENCE_WMS];
	},

	getReferenceLayerInfos: function() {
		var types = this.getReferenceLayerTypes();
		return this.getLayerInfosByTypes(types);
	},

	getExternalMapLayerTypes: function() {
		return [SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS, SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_XYZ];
	},

	getExternalMapLayerInfos: function() {
		var types = this.getExternalMapLayerTypes();
		return this.getLayerInfosByTypes(types);
	},

	getArcGISLayerInfos: function() {
		var types = SaigaiTask.Map.Layer.Type.getArcGISLayerTypes();
		return this.getLayerInfosByTypes(types);
	},

	/**
	 * レイヤ種別指定でレイヤ情報を配列で取得します.
	 * @param types レイヤ種別の配列
	 * @returns {Array<SaigaiTask.Map.Layer.LayerInfo>} レイヤ情報の配列
	 */
	getLayerInfosByTypes: function(types) {
		var layerInfos = [];
		// MapLayerInfo でソートする
		var ecommap = this;
		var mapLayerInfos = ecommap.mapInfo.MapLayerInfo;
		var checked = [];
		for(var mapLayerInfosIdx in mapLayerInfos) {
			var mapLayerInfo = mapLayerInfos[mapLayerInfosIdx];
			var layerId = mapLayerInfo.layerId;
			checked.push(layerId);
			var layerInfo = ecommap.layerInfoStore[layerId];
			if(typeof layerInfo =="undefined") {
				continue;
			}
			if($.inArray(layerInfo.type, types)!=-1) {
				layerInfos.push(layerInfo);
			}
		}
		// 外部地図などeコミに未登録レイヤの対応
		for(var layerId in ecommap.layerInfoStore) {
			if($.inArray(layerId, checked)!=-1) continue;
			var layerInfo = ecommap.layerInfoStore[layerId];
			if($.inArray(layerInfo.type, types)!=-1) {
				layerInfos.push(layerInfo);
			}
		}
		return layerInfos;
	},

	/**
	 * 非表示レイヤIDを配列で取得する
	 * @return {Array<String>} 非表示レイヤID配列
	 */
	getHiddenLayerIds: function() {
		var me = this;
		var tree = me.layerInfoTree;
		var hiddenLayerIds = [];
		for(var idx in tree) {
			var layerInfo = tree[idx];
			layerInfo.getHiddenLayerIds(hiddenLayerIds);
		}
		return hiddenLayerIds;
	},

	/**
	 * このeコミマップ情報を複製します.
	 */
	clone: function(stmap) {
		// eコミ情報をまるごとコピーする
		var ecommap = this;
		var copyWithFunc = $.extend(true, {}, ecommap);
		var options = {};
		for(var name in copyWithFunc) {
			var prop = copyWithFunc[name];
			// 関数以外をコピー
			if(typeof prop!="function") {
				options[name] = prop;
			}
		}

		// 地図オブジェクトを設定
		options.stmap = stmap;

		return new SaigaiTask.Map.EcommapInfo(options);
	},

	/**
	 * 空間検索範囲レイヤの検索条件を更新します.
	 * @param {Object} conditionValue
	 * @returns
	 */
	updateSpatialLayerCondition: function(conditionValue) {
		var me = this;
		var layerId = conditionValue.layerId;
		// レイヤ情報の取得
		var layerInfo = me.layerInfoStore[layerId];
		if(typeof layerInfo=="undefined" || layerInfo==null) {
			alert(lang.__("Retrieval object layer is not displayed."));
			return;
		}
		// 検索条件をレイヤ情報にコピー
		layerInfo.spatialLayers = conditionValue.spatiallayer;
		var spatialLayer = layerInfo.spatialLayer;
		if(typeof spatialLayer=="undefined" || spatialLayer==null) {
			// TODO: 範囲レイヤがなければ作成する
			//layerInfo.createSpatialLayer()
			alert(lang.__("There is no search range layer."));
			return;
		}
		// 検索範囲レイヤのパラメータを更新
		var spatialLayerInfo = spatialLayer.layerInfo;
		spatialLayerInfo.params.spatiallayers = JSON.stringify(layerInfo.spatialLayers);
		spatialLayer._refreshParams({
			nocache: true
		});

	},

	moveToHome: function() {
		var me = this;
		var ecommap = me;
		var stmap = me.stmap;

		var layoutInfo = ecommap.layoutInfo;
		var initExtent = null;
		if( layoutInfo ) {
			var e = layoutInfo.mapExtent;
			if(e){
				initExtent = new OpenLayers.Bounds(e[0],e[1],e[2],e[3]); // wsen
			}
		}
		if(initExtent==null) initExtent = new OpenLayers.Bounds(120.20,22.93,151.35,46.78);
		me.initExtent = initExtent;
		// 範囲で表示
		if(layoutInfo.mapResolution==0) {
			stmap.zoomToExtent(initExtent);
		}
		// 範囲よりも解像度で表示
		else {
			var initResolution = layoutInfo.mapResolution;
			var zoom = stmap.map.getZoomForResolution(stmap.toMapResolution(initResolution), stmap);
			stmap.setCenter(initExtent.getCenterLonLat(), zoom);
		}

		// 凡例別の表示切替のリセット処理
		var legendpanel = stmap.components.mainpanel.legend;
		for(var idx in me.contentsLayerInfos) {
			var contentsLayerInfo = me.contentsLayerInfos[idx];
			var legendrules = contentsLayerInfo.legendrules;
			if(!!legendrules) {
				for(var ruleIdx in legendrules) {
					var rule = legendrules[ruleIdx];
					var node = rule.node;
					if(!!node) {
						// 親のチェック状態でリセット
						var nodeChecked = node.get("checked");
						var parentChecked = node.parentNode.get("checked");
						if(nodeChecked!=parentChecked) {
							node.set("checked", parentChecked);
							legendpanel.tree.fireEvent("checkchange", node, parentChecked, {});
						}
					}
				}
			}
		}
	}
});
/* ======================================================================
    SaigaiTask/Map/Layer/WMSLayer.js
   ====================================================================== */

/**
 * WMSレイヤ
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 */
SaigaiTask.Map.Layer.WMSLayer = new OpenLayers.Class(OpenLayers.Layer.WMS, {

	/**
	 * レイヤ情報
	 * @type {SaigaiTask.Map.Layer.LayerInfo}
	 */
	layerInfo: null,

	params: null,

	/**
	 *
	 * @param {SaigaiTask.Map.Layer.LayerInfo} layerInfo レイヤ情報
	 */
	initialize: function(layerInfo) {

		// 引数を処理
		var me = this;
		me.layerInfo = layerInfo;

		// 表示するレイヤのvisibility初期化
		for(var childLayerInfoKey in layerInfo.children) {
			var childLayerInfo = layerInfo.children[childLayerInfoKey];
			if(typeof childLayerInfo.visibility=="undefined") {
				childLayerInfo.visibility = true;
			}
			childLayerInfo.parent = layerInfo;
		}

		// layerInfoからWMS初期化パラメータを生成
		var name = layerInfo.name;
		var url = layerInfo.wmsURL;
		var params = this.params = {
			TRANSPARENT: true
		};
		// ArcGISの表示でエラーになるのでコメントアウト（不要なはず）
		//if(layerInfo.featuretypeId!=null) {
		//	params.layers = layerInfo.featuretypeId;
		//}
		var options = {
			visibility: layerInfo.visibility,
			alpha: true,
			opacity: layerInfo.opacity,
			isBaseLayer: SaigaiTask.Map.Layer.Type.isBaseLayerType(layerInfo.type),
			attribution: layerInfo.attribution,
			transitionEffect: layerInfo.transitionEffect,
			singleTile: layerInfo.singleTile
		};
		if(layerInfo.ecommap!=null) {
			options.isBaseLayer = layerInfo.ecommap.isBaseLayerInfo(layerInfo);
		}

		// WMSレイヤの初期化
		OpenLayers.Layer.WMS.prototype.initialize.apply(this, [name, url, params, options]);
		me.refreshParams();

		layerInfo.layer = this;
	},

	/**
	 * WMSリクエストパラメータを再読み込みします.
	 * @param {Object} option
	 * @param {Boolean} option.nocache キャッシュ使用フラグ
	 */
	refreshParams: function(option) {
		var me = this;
		me._refreshParams(option);
		me.events.triggerEvent("refreshParams");
	},

	_refreshParams: function(option) {
		var defaultOption = {
			nocache: false
		};
		if(typeof option=="undefined") option = {};
		Ext.applyIf(option, defaultOption);

		// レイヤ情報からパラメータを作成し反映
		delete this.params.layertimes; // layertimes が残る場合があるので削除
		OpenLayers.Util.extend(this.params, this.getParams());
		// キャッシュを読み込まないように乱数を更新
		if(option.nocache) {
			this.params._olSalt = Math.random();
		}

		console.log("params "+this.layerInfo.name);
		console.log(this.params);

		// LAYERSが指定されていないとエラーになるためレイヤ自体を非表示にする
		if(typeof this.params.LAYERS=="undefined" ||
				this.params.LAYERS.length==0) {
			this.setVisibility(false);
		}
		else {
			this.setVisibility(this.layerInfo.visibility);
		}

		// 時間パラメータの付与
		var time = SaigaiTask.PageURL.getTime();
		if(!!time) {
			var iso8601Time = time.toISOString();
			// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
			if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
				iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
			}
			this.params.time = iso8601Time;
		}
		else {
			this.params.time = null;
		}

		console.log("visibility");
		console.log(this.getVisibility());

		console.log("opacity");
		console.log(this.opacity);

		console.log(this);

		this.redraw(true);
	},

	/**
	 * レイヤ情報からWMSリクエストパラメータを取得します.
	 * 子レイヤ情報のパラメータはカンマ区切りの文字列に変換します.
	 * @returns {Object} パラメータ
	 */
	getParams: function() {

		var params = $.extend(true, {}, this.layerInfo.params);

		var getParamsRecursive = function(params, layerInfo) {
			// 内部ノード
			if(0<layerInfo.children.length) {
				for(var key in layerInfo.children) {
					var child = layerInfo.children[key];
					getParamsRecursive(params, child);
				}
			}
			// 葉ノード
			else {
				/// param をコピー
				if(layerInfo.visibility) {
					layerInfo.mergeParams(params);
				}
			}
		};

		if(0<this.layerInfo.children.length) {
			getParamsRecursive(params, this.layerInfo);
		}

		// 整形
		for(var key in params) {
			var param = params[key];
			// 葉ノードの配列パラメータをCSV文字列に変換
			if($.isArray(param)) {
				params[key] = param.reverse().join(",");
			}
			// JSONオブジェクトをJSON文字列に変換
			else if(typeof param=="object") {
				params[key] = JSON.stringify(param);
			}
		}

		return params;
	},

	/**
	 * WMSのLAYERSパラメータを生成します.
	 * featuretypeIdが設定されていればそれを返します.
	 * childLayerInfoが設定されている場合はvisibilityがtrueのもののみ取得できます.
	 * @deprecated
	 * @returns {String} LAYERSパラメータ
	 */
	buildLayersParam: function() {
		var me = this;
		var info = me.layerInfo;
		// 表示するレイヤIDを取得する
		var layers = [];

		// featuretypeId が設定されているならそれを返す
		if(typeof info.featuretypeId !="undefined") {
			return info.featuretypeId;
		}

		// childLayerInfos が設定されているなら visibility をみて返す
		for(var childLayerInfoKey in info.childLayerInfos) {
			var childLayerInfo = info.childLayerInfos[childLayerInfoKey];
			if(childLayerInfo.visibility==true) {
				layers.push(childLayerInfo.featuretypeId);
			}
		}
		return layers.join(",");
	},

	//@Override
	getURL: function(bounds){
		var me = this;
		var info = me.layerInfo;

		var url = OpenLayers.Layer.WMS.prototype.getURL.call(this, bounds);

		if(info.wmsproxy != null){
			if (info.wmsproxy != 0 && url.indexOf("http") == 0) {
				var page_url = SaigaiTask.PageURL.getUrl();
				var metadataid = "";
				if(info.children.length > 0){
					metadataid = info.children[0].metadataid;
				}
				// Proxy用のActionに飛ばす
				url = page_url.substr(0, page_url.indexOf("/page/") + 6) + "map/externalWmsAuth/?url=" + encodeURIComponent(url) + "&externalmapdatainfoid="+info.wmsproxy + "&metadataid=" + metadataid;
			}
		}
		return url;
	},

	/**
	 * WMSのLAYERSのvisibilityを設定します.
	 * @deprecated
	 * @param {String} featuretypeId
	 * @param {Boolean} visibility
	 */
	setLayersParamVisibility: function(featuretypeId, visibility) {
		var me = this;
		var info = me.layerInfo;
		for(var childLayerInfoKey in info.childLayerInfos) {
			var childLayerInfo = info.childLayerInfos[childLayerInfoKey];
			// 指定フィーチャタイプIDならばvisibilityを設定
			if(childLayerInfo.featuretypeId == featuretypeId) {
				childLayerInfo.visibility = visibility;
				break;
			}
		}
	},
	CLASS_NAME: "SaigaiTask.Map.Layer.WMSLayer"
});
/* ======================================================================
    SaigaiTask/Map/Layer/ArcGIS93Rest.js
   ====================================================================== */

/**
 * ArcGISレイヤ
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 */
SaigaiTask.Map.Layer.ArcGIS93Rest = new OpenLayers.Class(OpenLayers.Layer.ArcGIS93Rest, {

	/**
	 * レイヤ情報
	 * @type {SaigaiTask.Map.Layer.LayerInfo}
	 */
	layerInfo: null,

	params: null,

	/**
	 *
	 * @param {SaigaiTask.Map.Layer.LayerInfo} layerInfo レイヤ情報
	 */
	initialize: function(layerInfo) {

		// 引数を処理
		var me = this;
		me.layerInfo = layerInfo;

		// 表示するレイヤのvisibility初期化
		for(var childLayerInfoKey in layerInfo.children) {
			var childLayerInfo = layerInfo.children[childLayerInfoKey];
			if(typeof childLayerInfo.visibility=="undefined") {
				childLayerInfo.visibility = true;
			}
			childLayerInfo.parent = layerInfo;
		}

		// layerInfoからWMS初期化パラメータを生成
		var name = layerInfo.name;
		var url = layerInfo.wmsCapabilitiesURL;
		var times = "";
		// timeプロパティを取得
		if( url != null && url.indexOf("time=") != -1 ){
			// time=以降の文字列にする
			var time_param1 = url.substring(url.indexOf("time=")+5, url.length);
			var sep_int = time_param1.indexOf("&");
			times = sep_int == -1 ? time_param1 : time_param1.substring(0, sep_int);
			url = url.replace("me.times", "");
		}

		var params = this.params = {
			TRANSPARENT: true
		};
		if(layerInfo.featuretypeId!=null) {
			params.layers = layerInfo.featuretypeId;
		}
		var options = {
			isBaseLayer: SaigaiTask.Map.Layer.Type.isBaseLayerType(layerInfo.type),
			time: times
		};
		//time: "1419141600000%2C1420629592000" time: encodeURIComponent(times)
		if(layerInfo.ecommap!=null) {
			options.isBaseLayer = layerInfo.ecommap.isBaseLayerInfo(layerInfo);
		}

		// WMSレイヤの初期化
		OpenLayers.Layer.ArcGIS93Rest.prototype.initialize.apply(this, [name, url, params, options]);
		me.refreshParams();

		layerInfo.layer = this;
	},

	/**
	 * WMSリクエストパラメータを再読み込みします.
	 * @param {Object} option
	 * @param {Boolean} option.nocache キャッシュ使用フラグ
	 */
	refreshParams: function(option) {
		var me = this;
		me._refreshParams(option);
		me.events.triggerEvent("refreshParams");
	},

	_refreshParams: function(option) {
		var defaultOption = {
			nocache: false
		};
		if(typeof option=="undefined") option = {};
		Ext.applyIf(option, defaultOption);

		// レイヤ情報からパラメータを作成し反映
		OpenLayers.Util.extend(this.params, this.getParams());
		// キャッシュを読み込まないように乱数を更新
		if(option.nocache) {
			this.params._olSalt = Math.random();
		}

		console.log("params "+this.layerInfo.name);
		console.log(this.params);
		this.setVisibility(this.layerInfo.visibility);
/*
		// LAYERSが指定されていないとエラーになるためレイヤ自体を非表示にする
		if(typeof this.params.LAYERS=="undefined" ||
				this.params.LAYERS.length==0) {
			this.setVisibility(false);
		}
		else {
			this.setVisibility(this.layerInfo.visibility);
		}
*/
		console.log("visibility");
		console.log(this.getVisibility());

		console.log("opacity");
		console.log(this.opacity);

		console.log(this);

		this.redraw(true);
	},

	/**
	 * レイヤ情報からWMSリクエストパラメータを取得します.
	 * 子レイヤ情報のパラメータはカンマ区切りの文字列に変換します.
	 * @returns {Object} パラメータ
	 */
	getParams: function() {

		var params = $.extend(true, {}, this.layerInfo.params);

		var getParamsRecursive = function(params, layerInfo) {
			// 内部ノード
			if(0<layerInfo.children.length) {
				for(var key in layerInfo.children) {
					var child = layerInfo.children[key];
					getParamsRecursive(params, child);
				}
			}
			// 葉ノード
			else {
				/// param をコピー
				if(layerInfo.visibility) {
					layerInfo.mergeParams(params);
				}
			}
		};

		if(0<this.layerInfo.children.length) {
			getParamsRecursive(params, this.layerInfo);
		}

		// 整形
		for(var key in params) {
			var param = params[key];
			// 葉ノードの配列パラメータをCSV文字列に変換
			if($.isArray(param)) {
				params[key] = param.reverse().join(",");
			}
			// JSONオブジェクトをJSON文字列に変換
			else if(typeof param=="object") {
				params[key] = JSON.stringify(param);
			}
		}

		return params;
	},

	/**
	 * WMSのLAYERSパラメータを生成します.
	 * featuretypeIdが設定されていればそれを返します.
	 * childLayerInfoが設定されている場合はvisibilityがtrueのもののみ取得できます.
	 * @deprecated
	 * @returns {String} LAYERSパラメータ
	 */
	buildLayersParam: function() {
		var me = this;
		var info = me.layerInfo;
		// 表示するレイヤIDを取得する
		var layers = [];

		// featuretypeId が設定されているならそれを返す
		if(typeof info.featuretypeId !="undefined") {
			return info.featuretypeId;
		}

		// childLayerInfos が設定されているなら visibility をみて返す
		for(var childLayerInfoKey in info.childLayerInfos) {
			var childLayerInfo = info.childLayerInfos[childLayerInfoKey];
			if(childLayerInfo.visibility==true) {
				layers.push(childLayerInfo.featuretypeId);
			}
		}
		return layers.join(",");
	},

	/**
	 * WMSのLAYERSのvisibilityを設定します.
	 * @deprecated
	 * @param {String} featuretypeId
	 * @param {Boolean} visibility
	 */
	setLayersParamVisibility: function(featuretypeId, visibility) {
		var me = this;
		var info = me.layerInfo;
		for(var childLayerInfoKey in info.childLayerInfos) {
			var childLayerInfo = info.childLayerInfos[childLayerInfoKey];
			// 指定フィーチャタイプIDならばvisibilityを設定
			if(childLayerInfo.featuretypeId == featuretypeId) {
				childLayerInfo.visibility = visibility;
				break;
			}
		}
	}
});
SaigaiTask.Map.Layer.ArcGIS93Rest.type = SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_ARCGIS_LAYERS;
/* ======================================================================
    SaigaiTask/Map/Layer/DrawLayerSelectDrag.js
   ====================================================================== */

/**
 * 描画レイヤ（地物選択関係）
 * @see ecommap : webapps/map/map/widgets/memo/memo.js
 * @requires SaigaiTask/Map/Layer.js
 */
SaigaiTask.Map.Layer.DrawLayerSelectDrag = new OpenLayers.Class({

	/** 追加時の形状ID 点 */
	POINT : 10,
	/** 追加時の形状ID 線 */
	LINESTRING : 20,
	/** 追加時の形状ID 面 */
	POLYGON : 30,
	/** 追加時の形状ID 文字 */
	TEXT : 40,
	/** 追加時の形状ID 画像 */
	PHOTO : 60,
	/** 追加時の形状ID フォルダ（未使用） */
	GROUP : 100,

	initialize: function(memoLayer) {
		var me = this;
		var stmap = me.stmap;

		//<span class="ja">選択用レイヤ</span><span class="en">Layer for selection</span>
		this.memoSelectLayer = new OpenLayers.Layer.Markers('memoSelect');
		this.stmap.map.addLayer(this.memoSelectLayer);
		this.selectIcon = new OpenLayers.Icon(stmap.icon.getURL("pointnodeIconURL"), new OpenLayers.Size(9,9), new OpenLayers.Pixel(-5,-5));
		this.memoLayer = memoLayer;
		this.eMap = {
			map: this.stmap.map,
			getLabelSize: OpenLayers.Format.KMLStyleUtil.getLabelSize,
			isFocus: this.stmap.isFocus
		}

		//<span class="ja">初期状態の色設定 ボタンの色も変更される</span><span class="en">Set color for initialization    Also change the buttons' color</span>
		//this.setFontColor("#0000FF");
		//this.setDrawColor("#0000FF");
		//this.setFillColor("#FFFFFF");
		//this.setIcon('widgets/memo/icons/pin01.png',31,48,-15,-48);
		this.setFontSize(14);

		//<span class="ja">編集時のスタイル defaultは新規作成時のフォームと合わせる</span><span class="en">Style when editing   In default, comply with the form when creating new </span>
		var modifyStyleMap = me.modifyStyleMap = new OpenLayers.StyleMap();
		modifyStyleMap.styles['default'] = new OpenLayers.Style({
			fillColor:"#0000FF", fillOpacity:0.4,
			hoverFillColor:"#FFFFFF", hoverFillOpacity:0.8,
			strokeColor:"#0000FF", strokeOpacity:1, strokeWidth:2,// strokeLinecap:"round",strokeDashstyle:"dash",
			graphicOpacity:1, 
			graphicZIndex: 0,
			//externalGraphic:"icons/default.png", graphicWidth:20, graphicHeight:40, graphicXOffset:-10, graphicYOffset:-20,
			//externalGraphic:"icons/pointnode.png", graphicWidth:9, graphicHeight:9, graphicXOffset:-5, graphicYOffset:-5,
			//hoverPointRadius:1, hoverPointUnit: "%",
			//pointerEvents:"visiblePainted",
			fontColor:"#0000FF", fontWeight:"bold", fontSize:memoLayer.styleMap.styles.default.defaultStyle.fontSize, labelAlign:"lt",
			cursor:"pointer"
		});

		var selectDragFeature = me.controls.selectDragFeature;
		selectDragFeature.events.on({
			"deactivate": function() {
				// 選択を無効にしたら、選択マーカをクリアする
				me.clearFeatureSelection();
			}
		});
		// 地図を移動・拡縮したら、テキスト編集を終了する
		stmap.map.events.on({
			"moveend": function() {
				if(selectDragFeature.active) {
					$(".memo_text_div textarea").blur();
				}
			}
		})
		

		me.layer.events.on({
			"historychange": function(option) {
				if(option.operation=="undo"
					|| option.operation=="redo" ) {
					// undo/redo時に選択マーカをクリアする
					me.clearFeatureSelection();

					// 選択コントロールが有効な場合、選択中にする
					if(me.activeDrawKey=="selectDragFeature") {
						me.getSelectDragFeatureControl().select(option.feature);

						// undo/redo時に選択マーカをリセットする
						me.resetFeatureSelection(me.memoLayer);
					}
					
				}
			}
		});
	},
	
	////////////////////////////////////////////////////////////////
	//	<span class="ja">選択</span><span class="en">Selection</span>
	////////////////////////////////////////////////////////////////
	isSelected : function(feature)
	{
		var sf = this.memoLayer.selectedFeatures;
		for (var i=sf.length-1; i>=0; i--) {
			if (sf[i] == feature) return true;
		}
		return false;
	},
	/** <span class="ja">SelectFeatureを使わずに選択状態にする</span><span class="en">Set Selection state without using SelectFeature </span> */
	selectFeature : function(feature)
	{
		this.memoLayer.selectedFeatures.push(feature);
		this._featureSelected(feature);
	},
	
	/** <span class="ja">Featureが選択されたときのスタイルを変更 <br/> 複数選択時は一つづつ呼ばれる</span><span class="en">Change the styles used when Features are selected</span> */
	clearFeatureSelection : function()
	{
		this.memoSelectLayer.clearMarkers();
		this.memoLayer.selectedFeatures = [];
	},
	
	/** 選択マーカーをリセット
	 * @param layer {OpenLayers.Layer.Vector} 選択している図形のあるレイヤ */
	resetFeatureSelection : function(layer)
	{
		var selected = layer.selectedFeatures;
		if (selected) {
			for (var i=selected.length-1; i>=0; i--) {
				this._featureUnselected(selected[i]);
				this._featureSelected(selected[i]);
			}
		}
	},
	
	/** SelectFeatureControlから呼ばれる
	 * Featureが選択されたときに選択ノードのマーカー表示
	 * 図形の場合も外説矩形にマーカー表示
	 * 複数選択時はfeatureごとに呼ばれる
	 * @param feature 選択されたFeature */
	_featureSelected : function(feature, noControl)
	{
		try {
			
			// フォーカスを外す
			// ※メモ描画でテキストメモ編集モードのテキストエリアを閉じるために必要
			// 　@see src/main/webapp/js/SaigaiTaskJS/lib/SaigaiTask/Map/Layer/DrawLayerSelectDrag.js _startTextEdit
			if(!!document.activeElement && !!document.activeElement.blur) document.activeElement.blur();
			
			if (feature.geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
				var vartices = feature.geometry.getVertices();
				for (var i=0; i<vartices.length; i++) {
					this._addSelectMarker(this.dragMarker, feature, new OpenLayers.LonLat(vartices[i].x, vartices[i].y), this.selectIcon.clone(), 'move');
				}
			} else {
				//外接矩形の4点のノード
				var bounds = feature.geometry.getBounds();
				this._addSelectMarker(this.dragMarker, feature, new OpenLayers.LonLat(bounds.left, bounds.top), this.selectIcon.clone()/*, 'nw-resize'*/);
				this._addSelectMarker(this.dragMarker, feature, new OpenLayers.LonLat(bounds.right, bounds.top), this.selectIcon.clone()/*, 'ne-resize'*/);
				this._addSelectMarker(this.dragMarker, feature, new OpenLayers.LonLat(bounds.left, bounds.bottom), this.selectIcon.clone()/*, 'sw-resize'*/);
				this._addSelectMarker(this.dragMarker, feature, new OpenLayers.LonLat(bounds.right, bounds.bottom), this.selectIcon.clone()/*, 'se-resize'*/);
			}
			//選択ノードを前面に表示させる Vector側に追加すると下になるため毎回実行
			//this.eMap.map.resetLayersZIndex();
			this.memoSelectLayer.setZIndex(726);
			
		} catch (e) { console.error(e); }
	},
	/** Featureの選択が解除されたときのスタイルを変更
	 * 複数選択時はfeatureごとに呼ばれる
	 * @param feature 選択解除されたFeature */
	_featureUnselected : function(feature, noControl)
	{
		if (this.dragMarker) this.dragMarker.deactivate();
		var markers = this.memoSelectLayer.markers;
		for (var i=markers.length-1; i>=0; i--) {
			if (markers[i].linkid == feature.id) {
				this.memoSelectLayer.removeMarker(markers[i]);
			}
		}
	},
	/** 選択マーカーを追加.
	 * マーカーのドラッグイベントもここで定義
	 * @param feature 選択されているFeature マーカーの linkidにfeature.idを格納
	 * @param lonlat マーカーの座標（メルカトルならメートル）
	 * @param icon マーカーに表示するアイコン cloneして別のimgDivにしておく
	 * @param cursor マーカー上のカーソル形状 */
	_addSelectMarker : function(control, feature, lonlat, icon, cursor)
	{
		icon.imageDiv.style.cursor = cursor;
		var marker = new OpenLayers.Marker(lonlat, icon);
		marker.linkid = feature.id;
		this.memoSelectLayer.addMarker(marker);
		//FIXME DragMarker.jsでaddMarker()に連動して設定できるようにする
		var self = this;
		if (control) {
			marker.events.register("mouseover", marker, function(){ control.overFeature(this); });
			marker.events.register("mouseout", marker, function(){ control.outFeature(this); });
			if (this.isText(feature)) marker.events.register("dblclick", marker, function(){ self._startTextEdit(feature, true); });
		}
	},
	
	/** 選択ノードドラッグ開始
	 * @parama marker ドラッグ開始されたマーカー*/
	_nodeDragStart : function(marker, layer)
	{
		if (!marker) return;
		var feature = layer.getFeatureById(marker.linkid);
		try {
		this.resizeOrigin = null;
		//外枠取得
		var bounds = feature.geometry.getBounds();
		//始点取得
		var isLeft = Math.abs(bounds.left-marker.lonlat.lon) > Math.abs(bounds.right-marker.lonlat.lon);
		var isBottom = Math.abs(bounds.bottom-marker.lonlat.lat) > Math.abs(bounds.top-marker.lonlat.lat);
		this.resizeOrigin = new OpenLayers.Geometry.Point(
			isLeft ? bounds.left : bounds.right, isBottom ? bounds.bottom : bounds.top
		);
		//Point内の変数に移動前のlonlat格納
		this.resizeOrigin.prevLon = marker.lonlat.lon;
		this.resizeOrigin.prevLat = marker.lonlat.lat;
		this.resizeOrigin.isPoint = feature.geometry.CLASS_NAME == "OpenLayers.Geometry.Point" || this.isText(feature);
		
		//選択解除と他のノードの非表示
		var markers = this.memoSelectLayer.markers;
		for (var i=markers.length-1; i>=0; i--) {
			if (markers[i] != marker) {
				this.memoSelectLayer.removeMarker(markers[i]);
			}
		}
		this.memoLayer.selectedFeatures = [feature];
		
		} catch (e) { console.error(e); }
	},
	/** 選択ノードドラッグ
	 * @parama marker ドラッグ中のマーカー*/
	_nodeDrag : function(marker, layer)
	{
		if (this.resizeOrigin) {
			var lonlat = marker.lonlat;
			var feature = layer.getFeatureById(marker.linkid);
			if (this.resizeOrigin.isPoint) {
				var geometry = feature.geometry;
				feature.geometry.move(lonlat.lon-geometry.x, lonlat.lat-geometry.y);
				layer.drawFeature(feature);
			} else {
				this.resizeFeature(feature, this.resizeOrigin, lonlat, layer);
			}
		}
	},
	/** 選択ノードドラッグ完了
	 * @parama marker ドラッグ完了したマーカー*/
	_nodeDragComplete : function(marker, layer)
	{
		try {
		if (this.resizeOrigin) {
			this.resizeOrigin = null;
			var feature = layer.getFeatureById(marker.linkid);
			this._featureUnselected(feature);
			this._featureSelected(feature);
			
			//図形更新情報設定
			this._featureModified(feature);
		}
		} catch (e) { console.error(e); }
	},
	/** 開始点と終了店の外接矩形内にfeatureをリサイズ
	 * @param feature リサイズするFeature
	 * @param originGeometry ドラッグ開始時の地図座標範囲 前回のリサイズ時のマウス位置も記録する
	 * @param lonlat マウス位置の地図座標 */
	resizeFeature : function(feature, originGeometry, lonlat, layer)
	{
		try {
			var geometry = feature.geometry;
			var dx0 = originGeometry.prevLon - originGeometry.x;
			var dy0 = originGeometry.prevLat - originGeometry.y;
			var dx1 = lonlat.lon - originGeometry.x;
			var dy1 = lonlat.lat - originGeometry.y;
			if (dx0 == 0 || dy0 == 0 || dx1 == 0 || dy1 == 0) return;
			originGeometry.prevLon = lonlat.lon;
			originGeometry.prevLat = lonlat.lat;
			var scale = dy1 / dy0;
			var ratio = (dx1 / dx0) / scale;
			//console.log(dx1+" , "+dy1+" , "+dx0+" , "+dy0+" , "+scale+" , "+ratio);
			geometry.resize(scale, originGeometry, ratio);
			layer.drawFeature(feature);
			//Point内の変数に移動前のlonlat格納
		} catch (e) { console.error(e); }
	},
	
	/** 地図画面上でキーが押された時の処理
	 * 選択Featureの移動と削除 */
	_onKeyDown : function(evt)
	{
		var offset = 4 * this.memoLayer.getResolution();
		switch (evt.keyCode) {
		case dojo.keys.LEFT_ARROW:
			this.moveSelectedFeature(-offset, 0); break;
		case dojo.keys.DOWN_ARROW:
			this.moveSelectedFeature(0, -offset); break;
		case dojo.keys.RIGHT_ARROW:
			this.moveSelectedFeature(offset, 0); break;
		case dojo.keys.UP_ARROW:
			this.moveSelectedFeature(0, offset); break;
		case dojo.keys.DELETE:
			//削除 コントロールでマウス下のFeatureもクリア
			this.removeSelectedFeature();
			break;
		}
		//var control = this.controls[this.editMode];
		//if (control.outFeatureByKey) control.outFeatureByKey();
	},
	
	/** 選択されているFeatureを移動
	 * @param xOffset 横移動量 マイナスが左
	 * @param yOffset 縦移動量 マイナスが上 */
	moveSelectedFeature : function(xOffset, yOffset)
	{
		var me = this;
		var selected = this.memoLayer.selectedFeatures;
		for (var i=selected.length-1; i>=0; i--) {
			var feature = selected[i];
			var geometry = feature.geometry;
			if (geometry) {
				var beforeFeature = me.cloneTextFeature(feature);
				
				geometry.move(xOffset, yOffset);
				this.memoLayer.drawFeature(feature);
				this._featureUnselected(feature);
				this._featureSelected(feature);
				
				
				// 地物の移動イベントをトリガーする
				var event = {
					type: "featuremoved",
					feature: feature,
					afterFeature: me.cloneTextFeature(feature),
					beforeFeature: beforeFeature
				};
				me.layer.events.triggerEvent(event.type, event);
			}
		}
	},

	/** <span class="ja">凡例と地図からFeature削除</span><span class="en">Delete Feature from legend and map</span>
	 * @return 選択済が無い場合はtrue */
	removeSelectedFeature : function(force)
	{
		try {
			if(typeof force=="undefined") force=false;
			var features = this.memoLayer.selectedFeatures;
			//console.log(features);
			if (features.length == 0) return true;
			
			if (force==false && !confirm(lang.__('Delete selected note?'))) {
				return;
			}

			/*
			//<span class="ja">変形中</span><span class="en">Changing shape</span>
			if (features.length == 1) {
				switch (this.editMode) {
				case 'MODIFY':
				case 'RESIZE':
				case 'ROTATE':
					this.controls[this.editMode].unselectFeature(features[0]);
					break;
				}
			}
			*/
			this.clearFeatureSelection();
			this.memoLayer.removeFeatures(features);

			/*
			//<span class="ja">リスト更新</span><span class="en">Update list</span>
			if (this.dataGrid) this.showList();
			*/
			
			} catch (e) { console.error(e); }
	},

	////////////////////////////////////////////////////////////////
	//	<span class="ja">メモ編集モード</span><span class="en">Memo editing mode</span>
	preExButton : null,
	
	/**
	 * @param mode {String} <span class="ja">mode文字列 nullならすべて無効</span><span class="en">"mode" string  If null, disable all</span>
	 * @param mode style 追加指定ボタンでのスタイル指定
	 * @param mode exButton 追加指定ボタン トグル制御用
	 * */
	changeEditControl : function(mode, style, exButton)
	{
		var me = this;
		if(mode=="SELECT") {
			me.setSelectDragFeatureControlActivation(true);
			// テキスト入力モードでは、地図クリック時にポップアップを出さないようにする
			me.stmap.clickHandler.deactivate();
			// 遅延させて地図クリックを有効に戻す
			// ※遅延させないと、このクリックイベントも拾われてしまうため
			setTimeout(function() {
				me.stmap.clickHandler.activate();
			}, 500);		
		}
		/*
		//<span class="ja">同じなら何もしない</span><span class="en">Do nothing if modes are the same</span>
		if ((this.editMode == mode || !exButton) && exButton && this.preExButton == exButton) {
			//this.editMode = null;
			return;
		}
		
		try {
		//スタイル指定
		if (style) {
			if (style.icon) this.setIcon(style.icon, style.size[0], style.size[1], style.size[2], style.size[3]);
			if (style.width) this.setLineWidth(style.width);
			if (style.color) this.setDrawColor(style.color);
			if (style.fill) this.setFillColor(style.fill);
			if (style.opacity) this.setFillOpacity(style.opacity);
			if (style.fontcolor) this.setFontColor(style.fontcolor);
			if (style.fontsize) this.setFontSize(style.fontsize);
		}
		
		//<span class="ja">選択削除</span><span class="en">Clear the selection</span>
		if ((this.editMode=='SELECT' || this.editMode=='SELECTBOX') && (mode == 'SELECT' || mode == 'SELECTBOX')) {
		} else {
			this.clearFeatureSelection();
		}
		
		for(key in this.controls) {
			this.controls[key].deactivate();
			
			var button = this.modeButtons[key];
			if (button) button.domNode.className = "toggle_button";
		}
		if (this.preExButton) {
			this.preExButton.domNode.className = "toggle_button";
			this.preExButton = null;
		}
		
		this.editMode = mode;
		
		if (mode && this.controls[mode]) {
			this.controls[mode].activate();
			
			if (exButton) {
				exButton.domNode.className = "toggle_button toggled";
				this.preExButton = exButton;
			}
			else this.modeButtons[mode].domNode.className = "toggle_button toggled";
			
			//<span class="ja">モードに応じたスタイルに変更</span><span class="en">Change the styles which are suitable to the mode</span>
			
			var defaultStyle = this.memoLayer.styleMap.styles['default'].defaultStyle;
			
			switch (mode) {
			case 'SELECT':
			case 'REMOVE':
				//this.setStyleGraphic(defaultStyle, "icons/pointnode.png", 9, 9, -5, -5);
				break;
			case 'LINE':
			case 'POLYGON':
			case 'MODIFY':
			case 'PHOTO':
				this.setStyleGraphic(defaultStyle, "icons/pointnode.png", 9, 9, -5, -5, 1);
				break;
			case 'RESIZE':
				this.setStyleGraphic(defaultStyle, "icons/resize.png", 24, 24, -12, -12, 1);
				break;
			case 'ROTATE':
				this.setStyleGraphic(defaultStyle, "icons/rotate.png", 24, 24, -12, -12, 1);
				break;
			}
			
			//<span class="ja">メモレイヤが非表示なら表示する</span><span class="en">If the memo layer is invisible, display it</span>
			dijit.byId("memoVisible").set('checked',true);
			
		}
		} catch (e) { console.error(e); }
		*/
	},
	/** <span class="ja">OpenLayers.Feature.Vectorのスタイルのgraphicを設定（コード短縮用）</span><span class="en">Set graphic of the OpenLayers.Feature.Vector's style (to reduce code)</span>
	 * @pram style <span class="ja">Graphicを設定するOpenLayers.Feature.Vectorのスタイル</span><span class="en">OpenLayers.Feature.Vector's style which sets the Graphic</span> */
	setStyleGraphic : function(style, externalGraphic, graphicWidth, graphicHeight, graphicXOffset, graphicYOffset, graphicOpacity)
	{
		style.externalGraphic = externalGraphic;
		style.graphicWidth = graphicWidth;
		style.graphicHeight = graphicHeight;
		style.graphicXOffset = graphicXOffset;
		style.graphicYOffset = graphicYOffset;
		if (graphicOpacity) style.graphicOpacity = graphicOpacity;
	},
	
	/** <span class="ja">メモの形状名称を返却</span><span class="en">Return geometry name of the memo</span> */
	getGeomName : function(feature)
	{
		var geom = feature.geometry;
		if (!geom) return lang._('Nothing');
		if (geom.CLASS_NAME.match(/Point$/)) {
			if (this.isText(feature)) return lang._('Font');
			return lang._('Point<!--2-->');
		}
		if (geom.CLASS_NAME.match(/LineString$/)) return lang._('Line');
		if (geom.CLASS_NAME.match(/Polygon$/)) return lang._('Polygon');
	},
	
	////////////////////////////////////////////////////////////////
	//	<span class="ja">テキスト編集</span><span class="en">Edit text</span>
	////////////////////////////////////////////////////////////////
	isText : function(feature)
	{
		return feature.style.fontColor && feature.style.label;
	},
	checkTextEdit : function(feature)
	{
		if (this.isText(feature)) {
			if (this.isSelected(feature)) this._startTextEdit(feature, true); 
		}
	},
	/** テキスト編集を終了しないフラグ */
	_textNoClose : false,
	_startTextEdit : function(feature, modified)
	{
		var me = this;
		try {
		//<span class="ja">追加時はモード変更</span><span class="en">Change mode when inserting</span>
		if (!modified) this.changeEditControl('SELECT');
		
		var self = this;
		
		var parentDiv = this.eMap.map.div.parentNode;
		var px = this.eMap.map.getViewPortPxFromLonLat(new OpenLayers.LonLat(feature.geometry.x, feature.geometry.y));
		
		var div = dojo.create("div", {className:"memo_text_div"});
		div.style.left = px.x+"px";
		div.style.top = px.y+"px";
		
		//文字サイズ連動設定を取得
		var textFixed = false;
		if (feature.attributes && feature.attributes.description) {
			try {
				var option = dojo.fromJson(feature.attributes.description);
				if (option.reso) textFixed = true;
				// デバッグ用ログ出力
				if (option.reso) console.log("reso: "+option.reso+", zoom:"+me.stmap.map.getZoomForResolution(option.reso));
			} catch (e) {}
		}
		
		//<span class="ja">テキストエリア追加</span><span class="en">Insert textarea element</span>
		var textarea = this.textarea = me.createExtTextArea({
			rows: 1,
			cols: 10,
			trim: true,
			value: modified ? feature.attributes.name.replace(/\\n/g, "\n") : null,
			div: div
		});
		var textChk = document.createElement("input"); textChk.type="checkbox"; textChk.checked=textFixed;// new dijit.form.CheckBox({checked:textFixed});
		var label = dojo.create("label", {style:"background-color:white; cursor:pointer;"});
		var labelDiv = dojo.create("div");
		var span = dojo.create("span",{innerHTML:lang.__("Resize with map scale"), style:"padding:0 2px;"});
		label.appendChild(textChk);
		label.appendChild(span);
		labelDiv.appendChild(label);
		div.appendChild(labelDiv);
		//クリックで閉じないようにフラグを立てる
		span.onmouseover = function(){ self._textNoClose = true; };
		textChk.onmouseover = span.onmouseover;
		span.onmouseout = function(){ self._textNoClose = false; textarea.focus(); };
		textChk.onmouseout = span.onmouseout;
		// 縮尺更新のチェックボックスを追加
		if(modified && textFixed) {
			var updateChk = document.createElement("input"); updateChk.type="checkbox"; updateChk.checked=false;
			var updateLabel = dojo.create("label", {style:"background-color:white; cursor:pointer;"});
			var updateLabelDiv = dojo.create("div");
			var updateSpan = dojo.create("span",{innerHTML:lang.__("Update scale"), style:"padding:0 2px;"});
			var s=document.createElement("span"); s.innerHTML="("; updateLabel.appendChild(s);
			updateLabel.appendChild(updateSpan);
			updateLabel.appendChild(updateChk);
			var s=document.createElement("span"); s.innerHTML=")"; updateLabel.appendChild(s);
			labelDiv.appendChild(updateLabel);
			div.appendChild(updateLabelDiv);
			updateChk.onmouseover = span.onmouseover;
			updateChk.onmouseout = span.onmouseout;
			updateSpan.onmouseover = span.onmouseover;
			updateSpan.onmouseout = span.onmouseout;
		}
		
		//テキストからフォーカスが外れたら編集終了
		textarea.onblur = function(){ if (self._textNoClose) return; self._endTextEdit(div, textarea, textChk, feature, modified, updateChk); };
		
		parentDiv.appendChild(div);
		textarea.focus();
		
		} catch (e) { console.error(e); }
	},
	_endTextEdit : function(div, textarea, textChk, feature, modified, updateChk)
	{
		var me = this;
		var beforeFeature = me.cloneTextFeature(feature);

		try {
		var parentDiv = this.eMap.map.div.parentNode;
		var label = textarea.value;
		var textFixed = textChk.checked;
		var textFixedUpdate = !!updateChk ? (updateChk.checked||!textFixed) : true;
		//textarea.destroy();
		//textChk.destroy();
		parentDiv.removeChild(div);
		
		//<span class="ja">空文字なら削除して終了</span><span class="en">Delete the spaces and finish</span>
		if (!label || dojo.trim(label) == "") {
			this.clearFeatureSelection();
			this.memoLayer.removeFeatures(feature);
			return;
		}
		
		feature.attributes.name = label;
		if (modified) {
			this.memoLayer.eraseFeatures([feature]);
			this._featureModified(feature);
			//<span class="ja">改行がXMLでは消えるので "\\n" に変更</span><span class="en">Because the breakline characters in XML are ignored, convert them to "\\n"</span>
			feature.attributes.name = feature.attributes.name.replace(/\n/g, "\\n");
			//<span class="ja">選択用の背景</span><span class="en">Background of the selection</span>
			this.setLabelBackground(feature);
			feature.style.label = feature.attributes.name;
			this.memoLayer.drawFeature(feature);
		}
		else {
			//<span class="ja">追加前に選択削除</span><span class="en">Remove the selection before inserting</span>
			this._featureAdded(this.TEXT, feature);
		}
		
		//連動設定
		if(textFixedUpdate) {
			this.setTextZoomOption(feature.attributes, false, !textFixed);
		}
		
		} catch (e) { console.error(e); }
		
		var afterFeature = me.cloneTextFeature(feature);

		if(me.isTextChanged(beforeFeature, afterFeature)) {
			// 地物の移動イベントをトリガーする
			var event = {
				type: "featuremoved",
				feature: feature,
				afterFeature: afterFeature,
				beforeFeature: beforeFeature
			};
			me.layer.events.triggerEvent(event.type, event);
		}

		// 再描画
		me.layer.redraw();
	},
	
	isTextChanged: function(feature1, feature2) {
		var getTextFixed = function(feature) {
			//文字サイズ連動設定を取得
			var textFixed = false;
			if (feature.attributes && feature.attributes.description) {
				try {
					var option = dojo.fromJson(feature.attributes.description);
					if (option.reso) textFixed = option.reso;
				} catch (e) {}
			}
			return textFixed;
		};
		var getTextLabel = function(feature) {
			var label = null;
			if (feature.attributes && feature.attributes.name) {
				label = feature.attributes.name;
			}
			return label;
		};
		if(getTextLabel(feature1)!=getTextLabel(feature2)) return true;
		if(getTextFixed(feature1)!=getTextFixed(feature2)) return true;
		return false;
	},

	cloneTextFeature: function(feature) {
		var clone = null;
		if(!!feature) {
			clone = feature.clone();
			// copy data
			clone.data = {};
			for(var key in feature.data) {
				clone.data[key] = feature.data[key];
			}
			// copy style
			clone.style = {};
			for(var key in feature.style) {
				clone.style[key] = feature.style[key];
			}
		}
		return clone;
	},
	createExtTextArea: function(option) {
		/*
		var textarea = document.createElement("textarea");
		if(option.value!=null) textarea.value = option.value;
		option.div.append(textarea);
		*/
		var exTextarea = Ext.create("Ext.form.field.TextArea", {
			//grow: true, // automatically grow and shrink to its content
			//rows: option.rows,
			//cols: option.cols,
			//resizable: true,
			renderTo: option.div,
			value: option.value
		});
		var textarea = exTextarea.inputEl.dom;
		var basic = Ext.create('Ext.create', 'Ext.resizer.Resizer', {
	        target: exTextarea.inputEl,
	        width: 200,
	        height: 100,
	        minWidth:50,
	        minHeight:20
		});
		
		return textarea;
	},
	
	setLabelBackground : function(feature)
	{
		var fontSize = parseInt(feature.style.fontSize);
		if (!fontSize) try { feature.style.fontSize.replace(/px$/,""); } catch (e) {};
		if (!fontSize) this.kmlFormat.FONTSIZE;
		var size = this.eMap.getLabelSize(feature.attributes.name.replace(/\\n/g, "<br/>"), fontSize, feature.style.fontWeight);
		this.setStyleGraphic(feature.style, null, size.w, size.h, 0, 0);
	},
	
	////////////////////////////////////////////////////////////////
	//	<span class="ja">追加 削除 変更</span><span class="en">Insert  Delete  Change</span>
	////////////////////////////////////////////////////////////////
	/** <span class="ja">凡例と地図のFeatureが追加された時の処理 <br/> (作図コントロールでmemoLayerには追加されている)</span><span class="en">Processing when legend and map's features are inserted</span>
	 * @param type <span class="ja">ジオメトリ形状のタイプ</span><span class="en">Type of geometry shapes</span>
	 * @param feature <span class="ja">追加されたOpenLayers.Feature.Vector</span><span class="en">The inserted OpenLayers.Feature.Vector</span> */
	_featureAdded : function(type, feature)
	{
		console.log(feature);
		
		//<span class="ja">地図のメモレイヤにフィーチャ追加</span><span class="en">Insert feature into map's memo layer</span>
		//feature.fid = fid;
		feature.attributes.description = "{created:"+new Date().getTime()+"}";
		
		//<span class="ja">デフォルトスタイルをFeatureのスタイルにコピー</span><span class="en">Copy default styles to Feature's styles</span>
		//デフォルトスタイルをFeatureのスタイルにコピー
		if (type != this.PHOTO) {
			var defaultStyle = this.memoLayer.styleMap.styles['default'].defaultStyle;
			feature.style = dojo.clone(defaultStyle);
		}
		feature.style.memo = true; //メモFeatureフラグ設定
		
		//<span class="ja">個別スタイルを調整</span><span class="en">Adjust the styles individually</span>
		switch (type) {
		case this.POINT:
			var style = this.iconStyle;
			//選択済のアイコンサイズで追加
			if (this.iconSize > 0) {
				var scale = this.iconSize/Math.max(style.graphicWidth, style.graphicHeight);
				style.graphicWidth *= scale;
				style.graphicHeight *= scale;
				style.graphicXOffset *= scale;
				style.graphicYOffset *= scale;
			}
			this.setStyleGraphic(feature.style, style.externalGraphic, style.graphicWidth, style.graphicHeight, style.graphicXOffset, style.graphicYOffset);
			//KML出力用のscaleをstyle.graphicScaleに設定
			this._adjustIconScale(feature.style);
			this.memoLayer.drawFeature(feature);
			break;
		case this.PHOTO:
			this.memoLayer.drawFeature(feature);
			break;
		case this.TEXT:
			//<span class="ja">改行がXMLでは消えるので "\\n" に変更</span><span class="en">Because the breakline characters in XML are ignored, convert them to "\\n"</span>
			feature.attributes.name = feature.attributes.name.replace(/\n/g, "\\n");
			//<span class="ja">選択用の背景</span><span class="en">Background of the selection</span>
			this.setLabelBackground(feature);
			feature.style.label = feature.attributes.name;
			//官民修正：新規登録時の線幅をユーザが選択した太さになるようにした。
			//feature.style.strokeWidth = 1;//<span class="ja">線幅は最初は１</span><span class="en">Set initialized stroke width to 1</span>
			feature.style.externalGraphic = null;
			this.memoLayer.drawFeature(feature);
			break;
		case this.LINESTRING:
		case this.POLYGON:
			this.setStyleGraphic(feature.style, null, null, null, null, null);
			break;
		}
		
		//<span class="ja">追加中のFeatureに設定</span><span class="en">Set to adding Feature</span>
		this.addingFeature = feature;
		
		//<span class="ja">モード変更</span><span class="en">Change mode</span>
		//this.changeEditControl('SELECT');
		
		this.clearFeatureSelection();
		this.selectFeature(feature);
		
		//<span class="ja">リスト更新</span><span class="en">Update the list</span>
		if (this.dataGrid) this.showList();
	},

	/** <span class="ja">フィーチャ変更時に呼び出し</span><span class="en">Call this function when modifying feature</span>
	 * @param <span class="ja">変更されたOpenLayers.Feature.Vector </span><span class="en">The modified OpenLayers.Feature.Vector</span>*/
	_featureModified : function(feature)
	{
		var json = {};
		try { json = dojo.fromJson(feature.attributes.description); } catch (e) {}
		json.modified = new Date().getTime();
		feature.attributes.description = dojo.toJson(json);
		//<span class="ja">リスト更新</span><span class="en">Update list</span>
		if (this.dataGrid) this.showList();
	},

	/** 選択中のフィーチャの更新情報を設定し図形一覧も更新
	 *  フィーチャ変更時に呼び出し
	 * @param 変更されたOpenLayers.Feature.Vector */
	_selectedFeaturesModified : function()
	{
		var selected = this.memoLayer.selectedFeatures;
		for (var i=selected.length-1; i>=0; i--) {
			this._featureModified(selected[i], true);
		}
		//リスト更新
		if (this.dataGrid) this.showList();
	},
	
	
	////////////////////////////////////////////////////////////////
	//	<span class="ja">スタイル</span><span class="en">Style</span>
	////////////////////////////////////////////////////////////////
	/** <span class="ja">最前面または最背面に移動</span><span class="en">Move to top or bottom</span> */
	changeOrderToEnds :function(toTop)
	{
		try {
			var f = this.memoLayer.features;
			var sf = this.memoLayer.selectedFeatures;
			var sfMap = {};
			for (var i=sf.length-1; i>=0; i--) {
				sfMap[sf[i].id] = true;
			}
			
			if (toTop) {
				f.sort(function(a,b){
					return (sfMap[a.id]?1:0) - (sfMap[b.id]?1:0);
				});
			} else {
				f.sort(function(b,a){
					return (sfMap[a.id]?1:0) - (sfMap[b.id]?1:0);
				});
			}
			//<span class="ja">再描画</span><span class="en">Redraw</span>
			this.memoLayer.eraseFeatures(f);
			for (var i=0; i<f.length; i++) {
				this.memoLayer.drawFeature(f[i]);
			}
		} catch (e) { console.error(e); }
	},
	
	/** <span class="ja">図形種別変更 </span><span class="en">Set shape type</span>*/
	setShapeType : function(mode, iconClass)
	{
		this.shapeType = mode;
		dijit.byId('memoSHAPE').iconNode.className = "dijitReset dijitInline "+iconClass;
		this.changeEditControl(mode);
	},
	
	/** <span class="ja">アイコン変更</span><span class="en">Set icon</span> */
	setIcon : function(iconURL, w, h, x, y)
	{
		//<span class="ja">アイコンスタイル設定</span><span class="en">Set icon styles</span>
		this.iconStyle = {externalGraphic:iconURL, graphicWidth:w, graphicHeight:h, graphicXOffset:x, graphicYOffset: y};
		
		//<span class="ja">選択済みのFeatureの色を設定</span><span class="en">Set color for the Features which are already selected</span>
		var features = this.memoLayer.selectedFeatures;
		for (var i in features) {
			var feature = features[i];
			var style = feature.style;
			//点のみ
			if (feature.geometry.CLASS_NAME.match(/Point$/)) {
				if (!this.isText(feature) && !this.isPhoto(feature)) {
					var scale = 1;
					if (style.externalGraphic) {
						//変更前のサイズ
						var size = Math.max(style.graphicWidth, style.graphicHeight);
						//アイコン変更＋サイズ変更
						var scale = size/Math.max(w, h);
					}
					style.externalGraphic = iconURL;
					style.graphicWidth = w*scale;
					style.graphicHeight = h*scale;
					style.graphicXOffset = x*scale;
					style.graphicYOffset = y*scale;
					this.memoLayer.drawFeature(features[i]);
					this._adjustIconScale(style);
				}
			}
		}
		
		/*
		//var iconUrl = "url("+iconFile.replace(/\.png$/, "_s.png")+")";
		var url = "url("+iconURL+")";
		dijit.byId('memoIcon').iconNode.style.backgroundImage = url;
		dijit.byId('memoPOINT').iconNode.style.backgroundImage = url;
		dijit.byId('memoIconList').onCancel();
		*/
	},
	
	/** アイコンサイズ変更
	 * @param size アイコンサイズ */
	setIconSize : function(size)
	{
		if (size > 0) {
		//追加時のアイコンサイズ
		this.iconSize = size;
		
		//選択済みのFeatureの文字サイズを設定
		var features = this.memoLayer.selectedFeatures;
		for (var i=0; i<features.length; i++) {
			//点のみアイコンサイズ変更
			if (features[i].geometry.CLASS_NAME.match(/Point$/)) {
				var style = features[i].style;
				if (style.externalGraphic) {
					//変更前アイコンサイズ
					var scale = size/Math.max(style.graphicWidth, style.graphicHeight);
					console.log(scale);
					style.graphicWidth *= scale;
					style.graphicHeight *= scale;
					style.graphicXOffset *= scale;
					style.graphicYOffset *= scale;
					style.graphicScale *= scale;
				} else {
					style.pointRadius = size;
				}
				this.memoLayer.drawFeature(features[i]);
			}
		}
		//var icon = dojo.byId('memoIconSize').firstChild;
		//icon.className = icon.className.replace(/iconSize\d+/, "iconSize"+size);
		}
	},
	
	/** KML出力用のアイコンのscaleをstyle.graphicScaleに設定 */
	_adjustIconScale : function(style)
	{
		var img = new Image();
		img.onload = function() {
			style.graphicScale = Math.max(style.graphicWidth)/this.width;
		};
		img.src = style.externalGraphic;
		if (img.width) {
			style.graphicScale = Math.max(style.graphicWidth)/img.width;
		}
	},

	/**
	 * @since SaigaiTask-2.2
	 */
	setSelectedFeatureStyle: function(changeStyleFunc) {
		var me = this;
		var memoLayer = me.memoLayer;
		var features = memoLayer.selectedFeatures;
		for (var i=0; i<features.length; i++) {
			var f = features[i];
			var beforeFeature = me.cloneTextFeature(f);
			changeStyleFunc(f);
			memoLayer.drawFeature(f);
	        me.layer.events.triggerEvent("featuremodified", {
	        	type: "featuremodified",
	        	feature: f,
	        	afterFeature: me.cloneTextFeature(f),
	        	beforeFeature: beforeFeature
	        });
		}
	},
	
	/** <span class="ja">文字色変更</span><span class="en">Change text color</span>
	 * @param color <span class="ja">#RRGGBB 形式の文字列</span><span class="en">String in #RRGGBB format</span> */
	setFontColor : function(color)
	{
		var defaultStyle = this.memoLayer.styleMap.styles['default'].defaultStyle;
		//<span class="ja">デフォルトに設定</span><span class="en">Set default value</span>
		defaultStyle.fontColor = color;
		
		//<span class="ja">選択済みのFeatureの色を設定</span><span class="en">Set color for the Features which are already selected</span>
		var features = this.memoLayer.selectedFeatures;
		for (var i=0; i<features.length; i++) {
			var f = features[i];
			f.style.fontColor = color;
			this.memoLayer.drawFeature(f);
		}
		dijit.byId('memoFontColor').iconNode.style.backgroundColor = color;
	},
	/** <span class="ja">線色変更</span><span class="en">Change stroke color</span>
	 * @param color <span class="ja">#RRGGBB 形式の文字列</span><span class="en">String in #RRGGBB format</span> */
	setDrawColor : function(color)
	{
		var defaultStyle = this.memoLayer.styleMap.styles['default'].defaultStyle;
		//<span class="ja">デフォルトに設定</span><span class="en">Set default value</span>
		defaultStyle.strokeColor = color;
		
		//<span class="ja">選択済みのFeatureの色を設定</span><span class="en">Set color for the Features which are already selected</span>
		var features = this.memoLayer.selectedFeatures;
		for (var i=0; i<features.length; i++) {
			var f = features[i];
			f.style.strokeColor = color;
			this.memoLayer.drawFeature(f);
		}
		dijit.byId('memoDrawColor').iconNode.style.backgroundColor = color;
	},
	/** <span class="ja">線幅変更</span><span class="en">Change stroke width</span>
	 * @param width <span class="ja">0～10の整数</span><span class="en">Integer in 0～10</span> */
	setLineWidth : function(width)
	{
		var defaultStyle = this.memoLayer.styleMap.styles['default'].defaultStyle;
		//<span class="ja">デフォルトに設定</span><span class="en">Set default value</span>
		defaultStyle.strokeWidth = width;
		
		//<span class="ja">選択済みのFeatureの色を設定</span><span class="en">Set color for the Features which are already selected</span>
		var features = this.memoLayer.selectedFeatures;
		for (var i=0; i<features.length; i++) {
			features[i].style.strokeWidth = width;
			this.memoLayer.drawFeature(features[i]);
		}
		//var icon = dojo.byId('memoLineWidth').firstChild;
		//icon.className = icon.className.replace(/lineWidth\d+/, "lineWidth"+Math.min(10, width));
	},
	/** <span class="ja">面の色変更</span><span class="en">Change area color</span>
	 * @param color <span class="ja">#RRGGBB 形式の文字列</span><span class="en">String in #RRGGBB format</span> */
	setFillColor : function(color)
	{
		var defaultStyle = this.memoLayer.styleMap.styles['default'].defaultStyle;
		//<span class="ja">デフォルトに設定</span><span class="en">Set default value</span>
		defaultStyle.fillColor = color;
		//<span class="ja">選択済みのFeatureの色を設定</span><span class="en">Set color for the Features which are already selected</span>
		var features = this.memoLayer.selectedFeatures;
		for (var i=0; i<features.length; i++) {
			var style = features[i].style;
			style.fillColor = color;
			//<span class="ja">if (style.label) style.externalGraphic = "/map/texture?fg="+style.fillColor.substring(1);
			this.memoLayer.drawFeature(features[i]);
		}
		//dojo.byId('memoFillColor').firstChild.style.backgroundColor = color;
	},
	/** <span class="ja">塗潰し不透明度</span><span class="en">Set fill opacity</span>
	 * @param opacity 0.0～1.0 */
	setFillOpacity : function(opacity)
	{
		var defaultStyle = this.memoLayer.styleMap.styles['default'].defaultStyle;
		//<span class="ja">デフォルトに設定</span><span class="en">Set default value</span>
		defaultStyle.fillOpacity = opacity;
		
		//<span class="ja">選択済みのFeatureの色を設定</span><span class="en">Set color for the Features which are already selected</span>
		var features = this.memoLayer.selectedFeatures;
		for (var i=0; i<features.length; i++) {
			features[i].style.fillOpacity = opacity;
			this.memoLayer.drawFeature(features[i]);
		}
	},
	/** <span class="ja">線幅変更</span><span class="en">Change stroke width</span>
	 * @param width <span class="ja">0～10の整数</span><span class="en">Integer in 0～10</span> */
	setFontSize : function(size)
	{
		var defaultStyle = this.memoLayer.styleMap.styles['default'].defaultStyle;
		//<span class="ja">デフォルトに設定</span><span class="en">Set default value</span>
		defaultStyle.fontSize = size;
		
		//<span class="ja">選択済みのFeatureの文字サイズを設定</span><span class="en">Set font size for the Features which are already selected</span>
		var features = this.memoLayer.selectedFeatures;
		for (var i=0; i<features.length; i++) {
			var f = features[i];
			if (f.attributes.name) {
				if (f.attributes.description) {
					this.setTextZoomOption(f.attributes, true);
				}
				f.style.fontSize = size;
				this.setLabelBackground(f);
				this.memoLayer.drawFeature(f);
			}
		}
		//var icon = dojo.byId('memoFontSize').firstChild;
		//icon.className = icon.className.replace(/fontSize\d+/, "fontSize"+size);
	},
	/** テキストサイズ連動のオプションをdescriptionに設定 */
	setTextZoomOption : function(attributes, update, remove)
	{
		try {
		var option = {};
		try { option = dojo.fromJson(attributes.description); } catch (e) {}
		//基準解像度設定
		if (update) {
			//設定されている場合は解像度更新
			if (option.reso) option.reso = this.memoLayer.getResolution();
		} else {
			//有効と無効を切り替える
			if (remove) {
				if (option.reso) delete option.reso;
			} else {
				option.reso = this.memoLayer.getResolution();
			}
		}
		attributes.description = dojo.toJson(option);
		attributes.option = option; //レンダラー利用中のoptionも更新
		} catch (e) { console.error(e); }
	},
	
	/** <span class="ja">凡例名称と地図のFeatureスタイルを更新</span><span class="en">Update styles of legend name and map's Feature</span> */
	updateStyle : function(type, feature, form)
	{
		//<span class="ja">地図のメモレイヤのフィーチャ更新</span><span class="en">Change feature of map's memo layer</span>
		
		
		this.changeEditControl(null);
		
		//<span class="ja">KMLに保存</span><span class="en">Save to KML</span>
		
	},

	CLASS_NAME: "SaigaiTask.Map.Layer.DrawLayerSelectDrag"
});
/* ======================================================================
    SaigaiTask/Map/Layer/DrawLayer.js
   ====================================================================== */

/**
 * 描画レイヤ
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/DrawLayerSelectDrag.js
 */
SaigaiTask.Map.Layer.DrawLayer = new OpenLayers.Class(SaigaiTask.Map.Layer.DrawLayerSelectDrag, {

	stmap: null,

	/** 地図click時のハンドラ */
	singlePointMoveClickHandler: null,

	/** 描画用のレイヤ */
	layer: null,
	drawFeatures: null,
	activeDrawKey: null,
	featureIdSerial: 0,

	/**
	 * コントロールの連想配列
	 * @type {Object.<String, OpenLayers.Control>}
	 */
	controls: null,

	/**
	 * @type {SaigaiTask.Map.Control.SnapControl}
	 */
	snapControl: null,

	/**
	 * ユーザが設定したスタイル
	 * @type {Object}
	 */
	userStyle: null,

	/**
	 *
	 */
	initialize: function(stmap) {
		var me = this;
		me.stmap = stmap;

		// スナップレイヤを初期化
		me.snapControl = new SaigaiTask.Map.control.SnapControl(stmap);

		// 描画レイヤを初期化
		me.initDraw();
		me.userStyle = {};

		// スナップの編集レイヤに描画レイヤを設定
		me.snapControl.setLayer(me.layer);

		// 点を描画して位置を選ぶ
		me.singlePointMoveClickHandler = new OpenLayers.Handler.Click(
			stmap, {
				click: function(evt) {
					var lonlat = stmap.map.getLonLatFromPixel(new OpenLayers.Pixel(evt.xy.x, evt.xy.y));
					var ret = me.moveSinglePoint(lonlat);
					var feature = ret.feature;
					$("."+feature.fid).change();
					return ret;
				}
			}, {
				single: true
			}
		);
		me.singlePointMoveClickHandler.deactivate();

		// 描画の履歴
		me.historyControl = new SaigaiTask.Map.control.DrawLayerHistoryControl(me);
		stmap.controls.kmlSelectControl.deactivate();

		// テキストメモ用の選択ボタンの初期化
		SaigaiTask.Map.Layer.DrawLayerSelectDrag.prototype.initialize.apply(this, [me.layer]);
	},

	getFeatureIDPrefix: function(){
		return this.stmap.div+"Feature";
	},

	createFeatureID: function(drawKey){
		// TODO: DrawLayerを識別できるようにする？
		var num = this.layer.features.length-1;
		return this.getFeatureIDPrefix()+num;
	},

	getFeatureIndexFromID: function(featureId){
		var prefix = this.getFeatureIDPrefix();
		var id = featureId.substring(prefix.length);
		return id;
	},

	initDraw: function(){
		var me = this;
		var stmap = me.stmap;
		// 描画レイヤを作成
		var layer = me.layer = new OpenLayers.Layer.Vector("Draw Layer");
		layer.events.on({
			"featureadded": function(evt){
				var feature = evt.feature;
				// 追加したフィーチャを取得する
				var f = feature;
				// フィーチャIDを設定する
				f.fid = me.createFeatureID(me.activeDrawKey);
				// 追加したフィーチャにスタイル設定がなければデフォルトスタイルを保存する
				if(!f.style) {
					f.style = new Object();
					var style = me.layer.styleMap.styles['default'].defaultStyle;
					for(var key in style){
						f.style[key] = style[key];
					}
				}
				// マウスカーソルをポインタにする
				f.style.cursor="pointer";
				// フィーチャを保存する
				if(!me.drawFeatures[me.activeDrawKey]){
					me.drawFeatures[me.activeDrawKey] = new Array();
				}
				me.drawFeatures[me.activeDrawKey].push(f);
				me.writeFeatureGeometoryValue(feature);
			},
			"featureremoved": function(evt){
				var feature = evt.feature;
				$("."+feature.fid).val("");
			},
			"featuremodified": function(evt){
				var feature = evt.feature;
				me.writeFeatureGeometoryValue(feature);
			}

		});
		stmap.addLayer(layer);

		// 描画スタイルを設定
		layer.styleMap = new OpenLayers.StyleMap();
		// スタイル複製しておく
		for(var key in layer.styleMap.styles) {
			var obj = layer.styleMap.styles[key];
			if(obj instanceof OpenLayers.Style) {
				layer.styleMap.styles[key] = obj.clone();
			}
		}
		layer.styleMap.styles['default'].defaultStyle = me.getDrawControlStyle();

		// 描画コントローラを作成
		var dragFeatureStatus = null;
		var drawControls = {
			text: new OpenLayers.Control.DrawFeature(layer, OpenLayers.Handler.Point, {
				featureAdded:function(feature){ me._startTextEdit(feature); }
			}),
			point:   new OpenLayers.Control.DrawFeature(layer,OpenLayers.Handler.Point),
			line:    new OpenLayers.Control.DrawFeature(layer,OpenLayers.Handler.Path),
			freeline:    new OpenLayers.Control.DrawFeature(layer,OpenLayers.Handler.Path, {
				handlerOptions: {
					freehand: true
				}
			}),
			polygon: new OpenLayers.Control.DrawFeature(layer,OpenLayers.Handler.Polygon),
			circle: new OpenLayers.Control.DrawFeature(layer,OpenLayers.Handler.RegularPolygon, {
				handlerOptions: {sides: 40}, // 頂点数
				eventListeners: {
					"deactivate": function() {
						// 前の半径ポップアップがあったら閉じる
						if(!!stmap.popupManager) {
							stmap.popupManager.closeAll();
						}
					}
				},
				callbacks: {
					// dragging
					"move": function(geometry) {
						// 円の半径を求める
						// 単位がメートルの座標系に変換
						if(map.map.units!="m") {
							geometry = geometry.clone().transform(map.map.getProjectionObject(), new OpenLayers.Projection("EPSG:900913"));
						}
						// 円の面積 A = Pi * r^2
						// r = Sqrt(A / Pi) = 0.56419 * Sqrt(A)
						var area = geometry.getArea();
						var radius = 0.565352 * Math.sqrt(area);

						// 前の半径ポップアップがあったら閉じる
						if(!!stmap.popupManager) {
							stmap.popupManager.closeAll();
						}

						// 円の半径を表示する
						var centroid = geometry.getCentroid();
						var center = new OpenLayers.LonLat(centroid.x, centroid.y).transform(stmap.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));
						popup = new SaigaiTask.Map.view.Popup();
						var radiusText = parseInt(radius)+"m";
						if(10000 < radius) radiusText =(radius/1000).toFixed(2)+"km";
						popup.showExtPopup({
							map: stmap,
							olmap: stmap.map,
							center: center,
							size: new OpenLayers.Size(150,10),
							title: radiusText
						});
					}
				}
			}),
			box:     new OpenLayers.Control.DrawFeature(layer,OpenLayers.Handler.RegularPolygon, {
				handlerOptions: {
					sides: 4,
					irregular: true
				}
			}),
			dragFeature: new OpenLayers.Control.DragFeature(layer, {
				onStart: function(feature,pixel){
					dragFeatureStatus = {
						beforeFeature: feature.clone()
					};
				},
				onComplete: function(feature,pixel){
					me.writeFeatureGeometoryValue(feature);
					if(!!dragFeatureStatus) {
						// 地物の移動イベントをトリガーする
						var event = {
							type: "featuremoved",
							feature: feature,
							afterFeature: feature.clone(),
							beforeFeature: dragFeatureStatus.beforeFeature
						};
						me.layer.events.triggerEvent(event.type, event);
						dragFeatureStatus = null;
					}
				}
			}),
			modifyFeature: new OpenLayers.Control.ModifyFeature(layer),
			selectFeature: new OpenLayers.Control.SelectFeature(layer),
			selectDragFeature: new OpenLayers.Control.SelectDragFeature(layer, {
				onSelect:function(feature){ me._featureSelected(feature); },
				onUnselect:function(feature){ me._featureUnselected(feature); },
				onDblClick:function(feature){ me.checkTextEdit(feature); },
				onKeyDown:function(evt){ /*if (me.eMap.isFocus())*/ if(document.activeElement.tagName!="TEXTAREA") me._onKeyDown(evt); },
				//onStart:function(feature, pixel, toggled){ if (!toggled) me.selectFeature(feature); },
				onStart: function(feature,pixel){
					// SelectDragControlでは複数選択して移動ができるためその対応
					var features = me.memoLayer.selectedFeatures;
					for(var idx in features) {
						var feature = features[idx];
						delete feature.beforeFeature;
						var beforeFeature = me.cloneTextFeature(feature);
						feature.beforeFeature = beforeFeature;
					}
					dragFeatureStatus = {
					};
				},
				onDrag:function(pixel){ me.memoSelectLayer.setVisibility(false); },
				onComplete:function(pixel){
					me.memoSelectLayer.setVisibility(true);
					me.resetFeatureSelection(layer);
					me._selectedFeaturesModified();

					if(!!dragFeatureStatus) {
						var features = me.memoLayer.selectedFeatures;
						for(var idx in features) {
							//var feature = me.controls.selectDragFeature.mouseFeature;
							var feature = features[idx];
							beforeFeature = feature.beforeFeature;

							// 地物の移動イベントをトリガーする
							var event = {
								type: "featuremoved",
								feature: feature,
								afterFeature: me.cloneTextFeature(feature),
								beforeFeature: beforeFeature
							};
							me.layer.events.triggerEvent(event.type, event);
						};
						dragFeatureStatus = null;							
					}
				},
				clickout:true, toggle:false, multiple:false, hover:false, toggleKey:"ctrlKey", multipleKey:"shiftKey", box:false
			}),
			selectDragFeatureBox: new OpenLayers.Control.SelectDragFeature(layer, {
				onSelect:function(feature){ me._featureSelected(feature); },
				onUnselect:function(feature){ me._featureUnselected(feature); },
				onDblClick:function(feature){ me.checkTextEdit(feature); },
				onKeyDown:function(evt){ /*if (me.eMap.isFocus())*/ if(document.activeElement.tagName!="TEXTAREA") me._onKeyDown(evt); },
				//onStart:function(feature, pixel, toggled){ if (!toggled) self.selectFeature(feature); },
				onStart: function(feature,pixel){
					// SelectDragControlでは複数選択して移動ができるためその対応
					var features = me.memoLayer.selectedFeatures;
					for(var idx in features) {
						var feature = features[idx];
						delete feature.beforeFeature;
						var beforeFeature = me.cloneTextFeature(feature);
						feature.beforeFeature = beforeFeature;
					}
					dragFeatureStatus = {
					};
				},
				onDrag:function(pixel){ me.memoSelectLayer.setVisibility(false); },
				onComplete:function(pixel){
					me.memoSelectLayer.setVisibility(true);
					me.resetFeatureSelection(layer);
					me._selectedFeaturesModified();

					if(!!dragFeatureStatus) {
						var features = me.memoLayer.selectedFeatures;
						for(var idx in features) {
							//var feature = me.controls.selectDragFeature.mouseFeature;
							var feature = features[idx];
							beforeFeature = feature.beforeFeature;

							// 地物の移動イベントをトリガーする
							var event = {
								type: "featuremoved",
								feature: feature,
								afterFeature: me.cloneTextFeature(feature),
								beforeFeature: beforeFeature
							};
							me.layer.events.triggerEvent(event.type, event);
						};
						dragFeatureStatus = null;							
					}
				},
				clickout:true, toggle:false, multiple:false, hover:false, toggleKey:"ctrlKey", multipleKey:"shiftKey", box:true})
			
		};

		// 描画コントローラを追加
		me.controls = {};
		for(var key in drawControls){
			var control = drawControls[key];
			me.addControl(control, key);
		}

		// フィーチャ編集コントローラ設定
		var virtualStyle = drawControls.modifyFeature.virtualStyle;
		virtualStyle.strokeColor = "#FF0000";
		virtualStyle.strokeWidth = 2;
		virtualStyle.strokeDashstyle = 'dash';
		virtualStyle.externalGraphic = stmap.icon.getURL("verticeIconURL");
		virtualStyle.graphicWidth = 9;
		virtualStyle.graphicHeight = 9;
		virtualStyle.graphicOpacity = 0.5;
		virtualStyle.graphicXOffset = -5;
		virtualStyle.graphicYOffset = -5;

		// 描画フィーチャを保存するオブジェクトを生成
		me.drawFeatures = new Object();
		for(var key in drawControls){
			me.drawFeatures[key] = new Array();
		}
	},

	// 描画スタイル
	/**
	 * 描画コントロールのデフォルトスタイルを取得する
	 * KMLStyle のために、色名を使用せず、カラーコードを用いる.
	 * @param {String} 描画コントローラキー
	 */
	getDrawControlDefaultStyle: function(key){
		var me = this;
		var stmap  = me.stmap;
		console.log("getDrawControlDefaultStyle");
		var style = {
			// 塗りつぶしの設定
			fillColor: "#FFFFFF",
			fillOpacity: 0.4,
			// ラインの設定
			strokeColor: "#000000",//"#ee9900",
			strokeOpacity: 1,
			strokeWidth: 2,
			strokeLinecap: "round", // butt, round, square
			strokeDashstyle: "solid", // dot, dash, dashdot, longdash, longdashdot, solid
			// フォント設定
			fontSize: 14, // @see OpenLayers.Format.KMLStyle.FONTSIZE
			labelAlign:"lt",
			// 図の設定
			externalGraphic: stmap.icon.getURL("editingIconURL"),
			graphicWidth: 19,
			graphicHeight: 32,
			graphicXOffset: -9,
			graphicYOffset: -32,
			graphicOpacity: 1
		};
		switch(key){
		case "point":
		case "line":
		case "polygon":
		case "box":
			break;
		case "modifyFeature":
			style.externalGraphic = stmap.icon.getURL("pointnodeIconURL");
			style.graphicWidth = 9;
			style.graphicHeight = 9;
			style.graphicXOffset = -5;
			style.graphicYOffset = -5;
			style.graphicOpacity = 1;
			break;
		case "selectDragFeature":
		case "text":
			style = {};
			Ext.apply(style, me.modifyStyleMap.styles.default.defaultStyle);
			break;
		}
		return style;
	},
	/**
	 * 描画コントロールに対応したトスタイルを取得する
	 * @param {String} 描画コントローラキー
	 */
	getDrawControlStyle: function(key){
		var me = this;
		var stmap  = me.stmap;
		var style = me.getDrawControlDefaultStyle(key);
		// ユーザが設定したスタイルがあれば上書き
		Ext.apply(style, me.userStyle);
		return style;
	},

	/**
	 * フィーチャの値を指定クラスに書き込む
	 * @param {OpenLayers.Feature} feature
	 */
	writeFeatureGeometoryValue: function(feature){
		if(!feature) return;
		var me = this;
		var stmap = me.stmap;
		var wkt = stmap.getWKT(feature);
		var featureId = feature.fid;
		switch(feature.geometry.CLASS_NAME){
		case "OpenLayers.Geometry.Point":
		case "OpenLayers.Geometry.LineString":
		case "OpenLayers.Geometry.Polygon": // 四角形も含む
		default:
			// 値を書き込む
			var c = "."+featureId;
			var jqueryObj = jQuery(c);
			jqueryObj.val(wkt);
			break;
		}
	},

	/**
	 * 指定の座標に座標選択用の点を移動する.
	 * 点がない場合は描画する.
	 * @param {OpenLayers.LonLat} lonlat
	 * @returns {Object} ret
	 */
	moveSinglePoint: function(lonlat){
		var me = this;
		// point draw control
		var drawKey = 'point';
		var idx = 0;
		var feature = me.drawFeatures[drawKey][idx];

		me.layer.setVisibility(true);

		if(lonlat!=null) {
			if(feature){
				feature.move(lonlat);
			}
			else {
				var lon = lonlat.lon;
				var lat = lonlat.lat;
				me.drawPointFeature(lon,lat);
				feature = me.drawFeatures[drawKey][idx];
			}
		}

		if(feature!=null) {
			me.writeFeatureGeometoryValue(feature);
		}

		var ret = {
			feature: feature
		};

		return ret;
	},

	/**
	 * 座標選択用の点を削除する.
	 */
	removeSinglePoint: function() {
		return me.removePointFeature(0);
	},


	/**
	 * 地図の中心にポイントを描画する
	 */
	drawCenterPoint: function(){
		var center = this.map.getCenter();
		return this.drawPointFeature(center.lon, center.lat);
	},

	/**
	 * ポイントを描画する
	 * @param {Number} lon
	 * @param {Number} lat
	 */
	drawPointFeature: function(lon,lat){
		var geometry = new OpenLayers.Geometry.Point(lon,lat);
		return this.drawFeature("point",geometry);
	},

	/**
	 * ジオメトリを描画する
	 * @param {String} controlKey 描画コントローラキー
	 * @param {OpenLayers.Geometry} geometry ジオメトリ
	 */
	drawFeature: function(controlKey, geometry){
		if(!geometry||!controlKey) return;

		var drawControl = this.getDrawControl(controlKey);
		var savedActiveDrawKey = this.activeDrawKey;
		this.activeDrawKey = controlKey;
		var ret = drawControl.drawFeature(geometry);
		this.activeDrawKey = savedActiveDrawKey;
		return ret;
	},

	/**
	 * ジオメトリを描画する
	 * @param {OpenLayers.Geometry} geometry (EPSG:4326)
	 */
	drawFeatureByGeometry: function(geometry) {
		var me = this;
		if(geometry.CLASS_NAME.match(/^OpenLayers.Geometry.Multi/)!=null) {
			for(var idx in geometry.components) {
				me.drawFeatureByGeometry(geometry.components[idx]);
			}
		}
		else {
			var controlKey = null;
			switch(geometry.CLASS_NAME) {
			case "OpenLayers.Geometry.Point":
				controlKey = "point";
				break;
			case "OpenLayers.Geometry.LineString":
				controlKey = "line";
				break;
			case "OpenLayers.Geometry.Polygon":
				controlKey = "polygon";
				break;
			}
			geometry.transform(new OpenLayers.Projection("EPSG:4326"), me.stmap.map.getProjectionObject());
			me.drawFeature(controlKey, geometry);
		}
	},

	getDrawLayerFeatureByIndex: function(idx) {
		return this.layer.features[idx];
	},

	removePointFeature: function(idx){
		return this.removeFeature("point",idx);
	},

	removeFeature: function(drawKey,idx){
		var feature = this.drawFeatures[drawKey][idx];
		this.layer.removeFeatures([feature]);
		this.drawFeatures[drawKey][idx] = null;
	},

	// コントローラ
	/**
	 * コントローラをOpenLayersに追加する
	 * キーがあれば連想配列に保存する
	 * @param {OpenLayers.Control} control コントローラ
	 * @param {String} key 連想配列のキー
	 */
	addControl: function(control, key) {
		if(typeof key!='undefined'){
			this.controls[key]=control;
		}
		return this.stmap.map.addControl(control);
	},

	setControlActivation: function(control,activation) {
		var me = this;
		if(activation)return control.activate();
		else {
			if(control==me.getDrawControl(me.activeDrawKey)) {
				me.activeDrawKey = null;
			}
			return control.deactivate();
		}
	},

	// 描画コントローラ
	/**
	 * 描画コントローラを取得する
	 * @param {String} key 描画コントローラキー
	 */
	getDrawControl: function(key){
		return this.controls[key];
	},

	/**
	 * 描画コントローラの有効フラグを取得する
	 * @param {String} key 描画コントローラキー
	 */
	getDrawActivation: function(key){
		var control=this.getDrawControl(key);
		return control.active;
	},

	/**
	 * 描画コントローラの有効フラグを設定する
	 * @param {String} key 描画コントローラキー
	 * @param {Boolean} activate 有効フラグ
	 */
	setDrawActivation: function(key,activate){
		var control=this.getDrawControl(key);
		return this.setControlActivation(control,activate);
	},

	/**
	 * 描画コントローラを無効にする
	 * @param {String} 描画コントローラキー
	 */
	deactivateDrawControl: function(key){
		return this.setDrawActivation(key,false);
	},

	/**
	 * 現在有効になっているモードがあるならOFFにする
	 */
	deactivateCurrentDrawControl: function(){
		var activeDrawKey = this.activeDrawKey;
		if(activeDrawKey) {
			return this.deactivateDrawControl(activeDrawKey);
		}
	},

	/**
	 * 描画コントローラを有効にする
	 * 一度に有効にできるコントローラは１つだけ。
	 * @param {String} 描画コントローラキー
	 */
	activateDrawControl: function(key){
		// マウスコントロールをすべて解除する
		//this.deactivateMouseControl();
		// 有効にする
		if(key){
			console.log("activate "+key);
			this.setDrawActivation(key,true);
			this.activeDrawKey=key;
			var style = this.getDrawControlStyle(key);
			this.layer.styleMap.styles['default'].defaultStyle = style;
			return true;
		}
		return false;
	},

	/**
	 * フィーチャ移動コントローラのactivationを取得します.
	 */
	getDragFeatureControl: function() {
		var me = this;
		var key = "dragFeature";
		var control = me.controls[key];
		if(!control) return null;
		return control;
	},

	/**
	 * フィーチャ移動コントローラのactivationを取得します.
	 */
	getDragFeatureControlActivation: function() {
		var me = this;
		var control = me.getDragFeatureControl();
		if(!control) return false;
		return control.active;
	},

	/**
	 * フィーチャ移動コントローラの有効無効を指定します.
	 * @type {Boolean} activation 指定がなければ反転
	 */
	setDragFeatureControlActivation: function(activation) {
		var me = this;
		var stmap = me.stmap;
		var key = "dragFeature";
		var control = me.getDragFeatureControl()
		if(!control) return;
		if(typeof activation=="undefined"){
			// 指定がなければ反転する
			activation = !control.active;
		}

		if(activation){
			stmap.deactivateMouseControl();
			me.deactivateCurrentDrawControl(); // 描画
			me.setDragFeatureControlActivation(false); // フィーチャ移動
			me.setModifyFeatureControlActivation(false); // フィーチャ編集
			stmap.setNavigationControlActivation(true);
			return me.activateDrawControl(key);
		}
		return me.setControlActivation(control, activation);
	},


	/**
	 * フィーチャ選択コントローラのactivationを取得します.
	 */
	getSelectDragFeatureControl: function() {
		var me = this;
		var key = "selectDragFeature";
		var control = me.controls[key];
		if(!control) return null;
		return control;
	},
	/**
	 * フィーチャ選択コントローラのactivationを取得します.
	 */
	getBoxSelectDragFeatureControl: function() {
		var me = this;
		var key = "selectDragFeatureBox";
		var control = me.controls[key];
		if(!control) return null;
		return control;
	},

	/**
	 * フィーチャ選択コントローラのactivationを取得します.
	 */
	getSelectDragFeatureControlActivation: function() {
		var me = this;
		var control = me.getSelectDragFeatureControl();
		if(!control) return false;
		return control.active;
	},
	/**
	 * フィーチャ選択コントローラのactivationを取得します.
	 */
	getBoxSelectDragFeatureControlActivation: function() {
		var me = this;
		var control = me.getBoxSelectDragFeatureControl();
		if(!control) return false;
		return control.active;
	},

	/**
	 * フィーチャ選択コントローラの有効無効を指定します.
	 * @type {Boolean} activation 指定がなければ反転
	 */
	setSelectDragFeatureControlActivation: function(activation) {
		var me = this;
		var stmap = me.stmap;
		var key = "selectDragFeature";
		var control = me.getSelectDragFeatureControl()
		if(!control) return;
		if(typeof activation=="undefined"){
			// 指定がなければ反転する
			activation = !control.active;
		}

		if(activation){
			stmap.deactivateMouseControl();
			me.deactivateCurrentDrawControl(); // 描画
			me.setDragFeatureControlActivation(false); // フィーチャ移動
			me.setModifyFeatureControlActivation(false); // フィーチャ編集
			stmap.setNavigationControlActivation(true);
			stmap.toFront(me.layer);
			return me.activateDrawControl(key);
		}
		return me.setControlActivation(control, activation);
	},
	/**
	 * フィーチャ選択コントローラの有効無効を指定します.
	 * @type {Boolean} activation 指定がなければ反転
	 */
	setBoxSelectDragFeatureControlActivation: function(activation) {
		var me = this;
		var stmap = me.stmap;
		var key = "selectDragFeatureBox";
		var control = me.getBoxSelectDragFeatureControl()
		if(!control) return;
		if(typeof activation=="undefined"){
			// 指定がなければ反転する
			activation = !control.active;
		}

		if(activation){
			stmap.deactivateMouseControl();
			me.deactivateCurrentDrawControl(); // 描画
			me.setDragFeatureControlActivation(false); // フィーチャ移動
			me.setModifyFeatureControlActivation(false); // フィーチャ編集
			stmap.setNavigationControlActivation(true);
			stmap.toFront(me.layer);
			return me.activateDrawControl(key);
		}
		return me.setControlActivation(control, activation);
	},

	/**
	 * フィーチャ編集
	 */
	setModifyFeatureControlActivation: function(activation) {
		var me = this;
		var stmap = me.stmap;
		var key = "modifyFeature";
		var control = this.controls[key];
		if(!control)return;
		if(typeof activation=="undefined"){
			// 指定がなければ反転する
			activation = !control.active;
		}

		if(activation){
			stmap.deactivateMouseControl();
			me.deactivateCurrentDrawControl(); // 描画
			me.setDragFeatureControlActivation(false); // フィーチャ移動
			me.setModifyFeatureControlActivation(false); // フィーチャ編集
			stmap.setNavigationControlActivation(true);

			// フィーチャ編集モード
			control.mode = OpenLayers.Control.ModifyFeature.RESHAPE;

			// 編集コントローラを有効にする
			var ret = me.activateDrawControl(key);

			// フィーチャがあれば選択状態にする
			if(0<me.layer.features.length) {
				control.selectFeature(me.layer.features[0]);
			}

			return ret;
		}

		return me.setControlActivation(control, activation);
	},

	/**
	 * 終了処理
	 */
	destroy: function() {
		var me = this;
		var stmap = me.stmap;
		var olmap = stmap.map;
		var drawLayer = me;
		drawLayer.deactivateCurrentDrawControl();
		drawLayer.setDragFeatureControlActivation(false);
		// SelectFeature を無効、取り除く
		drawLayer.controls.selectFeature.deactivate();
		olmap.removeControl(drawLayer.controls.selectFeature);
		drawLayer.layer.setVisibility(false);
		drawLayer.layer.removeAllFeatures();
		drawLayer.singlePointMoveClickHandler.deactivate();
		olmap.removeLayer(drawLayer.layer);
		drawLayer.layer.destroy();
		// スナップ終了処理
		me.snapControl.destroy();
		// kmlSelectFeature を有効化
		stmap.controls.kmlSelectControl.activate();
	}

});
/* ======================================================================
    SaigaiTask/Map/control/SpatialSearch.js
   ====================================================================== */

/**
 * 登録情報の空間検索のコントローラです.
 * @class SaigaiTask.Map.control.SpatialSearch
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.SpatialSearch = function() {};
SaigaiTask.Map.control.SpatialSearch.prototype = {

	/**
	 * 検索結果のJSONを SaigaiTask.Map.model.SearchResult オブジェクトに変換して取得します.
	 * @param result 検索結果JSONオブジェクト
	 * @returns {SaigaiTask.Map.model.SearchResult}
	 */
	getSearchResult: function(result) {
		if(result) {
			var searchResult = new SaigaiTask.Map.model.SearchResult();
			searchResult.raw = result;
			var _result = result;
			if(_result) {
				searchResult.success = _result.success;

				// カウント情報を取得する
				var counts = _result.items[0];
				var resultCount = new SaigaiTask.Map.model.ResultCount();
				resultCount.total = counts[0];
				resultCount.limit = counts[1];
				resultCount.offset = counts[2];
				searchResult.counts = resultCount;

				// フィーチャ情報を取得する
				searchResult.features = [];
				var features = _result.items[1];
				for(var featuresIdx in features) {
					var feature = features[featuresIdx];
					var f = new SaigaiTask.Map.model.Feature();
					f.layerId = feature[0];
					f.featureId = feature[1];
					// ジオメトリ
					f.geometry = new SaigaiTask.Map.model.Geometry();
					var geometryResult = feature[2];
					f.geometry.wkt = geometryResult[0];
					// 属性値
					f.attributes = [];
					var attributeResults = feature[3];
					for(var attributeResultsIdx=0; attributeResultsIdx<attributeResults.length/2; attributeResultsIdx++) {
						var idx = attributeResultsIdx*2;
						var attr = new SaigaiTask.Map.model.Attribute();
						attr.id =  attributeResultsIdx;
						attr.name = attributeResults[idx];
						attr.value = attributeResults[idx+1];
						f.attributes.push(attr);
					}
					f.files = feature[4];
					f.metadata = feature[5];
					f.raw = feature;
					searchResult.features.push(f);
				}
				return searchResult;
			}
		}
		return null;
	}
};
/* ======================================================================
    OpenLayers/Control/DragMarker.js
   ====================================================================== */

/* Copyright (c) 2006 MetaCarta, Inc., published under a modified BSD license.
 * See http://svn.openlayers.org/trunk/openlayers/repository-license.txt 
 * for the full text of the license. */

/**
 * @ requires OpenLayers/Control.js
 * @ requires OpenLayers/Handler/Drag.js
 * @ requires OpenLayers/Handler/Feature.js
 */
/**
 * @class マーカードラックのためのコントロール
 * FeatureのDragの処理と同様の処理をマーカーで行う
 * 
 * Move a marker with a drag.
 */
OpenLayers.Control.DragMarker = OpenLayers.Class(OpenLayers.Control, {
	/** コントロールを初期化
	 * @param {OpenLayers.Layer.Vector} layer
	 * @param {Object} options
	 */
	initialize: function(layer, options) {
		OpenLayers.Control.prototype.initialize.apply(this, [options]);
		this.layer = layer;
		this.handlers = {
			drag: new OpenLayers.Handler.Drag(
				this, OpenLayers.Util.extend({
					down: this.downFeature,
					move: this.moveFeature,
					up: this.upFeature,
					out: this.cancel
					//done: this.doneDragging
				}, this.dragCallbacks), {
					documentDrag: this.documentDrag
				}
			)
		};
	},
	
	/** コントロールを破棄
	 * APIMethod: destroy
	 * Take care of things that are not handled in superclass
	 */
	destroy: function() {
		this.layer = null;
		OpenLayers.Control.prototype.destroy.apply(this, []);
	},

	/** コントロールを有効化
	 * APIMethod: activate
	 * Activate the control and the feature handler.
	 * 
	 * Returns:
	 * {Boolean} Successfully activated the control and feature handler.
	 */
	activate: function() {
		return (this.handlers.drag.activate() &&
				OpenLayers.Control.prototype.activate.apply(this, arguments));
	},

	/** コントロールを無効化
	 * APIMethod: deactivate
	 * Deactivate the control and all handlers.
	 * 
	 * Returns:
	 * {Boolean} Successfully deactivated the control.
	 */
	deactivate: function() {
		// the return from the handlers is unimportant in this case
		this.handlers.drag.deactivate();
		this.feature = null;
		this.dragging = false;
		this.lastPixel = null;
		OpenLayers.Element.removeClass(
			this.map.viewPortDiv, this.displayClass + "Over"
		);
		return OpenLayers.Control.prototype.deactivate.apply(this, arguments);
	},

	/** マウスがマーカ内に入ったときの処理
	 * Method: overFeature
	 * Called when the feature handler detects a mouse-over on a feature.
	 *	   This activates the drag handler.
	 *
	 * Parameters:
	 * feature - {<OpenLayers.Feature.Vector>} The selected feature.
	 */
	overFeature: function(feature) {
		if(!this.handlers.drag.dragging) {
			this.feature = feature;
			this.handlers.drag.activate();
			OpenLayers.Element.addClass(this.map.viewPortDiv, this.displayClass + "Over");
		}
		this.over = true;
	},

	/** マーカ上でマウスが押下されたときの処理
	 * Method: downFeature
	 * Called when the drag handler detects a mouse-down.
	 *
	 * Parameters:
	 * pixel - {<OpenLayers.Pixel>} Location of the mouse event.
	 */
	downFeature: function(pixel) {
		if (this.over) {
			this.lastPixel = pixel;
			this.onStart(this.feature, pixel);
			this.handlers.drag.activate();
			this.handlers.drag.dragging = true;//outFeatureの挙動調整
		}
	},

	/** マウスが移動したときの処理
	 * Method: moveFeature
	 * Called when the drag handler detects a mouse-move.  Also calls the
	 *	   optional onDrag method.
	 * 
	 * Parameters:
	 * pixel - {<OpenLayers.Pixel>} Location of the mouse event.
	 */
	moveFeature: function(pixel) {
		if (this.feature) {
			var px = this.feature.icon.px.add(pixel.x - this.lastPixel.x, pixel.y - this.lastPixel.y);
			this.feature.moveTo(px);
			this.lastPixel = pixel;
			this.onDrag(this.feature, pixel);
		}
	},

	/** マウスの押下が終わったときの処理
	 * Method: upFeature
	 * Called when the drag handler detects a mouse-up.
	 * 
	 * Parameters:
	 * pixel - {<OpenLayers.Pixel>} Location of the mouse event.
	 */
	upFeature: function(pixel) {
		if(!this.over) {
			this.handlers.drag.deactivate();
		}
		this.onComplete(this.feature, pixel);
	},

	/** ドラッグ完了時の処理
	 * Method: doneDragging
	 * Called when the drag handler is done dragging.
	 *
	 * Parameters:
	 * pixel - {<OpenLayers.Pixel>} The last event pixel location.	If this event
	 *	   came from a mouseout, this may not be in the map viewport.
	 */
	doneDragging: function(pixel) {
		this.onComplete(this.feature, pixel);
	},

	/** マウスがマーカから出たときの処理
	 * Method: outFeature
	 * Called when the feature handler detects a mouse-out on a feature.
	 *
	 * Parameters:
	 * feature - {<OpenLayers.Feature.Vector>} The feature that the mouse left.
	 */
	outFeature: function(feature) {
		this.over = false;
		if(!this.handlers.drag.dragging) {
			this.handlers.drag.deactivate();
			OpenLayers.Element.removeClass(
				this.map.viewPortDiv, this.displayClass + "Over"
			);
			this.feature = null;
		}
	},
		
	/** ドラッグキャンセル時の処理
	 * Method: cancel
	 * Called when the drag handler detects a mouse-out (from the map viewport).
	 */
	cancel: function() {
		this.onComplete(this.feature, this.lastPixel);
		this.handlers.drag.deactivate();
		this.over = false;
		this.feature = null;
	},

	/**
	 * Method: setMap
	 * Set the map property for the control and all handlers.
	 *
	 * Parameters: 
	 * map - {<OpenLayers.Map>} The control's map.
	 */
	setMap: function(map) {
		this.handlers.drag.setMap(map);
		OpenLayers.Control.prototype.setMap.apply(this, arguments);
	},
	
	/** クラス名
	 * @final @type String */
	CLASS_NAME: "OpenLayers.Control.DragMarker"
});
/* ======================================================================
    SaigaiTask/Map/Icon.js
   ====================================================================== */

SaigaiTask.Map.Icon = function() {
	this.initialize.apply(this, arguments);
};

SaigaiTask.Map.Icon.prototype = {

	baseURL: null,

	/**
	 * アイコンMap
	 * @type {Object<String, String>} <アイコン名, URL>
	 */
	icon: {

		/**
		 * 追加アイコンを取得するためのURL
		 * @type {String}
		 */
		addIconURL: "/icons/add.png",

		/**
		 * 除外アイコン
		 */
		removeIconURL: "/icons/remove.png",

		/**
		 * 削除アイコン
		 */
		deleteIconURL: "/icons/delete.png",

		/**
		 * 編集アイコン
		 */
		editIconURL: "/icons/edit.png",

		/**
		 * 地図編集アイコン(メモ描画アイコン)
		 */
		mapEditIconURL: "/icons/map_edit.png",

		/**
		 * 元に戻す
		 */
		undoIconURL: "/icons/undo.png",

		/**
		 * やり直す
		 */
		redoIconURL: "/icons/redo.png",

		/**
		 * 地図上の編集アイコン
		 * @type {String}
		 */
		editingIconURL: "/icons/editing.png",

		/**
		 * 地図上の選択アイコン
		 * @type {String}
		 */
		selectingIconURL: "/icons/selecting.png",

		/**
		 * フィーチャ編集時の頂点アイコンを取得するためのURL
		 * @type {String}
		 */
		pointnodeIconURL: "/icons/pointnode.png",

		/** 印刷アイコン */
		printIconURL: "/icons/print.png",

		/** 地図画像出力アイコン */
		downloadMapIconURL: "/icons/map_down.png",

		/** ダウンロードアイコン */
		downloadIconURL: "/icons/download.png",

		/** 範囲アイコン */
		rangeIconURL: "/icons/range.png",

		/** 印刷設定読み込みアイコン */
		folderOpenIconURL: "/icons/folder_open.png",

		/** 閉じるアイコン */
		closeIconURL: "/icons/close.png",

		/** リロードアイコン */
		reloadIconURL: "/icons/reload.png",

		/**
		 * フィーチャ編集時の頂点追加アイコンを取得するためのURL
		 * @type {String}
		 */
		verticeIconURL: "/icons/vertice.png",

		/**
		 * 2画面表示アイコン
		 */
		submapIconURL: "/images/submap.png",

		/**
		 * 同期アイコン
		 */
		syncIconURL: "/images/CircledSync.png",

		/**
		 * マーカーアイコン
		 */
		markerIconURL: "/icons/geosilk/marker.png",

		/**
		 * 新しいウィンドウで開くアイコン
		 * @type {String}
		 */
		newwinIconURL: "/images/newwinicon.gif",

		/**
		 * MGRSアイコン
		 */
		mgrsIconURL: "/icons/mgrs.png",

		/**
		 * 計測アイコン
		 */
		rulerIconURL: "/icons/geosilk/ruler_triangle.png",

		/**
		 * 透明度変更アイコン
		 */
		transparencyURL: "/icons/pen.png"
	},

	initialize: function(baseURL) {
		var me = this;
		if(typeof baseURL!="undefined") {
			me.baseURL = baseURL;
		}
	},

	getURL: function(name) {
		var me = this;
		return me.baseURL + me.icon[name];
	}
};
/* ======================================================================
    SaigaiTask/Map/util/GeoUtil.js
   ====================================================================== */

/**
 * @class SaigaiTask.Map.util.GeoUtil
 * GIS関連のユーティリティクラスです.
 * @static
 * @requires SaigaiTask/Map/util.js
 */
SaigaiTask.Map.util.GeoUtil = {

	/**
	 * 投影法一覧
	 * @type {Object.<String, OpenLayers.Projection>}
	 */
	projection: {

		WGS84: new OpenLayers.Projection("EPSG:4326"),

		GOOGLE: new OpenLayers.Projection("EPSG:900913"),

		/**
		 * UTM zone 52N
		 * 九州と沖縄などを含みます.
		 * http://www.spatialreference.org/ref/epsg/32652/
		 */
		UTM_ZONE_52N: new OpenLayers.Projection("EPSG:32652"),

		/**
		 * UTM zone 53N
		 * 四国、中国地方、近畿、愛知県などを含みます。
		 * http://www.spatialreference.org/ref/epsg/32653/
		 */
		UTM_ZONE_53N: new OpenLayers.Projection("EPSG:32653"),

		/**
		 * UTM zone 54N
		 * 静岡、長野、関東、東北、北海道などを含みます。
		 * http://www.spatialreference.org/ref/epsg/32654/
		 */
		UTM_ZONE_54N: new OpenLayers.Projection("EPSG:32654"),

		/**
		 * UTM zone 55N
		 * 北海道の釧路や択捉島などを含みます。
		 * http://www.spatialreference.org/ref/epsg/32655/
		 */
		UTM_ZONE_55N: new OpenLayers.Projection("EPSG:32655")
	},

	/**
	 * 投影法の境界線一覧(WGS84)
	 * @type {Object.<String, OpenLayers.Bounds>}
	 */
	projectionBounds: {

		WGS84: null,

		GOOGLE: null,

		/**
		 * UTM zone 52N
		 */
		UTM_ZONE_52N: new OpenLayers.Bounds(126.0000, 0.0000, 132.0000, 84.0000),

		/**
		 * UTM zone 53N
		 */
		UTM_ZONE_53N: new OpenLayers.Bounds(132.0000, 0.0000, 138.0000, 84.0000),

		/**
		 * UTM zone 54N
		 */
		UTM_ZONE_54N: new OpenLayers.Bounds(138.0000, 0.0000, 144.0000, 84.0000),

		/**
		 * UTM zone 55N
		 */
		UTM_ZONE_55N: new OpenLayers.Bounds(144.0000, 0.0000, 150.0000, 84.0000)
	},

	/**
	 * OpenLayers.Geometry を指定の投影法に変換します.
	 * 変換結果はgeometry自身に反映されます.
	 * Proj4jsライブラリが必要です.
	 * @param {OpenLayers.Geometry} geometry 変換対象のジオメトリ
	 * @param {OpenLayers.Projection} sourceProj 変換対象の投影法
	 * @param {OpenLayers.Projection} destProj 変換したい投影法
	 */
	transform: function(geometry, sourceProj, destProj) {
		switch(geometry.CLASS_NAME) {
			case "OpenLayers.Geometry.Curve" :
				console.error('transform '+geometry.CLASS_NAME+' is not supported.');
				break;
			case "OpenLayers.Geometry.Point" :
			case "OpenLayers.Geometry.Collection" :
			case "OpenLayers.Geometry.LinearRing" :
				geometry = geometry.transform(sourceProj, destProj);
				break;
			case "OpenLayers.Geometry.LineString" :
			case "OpenLayers.Geometry.Polygon" :
			case "OpenLayers.Geometry.MultiPoint" :
			case "OpenLayers.Geometry.MultiLineString" :
			case "OpenLayers.Geometry.MultiPolygon" :
				var components= geometry.components;
				for(var componentsIdx in components) {
					var component = components[componentsIdx];
					SaigaiTask.Map.util.GeoUtil.transform(component, sourceProj, destProj);
				}
				break;
		}
		return geometry;
	},

	/**
	 * OpenLayers.Geometry をUTMに変換します.
	 * UTMは、52から55までのゾーンに含まれるものまたは近いもののどれかに変換されます.
	 * 変換結果はgeometry自身に反映されます.
	 * @param {OpenLayers.Geometry} geometry 変換対象のジオメトリ
	 * @param {OpenLayers.Projection} sourceProj 変換対象の投影法(optional, default WGS84)
	 * @return {OpenLayers.Projection} 変換後のUTM投影法
	 */
	transform2UTM: function(geometry, sourceProj) {
		var startTime = new Date();

		if(typeof sourceProj=='undefined') {
			sourceProj = SaigaiTask.Map.util.GeoUtil.projection.WGS84;
		}

		// UTM ゾーン設定
		var zones = [{
			proj: SaigaiTask.Map.util.GeoUtil.projection.UTM_ZONE_52N,
			bounds: SaigaiTask.Map.util.GeoUtil.projectionBounds.UTM_ZONE_52N
		}, {
			proj: SaigaiTask.Map.util.GeoUtil.projection.UTM_ZONE_53N,
			bounds: SaigaiTask.Map.util.GeoUtil.projectionBounds.UTM_ZONE_53N
		}, {
			proj: SaigaiTask.Map.util.GeoUtil.projection.UTM_ZONE_54N,
			bounds: SaigaiTask.Map.util.GeoUtil.projectionBounds.UTM_ZONE_54N
		}, {
			proj: SaigaiTask.Map.util.GeoUtil.projection.UTM_ZONE_55N,
			bounds: SaigaiTask.Map.util.GeoUtil.projectionBounds.UTM_ZONE_55N
		}];

		// 重心を含むUTMゾーンを調べる
		// なければ距離の近いものを取得する
		var destProj = null;
		var mindistance = null;
		var centroid = geometry.getCentroid(); // 重心
		for(var zonesIdx in zones) {
			var zone = zones[zonesIdx];
			var contain = zone.bounds.contains(centroid.x, centroid.y);
			if(contain) {
				destProj = zone.proj;
				break;
			}
			var distance = centroid.distanceTo(zone.bounds.toGeometry());
			if(mindistance==null||mindistance>distance) {
				mindistance = distance;
				destProj = zone.proj;
			}
		}

		SaigaiTask.Map.util.GeoUtil.transform(geometry, sourceProj, destProj);
		var endTime = new Date();
		console.log("transform2UTM: "+(endTime-startTime)/1000+lang.__("Second"));
		return destProj;
	},

	/**
	 * WKT配列のジオメトリを結合してフィーチャを取得します.
	 * JSTSライブラリが必要です.
	 * @param {Array<String>} wkts WKT文字列配列
	 * @return {OpenLayers.Feature.Vector} ベクタフィーチャ. 無い場合は null
	 */
	union: function(wkts) {
		var wktFormat = new OpenLayers.Format.WKT();
		var parser = new jsts.io.OpenLayersParser();
		var unionGeom = null;
		var utmProj = null;
		for(var wktsIdx in wkts) {
			var wkt = wkts[wktsIdx];
			var feature = wktFormat.read(wkt);

			utmProj = SaigaiTask.Map.util.GeoUtil.transform2UTM(feature.geometry);
			var jstsGeom = parser.read(feature.geometry);
			if(unionGeom==null) unionGeom = jstsGeom;
			else unionGeom = unionGeom.union(jstsGeom);
		}
		if(unionGeom!=null) {
			var olGeom = parser.write(unionGeom);
			var feature = new OpenLayers.Feature.Vector(olGeom);
			SaigaiTask.Map.util.GeoUtil.transform(feature.geometry, utmProj, SaigaiTask.Map.util.GeoUtil.projection.WGS84);
			return feature;
		}
		return null;
	},

	/**
	 * WKT配列をバッファ計算してフィーチャ配列で取得します.
	 * JSTSライブラリが必要です.
	 * @param {Array<String>} wkts WKT文字列配列
	 * @param {Number} buffer バッファ（メートル）
	 * @return {Array.<OpenLayers.Feature.Vector>} ベクタフィーチャ配列.無い場合は要素数0の配列を返す.
	 */
	buffer: function(wkts, buffer) {
		var wktFormat = new OpenLayers.Format.WKT();
		var parser = new jsts.io.OpenLayersParser();
		var features = [];
		for(var wktsIdx in wkts) {
			var wkt = wkts[wktsIdx];
			var feature = wktFormat.read(wkt);

			var utmProj = SaigaiTask.Map.util.GeoUtil.transform2UTM(feature.geometry);
			var jstsGeom = parser.read(feature.geometry);
			jstsGeom = jstsGeom.buffer(buffer); // buffered by meter unit.
			console.log("utmProj");
			console.log(utmProj);

			var olGeom = parser.write(jstsGeom);
			var bufferedFeature = new OpenLayers.Feature.Vector(olGeom);
			SaigaiTask.Map.util.GeoUtil.transform(bufferedFeature.geometry, utmProj, SaigaiTask.Map.util.GeoUtil.projection.WGS84);
			features.push(bufferedFeature);
		}
		return features;
	}
};
/* ======================================================================
    SaigaiTask/Map/view/ContentsSearch.js
   ====================================================================== */


/**
 * 登録情報を検索するビューです.
 * @class SaigaiTask.Map.view.ContentsSearch
 * @param {SaigaiTask.Map} map
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.ContentsSearch = function(map) {
	this.map = map;
};
SaigaiTask.Map.view.ContentsSearch.prototype = {

	/**
	 * SaigaiTask.Mapオブジェクト
	 * @type {SaigaiTask.Map}
	 */
	map: null,

	/**
	 * 登録情報検索ウィジェットのコンテナです.
	 * @type {Ext.container.Container}
	 */
	container: null,

	/**
	 * 登録情報検索フォームのビュー
	 * @type {SaigaiTask.Map.view.SpatialSearchForm}
	 */
	spatialSearchFrom: null,

	/**
	 * 登録情報検索結果のビュー
	 * @type {SaigaiTask.Map.view.SpatialSearchResult}
	 */
	spatialSearchResult: null,

	/**
	 * 検索範囲レイヤー
	 * @type {OpenLayers.Layer.Vector}
	 */
	rangeLayer: null,

	/**
	 * 検索結果レイヤー
	 * @type {OpenLayers.Layer.Vector}
	 */
	resultLayer: null,

	/**
	 * 全検索結果
	 * @type {SaigaiTask.Map.model.SearchResult}
	 */
	searchResult: null,

	/**
	 * 登録情報検索ウィジェットを取得します
	 * @param {Object<String, *>} options
	 * @param {Object<String, *>} options.searchFormOptions {@link SaigaiTask.Map.view.SpatialSearchForm #get(options)} の引数options
	 */
	get: function(options) {
		var me = this;
		var searchFormOptions = options.searchForm;

		// 検索フォームのパネルを定義
		var spatialSearchForm = new SaigaiTask.Map.view.SpatialSearchForm();
		me.spatialSearchFrom = spatialSearchForm;
		var form = spatialSearchForm.get(searchFormOptions);

		// 検索結果のグリッドを定義
		var spatialSearchResult = new SaigaiTask.Map.view.SpatialSearchResult();
		me.spatialSearchResult = spatialSearchResult;
		var resultView = spatialSearchResult.grid;
		resultView.title = lang.__('Search result');
		resultView.collapsible = false;
		resultView.margin = '5 0 0 0';
		resultView.autoSize = true;
		var store = spatialSearchResult.grid.store;

		// 検索範囲レイヤを更新する関数を定義
		var reloadRangeLayer = function(){
			var wkts = [];
			var values = spatialSearchForm.getValues();
			var wkt = me.map.api.getContentsSearchRangeWKT(values);
			if(typeof wkt!="undefined" && wkt!=null) {
				wkts.push(wkt);
			}
			me.loadRangeLayer(wkts);
		};
		reloadRangeLayer();

		// 検索結果レイヤの検索メソッドを定義
		var searchForMap = function() {
			// 検索範囲を更新する
			reloadRangeLayer();

			// 検索リクエストを送信
			me.searchResult = null;
			var limit = 0;
			var offset = 0;
			form.submit({
				params: {
					mid: searchFormOptions.searchButtonInfo.mid,
					limit: limit,
					offset: offset
				}, success: function(form, action) {
					var result = action.result;
					var spatialSearch = new SaigaiTask.Map.control.SpatialSearch();
					var searchResult = spatialSearch.getSearchResult(result);

					// 地図に検索結果レイヤを追加する
					me.loadResultLayer(searchResult);
					me.searchResult = searchResult;
				}
			});
		};

		// 検索結果グリッドの検索メソッドを定義
		var searchForGrid = function(limit, offset) {
			// ロード中の表示
			resultView.setLoading(true);

			// collapsed の場合は表示する
			if(resultView.collapsed) {
				resultView.toggleCollapse();
			}

			// ページサイズを更新
			store.pageSize = limit;

			// 検索リクエストを送信
			form.submit({
				params: {
					mid: searchFormOptions.searchButtonInfo.mid,
					limit: limit,
					offset: offset
				}, success: function(form, action) {
					var result = action.result;
					var spatialSearch = new SaigaiTask.Map.control.SpatialSearch();
					var searchResult = spatialSearch.getSearchResult(result);
					// 検索結果をグリッドにロードする
					spatialSearchResult.load(searchResult);

					// ロード中の非表示
					resultView.setLoading(false);
				}
			});
		};

		// 検索ボタンイベントを定義
		form.on('search', function(){
			// 検索範囲、検索結果をレイヤに更新
			searchForMap();

			// 取得数、オフセット指定で検索
			var limit = spatialSearchResult.limitCombo.value;
			var offset = 0;
			searchForGrid(limit, offset);
		});

		// ページングのイベントを定義
		var pagingTbar = spatialSearchResult.pagingTbar;
		pagingTbar.on('movefirst', function() {
			store.currentPage = 1;
			var limit = spatialSearchResult.limitCombo.value;
			var offset = (store.currentPage-1)*store.pageSize;
			searchForGrid(limit, offset);
		});
		pagingTbar.on('movelast', function() {
			var total = pagingTbar.store.totalCount;
			var limit = pagingTbar.store.pageSize;
			store.currentPage = Math.ceil(total/limit);
			var offset = (store.currentPage-1)*store.pageSize;
			searchForGrid(limit, offset);
		});
		pagingTbar.on('movenext', function() {
			store.currentPage++;
			var limit = spatialSearchResult.limitCombo.value;
			var offset = (store.currentPage-1)*store.pageSize;
			searchForGrid(limit, offset);
		});
		pagingTbar.on('moveprevious', function() {
			store.currentPage--;
			var limit = spatialSearchResult.limitCombo.value;
			var offset = (store.currentPage-1)*store.pageSize;
			searchForGrid(limit, offset);
		});

		// グリッドのイベントを定義
		spatialSearchResult.grid.on('popup', function(layerId, featureId){
			if(me.map) {
				me.map.getContent(layerId, featureId);
			}
		});

		// 組み合わせる
		form.region = "north";
		resultView.region = "center";
		var panel = Ext.create("Ext.container.Container", {
			width: 500,
			height: 500,
			autoScroll: true,
			layout: {
				type: 'border'
				//align: 'stretch'
			},
			items: [form, resultView]
		});

		// 検索を実行する
		//form.doSearch();

		this.container = panel;

		return panel;
	},

	/**
	 * 登録情報検索ウィンドウを表示します.
	 * @param {Object<String, *>} options
	 */
	show: function(options) {
		var me = this;
		var map = me.map;
		var container = me.get(options);

		// フッターツールバー
		var fbar = null;
		fbar = map.events.triggerEvent(map.EventType.beforeshowcontentsearchview, {
			contentSearchView: me
		});

		// ウィンドウを定義する
		var win = Ext.create("Ext.window.Window", {
			title: lang.__('Registration info Search'),
			collapsible: true,
			resizable: true,
			width: 500,
			maxWidth: document.body.clientWidth,
			maxHeight: document.body.clientHeight,
			layout: 'fit',
			items: [container],
			fbar: fbar,
			buttonAlign: "center"
		});

		win.on('destroy', function(){
			me.onDestroy();
		});

		window.win = win;

		win.show();
		// ウィンドウ左下に表示
		win.alignTo(document, "bl", [0, -win.getHeight()-20]);
	},

	/**
	 * 検索範囲を検索範囲レイヤに反映します.
	 * @param {Array<String>} wkts 検索範囲のWKT文字列配列
	 */
	loadRangeLayer: function(wkts) {
		var me = this;
		var olmap = me.map.map;

		// 定義されていなければ生成する
		if(!me.rangeLayer) {
			me.rangeLayer = new OpenLayers.Layer.Vector(lang.__("Search range"));
		}

		var rangeLayer = me.rangeLayer;

		// 一度、非表示にする
		if(olmap.getLayer(rangeLayer.id)) {
			olmap.removeLayer(rangeLayer);
		}

		// WKTからフィーチャを作成する
		features = [];
		var wktFormat = new OpenLayers.Format.WKT();
		for(var wktsIdx in wkts) {
			var wkt = wkts[wktsIdx];
			var feature = wktFormat.read(wkt);
			// 投影法を変換
			feature.geometry.transform(new OpenLayers.Projection("EPSG:4326"), olmap.getProjectionObject());
			features.push(feature);
		}

		// フィーチャを更新する
		rangeLayer.removeAllFeatures();
		rangeLayer.addFeatures(features);

		// データがあれば表示する
		if(0<features.length) {
			olmap.addLayer(rangeLayer);
		}
	},

	/**
	 * 検索結果を検索結果レイヤに反映します.
	 * @param {SaigaiTask.Map.model.SearchResult} searchResult 検索結果オブジェクト
	 * @param {Array<SaigaiTask.Map.model.Feature>} searchResult.features 検索結果のフィーチャ配列
	 */
	loadResultLayer: function(searchResult) {
		var me = this;
		var map = me.map;
		var olmap = me.map.map;

		// 定義されていなければ生成する
		if(!me.resultLayer) {
			me.resultLayer = new OpenLayers.Layer.Vector(lang.__("Search result"));
		}

		var resultLayer = me.resultLayer;

		// スタイルを更新
		var style = {
			// 塗りつぶしの設定
			fillColor: "white",
			fillOpacity: 0.4,
			// ラインの設定
			strokeColor: "#0099ee",
			strokeOpacity: 1,
			strokeWidth: 5,
			strokeLinecap: "round", // butt, round, square
			strokeDashstyle: "solid", // dot, dash, dashdot, longdash, longdashdot, solid
			// 図の設定
			externalGraphic: map.icon.getURL("editingIconURL"),
			graphicWidth: 19,
			graphicHeight: 32,
			graphicXOffset: -9,
			graphicYOffset: -32,
			graphicOpacity: 1
		};
		resultLayer.styleMap.styles['default'].defaultStyle = style;


		// 一度、非表示にする
		if(olmap.getLayer(resultLayer.id)) {
			olmap.removeLayer(resultLayer);
		}

		// フィーチャを更新する
		resultLayer.removeAllFeatures();
		var features = [];
		for(var searchResultFeaturesIdx in searchResult.features) {
			var searchResultFeature = searchResult.features[searchResultFeaturesIdx];
			var geometry = OpenLayers.Geometry.fromWKT(searchResultFeature.geometry.wkt);
			var feature = new OpenLayers.Feature.Vector(geometry);
			features.push(feature);
		}
		resultLayer.addFeatures(features);

		// データがあれば表示する
		if(0<features.length) {
			olmap.addLayer(resultLayer);
		}
	},

	/**
	 * 登録情報検索の終了処理です.
	 */
	onDestroy: function() {
		var me = this;
		var olmap = me.map.map;

		// 検索範囲レイヤーを消去する
		var rangeLayer = me.rangeLayer;
		if(rangeLayer) {
			if(olmap.getLayer(rangeLayer.id)) {
				olmap.removeLayer(rangeLayer);
			}
		}

		// 検索結果レイヤーを消去する
		var resultLayer = me.resultLayer;
		if(resultLayer) {
			if(olmap.getLayer(resultLayer.id)) {
				olmap.removeLayer(resultLayer);
			}
		}
	}
};
/* ======================================================================
    SaigaiTask/Map/Layer/AttrInfo.js
   ====================================================================== */

/**
 * 属性情報のクラスです.
 * @requires SaigaiTask/Map/Layer.js
 */
SaigaiTask.Map.Layer.AttrInfo = new OpenLayers.Class({

	attrId: null,
	dataExp: null,
	dataType: null,
	dataTypeId: null,
	dataTypeName: null,
	highlight: false,
	length: null,
	maxLength: null,
	name: null,
	nullable: null,
	status: null,

	/**
	 * 登録時時刻アップデートフラグ
	 * 登録時に現在時刻を自動で設定する
	 * @type {Boolean}
	 */
	updateInserted: false,

	/**
	 * 更新時時刻アップデートフラグ
	 * 更新時に現在時刻を自動で設定する
	 * @type {Boolean}
	 */
	updateModified: false,

	/**
	 * dataType が文字列の場合に、
	 * 住所ボタンを表示するかどうかのフラグ
	 * @type {Boolean}
	 */
	addAddressButton: false,

	/**
	 * ポップアップ時のツールバーボタンの設定
	 * URLはこの属性値が使われます.
	 * @type {Object}
	 */
	buttonData: null,
	
	/**
	 * コンストラクタ
	 * @param options
	 */
	initialize: function(options) {
		this.children = [];
		this.params = [];
		// オプションをコピー
		OpenLayers.Util.extend(this, options);

		this.searchable = this.visibility;
	}
});

/** 閲覧可、編集可 */
SaigaiTask.Map.Layer.AttrInfo.STATUS_DEFAULT = 0;
/** 閲覧可、編集不可 */
SaigaiTask.Map.Layer.AttrInfo.STATUS_READONLY = 1;
/** 閲覧不可、編集可？ */
SaigaiTask.Map.Layer.AttrInfo.STATUS_SEARCHHIDE = -1;
SaigaiTask.Map.Layer.AttrInfo.STATUS_DELETED = -100;
/* ======================================================================
    SaigaiTask/Map/view/LegendPanel.js
   ====================================================================== */


/**
 * @class SaigaiTask.Map.view.LengendPanel
 * 凡例ツリーパネルのビューです.
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.LegendPanel = function() {
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.LegendPanel.prototype = {

	/**
	 * SaigaiTask.Mapオブジェクト
	 * @type {SaigaiTask.Map}
	 */
	map: null,

	/**
	 * 凡例ツリーパネル
	 * @type {Ext.tree.Panel}
	 */
	tree: null,

	/**
	 * フッターツールバー
	 * @type {Ext.toolbar.Toolbar}
	 */
	fbar: null,

	/**
	 * 地図追加ボタン
	 */
	addMapBtn: null,

	initialize: function(map) {
		var me = this;
		me.map = map;

		var store = Ext.create('Ext.data.TreeStore', {
			expanded: true
		});

		var tree = Ext.create('Ext.tree.Panel', {
			store: store,
			rootVisible: false,
			title: lang.__('Legend'),
			// maxWidth: 300, maxHeight: 200,
			width: 200, // height: 200,
			border: true,
			useArrows: true,
			scroll: false,
			draggable: true,
			collapsible: true,
			resizable: true,
			resizeHandles: "e",
			collapsed: me.map.options.collapsed,
			viewConfig: {
				style: {
					overflow: 'auto'
				}
			},
			listeners: {
				afterrender: function(panel, eOps) {
					obj = $(panel.getEl().dom);

					// Z-indexを設定する
					panel.getEl().setStyle('z-index','1010');

					// 各イベントのバブリングを抑止する
					obj.click(function(){ return false; });
					obj.dblclick(function(){ return false; });
					obj.children().get(2).style.overflow = 'auto';
				},
				viewready: function(panel, eOps) {
					console.log("viewready");
					// ツールバーアイテム
					var barItems = [];

					// 凡例のアイテムを追加
					// getRootNode() は パネルを作っておかないと null が返るため、ここで行う.
					var rootNode = store.getRootNode();
					// ノードを追加時に、チェックボックスに戻ってしまうためラジオに変換する
					rootNode.on("append", function(thisNode, node, index, eOpts) {me.changeViewCheckbox2Radio(thisNode);});
					rootNode.on("insert", function(thisNode, node, refNode, eOpts) {me.changeViewCheckbox2Radio(thisNode);});

					for(var ecommapsKey in map.ecommaps) {
						var ecommap = map.ecommaps[ecommapsKey];
						// 凡例ウィンドウに表示しないレイヤをレイヤIDで非表示にする
						var excludesLayerIds = map.excludesLayerIdsFromLegendWindow; // 凡例ウィンドウに表示しないレイヤのレイヤIDを設定する
						for(var idx in excludesLayerIds) {
							var excludesLayerId = excludesLayerIds[idx];
							var excludesLayerInfo = ecommap.layerInfoStore[excludesLayerId];
							if(typeof excludesLayerInfo!="undefined") {
								excludesLayerInfo.visibility = false;
							}
						}
						// すべてのレイヤを凡例の対象にする
						for(var layerInfoTreeKey in ecommap.layerInfoTree) {
							var layerInfo = ecommap.layerInfoTree[layerInfoTreeKey];
							var node = me.createTreeNode(rootNode, layerInfo);
							if(node!=null) {
								rootNode.appendChild(node);
								me.changeViewCheckbox2Radio(node);
								var layer = layerInfo.layer;
								if(layer!=null && typeof layer.refreshParams=="function") {
									layer.refreshParams();
								}
							}
						}
						// クリアリングハウスのURLが指定されていれば、
						// 地図追加ボタンを配置する
						if(!!ecommap.cswURL && !me.addMapBtn) {
							me.addMapBtn = {
								text: lang.__('Add map'),
								icon: map.icon.getURL("addIconURL"),
								handler: function() {
									outermap_select();
								}
							};
							barItems.push(me.addMapBtn);
						}
					}

					// ツールバー
					var bar = null;
					if(0<barItems.length) {
						me.addTbarItems(barItems);
					}
				},
				checkchange: function(node, checked, eOpts) {
					/**
					 * 各ノードで行うチェックボックスの処理
					 */
					var onCheckChange = function(node, checked, option) {
						if(node!=null) {
							// チェックボックスでレイヤの表示を切り替える
							var layerInfo = node.raw.layerInfo;
							if(typeof layerInfo!="undefined") {
								// 凡例別の表示切替対応
								if(!!node.raw && !!node.raw.isRuleNode) {
									// チェックしたレイヤの全ルールノードのチェック状態を取得する
									var ruleNodes = node.parentNode.childNodes;
									var checkedMap = {};
									for(var ruleNodesIdx in ruleNodes) {
										var ruleNode = ruleNodes[ruleNodesIdx];
										var ruleId = ruleNode.raw.rule.ruleId;
										checkedMap[ruleId] = ruleNode.data.checked;
									}

									// ルールノードのチェック状態をLayerInfoに反映する
									for(var legendrulesIdx in layerInfo.legendrules) {
										var rule = layerInfo.legendrules[legendrulesIdx];
										rule.visibility = rule.searchable = checkedMap[rule.ruleId];
									}

									// レイヤ情報のパラメータを更新
									layerInfo.updateRuleParam();
								}
								// 通常の凡例
								else {
									layerInfo.visibility = checked;
									layerInfo.searchable = checked;
								}
								var recursive = function(n) {
									// チェックボックスを利用している場合のみ親のチェック状態を設定
									if(n.get("checked")!=null) {
										if(layerInfo.radio!=null) { // 親ノードにラジオの指定があるなら
											// ON の場合
											if(checked) {
												// ON の兄弟がいるならなにもしない
												if(n.existOnBrother()) return;
												// ONになっている兄弟がいなければ
												// ラジオの場合は最初のノードだけがONになる
												else {
													var brothers = node.childNodes;
													for(var idx in brothers) {
														var brother = brothers[idx];
														if(brother.get("checked")!=null) {
															// 最初のチェックボックスノード以外は処理しない
															if(n!=brother) return;
															else break;
														}
													}
												}
											}
											// OFF の場合は、チェックを外さないので何も処理しない
											else return;
										}
										n.set("checked", checked);
										me.changeViewCheckbox2Radio(n);
										onCheckChange(n, checked, option);
									}
								};
								if(!option==false) {
									if(option.doChildren) {
										// チェック状態の取得
										var childIsRuleNode = false;
										for(var childNodesIdx in node.childNodes) {
											var childNode = node.childNodes[childNodesIdx];
											if(!!childNode.raw)
												childIsRuleNode = !!childNode.raw.isRuleNode;
										}

										// SLD表示ルールを制御するノードの場合
										if(childIsRuleNode) {
											// 一部の子ノードがすでにチェック済みなら、子ノードのチェック状態は変えない
											// 子ノードの全ON/OFF処理を無効化する
											if(!!layerInfo.params && layerInfo.params.rule!=null) {
												return;
											}
										}

										// チェック状態をすべての子ノードに設定
										node.eachChild(recursive);
									}
									if(option.doParent) {
										// チェック状態をすべての親ノードに設定
										recursive(node.parentNode);
									}
								}
								// ラジオの場合は他の兄弟をOFFにする
								var isRadio = layerInfo.parent!=null && layerInfo.parent.radio!=null;
								if(checked && isRadio) {
									var brothers = node.parentNode.childNodes;
									for(var idx in brothers) {
										if(node!=brothers[idx]) {
											var brother = brothers[idx];
											if(brother.get("checked")!=null) {
												brother.set("checked", false);
												me.changeViewCheckbox2Radio(brother);
												onCheckChange(brother, false);
											}
										}
									}
								}
							}
						}
					};
					// ラジオの場合、OFFさせない
					var isRadio = typeof node.raw.radio!="undefined" && node.raw.radio!=null;
					if(isRadio) {
						me.changeViewCheckbox2Radio(node);
						if(checked==false) {
							node.set("checked", true);
							me.changeViewCheckbox2Radio(node);
							return;
						}
					}
					onCheckChange(node, checked, {doChildren: true});
					// チェックを入れた場合は親ノードのチェックをすべて入れる
					if(checked==true) {
						onCheckChange(node, checked, {doParent: true});
					}
					// レイヤの表示状態を変更
					var refreshLayerInfos = [node.raw.layerInfo];
					while(0<refreshLayerInfos.length) {
						var layerInfo = refreshLayerInfos.pop();
						var layer = layerInfo.getLayer();
						// レイヤ情報にレイヤが見つからない場合は、下位のレイヤ情報を検索する
						if(!layer) {
							for(var idx in layerInfo.children) {
								refreshLayerInfos.push(layerInfo.children[idx]);
							}
						}
						// レイヤがある場合
						else {
							// レイヤの refreshParam を呼ぶ
							if(typeof layer.refreshParams=="function") {
								layer.refreshParams();
							}
							else {
								layer.setVisibility(checked);
							}
						}
					}
					map.events.triggerEvent("legendcheckchange");
				},
				afteritemexpand: function(node, index, item, eOpts) {
					me.changeViewCheckbox2Radio(node);
				},
				itemexpand: function(node, eOpts) { me.onChangeExpanded(node, eOpts); },
				itemcollapse: function(node, eOpts) { me.onChangeExpanded(node, eOpts); },
				itemcontextmenu: function(view, record, htmlItem, index, e, eOpts) {
					var layerInfo = record.raw.layerInfo;
					if(typeof layerInfo!="undefined") {
						var contextmenu = map.components.contextmenu;
						if(typeof contextmenu!="undefined") {
							e.stopEvent();
							var option = {
								tree: tree,
								record: record,
								layerInfo: layerInfo,
								addContentsMenu: true,
								addContentsMenuLayerInfos: [layerInfo],
								deleteLayerMenu: layerInfo.isDeletableSessionExternalMapLayer(),
								transparencyLayerMenu: SaigaiTask.Map.Layer.Type.isOverlayLayerType(layerInfo.type) || [
									SaigaiTask.Map.Layer.Type.REFERENCE,
									SaigaiTask.Map.Layer.Type.REFERENCE_WMS,
									SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS,
									SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS_LAYERS,
									SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_XYZ
									].includes(layerInfo.type)
							};
							contextmenu.showMenu(e.xy[0], e.xy[1], option);
						}
					}
				}
			}
		});
		me.tree = tree;

		map.events.triggerEvent("legendinitialize", {
			legend: me
		});
	},

	/**
	 * ツールバーに追加する.
	 * @params {Ext.Component[]} items
	 */
	addTbarItems: function(items) {
		var me = this;
		if(!!me.fbar) {
			me.fbar.add(items);
		}
		else {
			bar = me.fbar = Ext.create('Ext.toolbar.Toolbar', {
				items: items,
				dock: "bottom"
			});
			me.tree.addDocked(bar);
		}
	},

	onChangeExpanded: function(node, eOpts) {
		var me = this;
		var map = me.map;
		me.changeViewCheckbox2Radio(node);
		// 凡例の畳み込み情報を保存する
		var expanded = node.isExpanded();
		var layerInfo = node.raw.layerInfo;
		layerInfo.expanded = expanded;
		map.events.triggerEvent("legenditemexpanded");
	},

	/**
	 * レイヤ情報から凡例ツリーのノードを生成する.
	 * @param parentNode 親ノード
	 * @param layerInfo レイヤ情報
	 * @returns 凡例ツリーのノード 除く場合はnullを返す
	 */
	createTreeNode: function(parentNode, layerInfo) {

		var me = this;
		var map = me.map;
		var ecommap = layerInfo.ecommap;

		// 凡例ウィンドウに表示しないレイヤをレイヤIDで取り除く
		var excludesLayerIds = map.excludesLayerIdsFromLegendWindow; // 凡例ウィンドウに表示しないレイヤのレイヤIDを設定する
		if($.inArray(layerInfo.layerId, excludesLayerIds)!=-1) {
			return null;
		}
		// レイヤ種別で取り除く
		if(ecommap!=null) {
			var excludesLayerTypes = SaigaiTask.Map.Layer.Type.getBaseLayerTypes();
			if($.inArray(layerInfo.type, excludesLayerTypes)!=-1) {
				return null;
			}
		}

		// ノードの設定
		var nodeConfig = {};
		nodeConfig.expanded = layerInfo.expanded;
		nodeConfig.text = layerInfo.name;
		if(!!layerInfo.loaderror) nodeConfig.text = lang.__("[Read error]")+nodeConfig.text; // for extlayer
		nodeConfig.layerInfo = layerInfo;


		// 内部ノード
		if(0<layerInfo.children.length) {
			nodeConfig.checked = layerInfo.visibility;
			nodeConfig.children = [];
			var node = parentNode.createNode(nodeConfig);
			node.raw = nodeConfig;
			if(ecommap!=null) {
				// 凡例画像を取得できるか確認
				var legendUrl = ecommap.ecommapURL+'/legend?WIDTH=44&HEIGHT=32&cid='+ecommap.mapInfo.communityId+'&mid='+ecommap.mapInfo.mapId+'&layer='+layerInfo.layerId+'&SCALE=1000';
				var img = new Image();
				//img.onerror = function() {alert("image load error!");}
				img.onload = function() {
					// 先頭に凡例画像を追加
					node.insertChild(0, node.createNode({
						icon: legendUrl,
						leaf: true
					}));
				}
				img.src = legendUrl;
			}
			for(var childLayerInfosKey in layerInfo.children) {
				var childLayerInfo = layerInfo.children[childLayerInfosKey];
				var childNode = this.createTreeNode(node, childLayerInfo);
				if(childNode!=null) {
					node.appendChild(childNode);
				}
			}
			return node;
		}
		// 葉ノード
		else {
			// 子ノードの設定
			if(layerInfo.type!=SaigaiTask.Map.Layer.Type.LOCAL_GROUP) {
				//
				nodeConfig.iconCls = 'no-icon';
				nodeConfig.checked = layerInfo.visibility;
				// ラジオ化
				if(layerInfo.parent!=null) {
					if(layerInfo.parent.radio!=null) {
						nodeConfig.radio = layerInfo.parent.radio;
						nodeConfig.id = layerInfo.layerId;
					}
				}
				var node = parentNode.createNode(nodeConfig);
				node.raw = nodeConfig;
				if(nodeConfig.radio!=null) {
					// すでにONの兄弟がいれば、OFFにしておく
					node.existOnBrother = function() {
						var existOnBrother = false;
						for(var idx in parentNode.childNodes) {
							if(parentNode.childNodes[idx])
							var brother = parentNode.childNodes[idx];
							if(brother.get("checked")==true) {
								existOnBrother = true;
								break;
							}
						}
						return existOnBrother;
					}
					if(node.existOnBrother()) {
						node.set("checked", false);
						layerInfo.visibility = false;
						layerInfo.searchable = false;
						var layer = layerInfo.getLayer();
						layer.refreshParams();
					}
				}
				// 凡例画像
				if(ecommap!=null){
					// 登録情報レイヤで属性による描画切替が２つ以上ある場合
					if(layerInfo.type==SaigaiTask.Map.Layer.Type.LOCAL
							&& !!layerInfo.legendrules && 2<=layerInfo.legendrules.length) {
						var iconHeight = 32;
						for(var legendrulesIdx in layerInfo.legendrules) {
							// ruleNode 生成
							var rule = layerInfo.legendrules[legendrulesIdx];
							var ruleNodeConfig = {
								cls: "legendpanel-legendrule-node",
								text: rule.title,
								checked: rule.visibility,
								icon: ecommap.ecommapURL+'/legend?WIDTH=44&HEIGHT='+iconHeight+'&cid='+ecommap.mapInfo.communityId+'&mid='+ecommap.mapInfo.mapId+'&layer='+layerInfo.layerId+'&SCALE=1000&'+new Date().getTime()+"&rule="+layerInfo.layerId+":"+rule.ruleId,
								leaf: true
							};
							ruleNodeConfig.layerInfo = layerInfo;
							ruleNodeConfig.isRuleNode = true;
							ruleNodeConfig.rule = rule;
							var ruleNode = node.createNode(ruleNodeConfig);
							ruleNode.raw = ruleNodeConfig;

							// ノード情報を記録
							rule.node = ruleNode;

							// ノード追加
							node.insertChild(legendrulesIdx, ruleNode);
						}
					}
					// 登録情報レイヤの凡例画像ノードを追加
					else if(layerInfo.type==SaigaiTask.Map.Layer.Type.LOCAL
							|| layerInfo.type == SaigaiTask.Map.Layer.Type.REFERENCE) {
						node.insertChild(0, node.createNode({
							icon: ecommap.ecommapURL+'/legend?WIDTH=44&HEIGHT=32&cid='+ecommap.mapInfo.communityId+'&mid='+ecommap.mapInfo.mapId+'&layer='+layerInfo.layerId+'&SCALE=1000&'+new Date().getTime(),
							leaf: true
						}));
					}
					// 外部地図レイヤの凡例画像ノードを追加
					else if (layerInfo.type == SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS_LAYERS) {
						var url = layerInfo.wmsLegendURL;

						// 親のwmsLegendURL は GetLegendGraphic になっているはず
						if (!url && layerInfo.parent) {
							url = layerInfo.parent.wmsLegendURL;
							if(0<url.length) url += '&REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&WIDTH=44&HEIGHT=32&layer=' + layerInfo.featuretypeId+'&'+new Date().getTime();
						}

						// URLがある場合
						if(!!url && 0<url.length) {
							// 認証情報
							if(layerInfo.wmsproxy != null){
								if (layerInfo.wmsproxy != 0 && url.indexOf("http") == 0) {
									var page_url = SaigaiTask.PageURL.getUrl();
									// Proxy用のActionに飛ばす
									url = page_url.substr(0, page_url.indexOf("/page/") + 6) + "map/externalWmsAuth/?url=" + encodeURIComponent(url) + "&externalmapdatainfoid="+layerInfo.wmsproxy + "&metadataid="+layerInfo.metadataid;
								}
							}

							node.insertChild(0, node.createNode({
								icon: url,
								leaf: true
							}));
						}
					}
					// ArcGIS用の凡例画像
					else if(layerInfo.type == SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_ARCGIS_LAYERS){
						var url = layerInfo.wmsLegendURL;
						if (!url && layerInfo.parent)
							url = layerInfo.parent.wmsLegendURL;
						if (url){
							$.ajax({
								url : url + "&f=json",
								dataType : "json",
								data : this.param,
								type : "POST",
								contentType: "application/x-www-form-urlencoded; charset=UTF-8",
								success : function(data, dataType){
									var legendURL = "";
									if('layers' in data){
										var j_layers = data.layers;
										for(var i = 0; i < j_layers.length; i++){
											if("legend" in j_layers[i]){
												for(var j = 0; j < j_layers[i].legend.length; j++){
													if("imageData" in j_layers[i].legend[j]){
														node.insertChild(0, node.createNode({
															icon: "data:image/png;base64," + j_layers[i].legend[j].imageData,
															text: j_layers[i].legend[j].label,
															leaf: true
														}));
													}
												}
											}
										}
									}
								},
								error : function(XMLHttpRequest, textStatus, errorThrown){
									console.log("ArcGIS Legend ImageData error");
								}
							});
						}
					}
					// 凡例画像がない場合はノードを追加しない
					else {
						console.log("LegendPanel is Else");
						node.leaf = true;
					}
				}
			}
			return node;
		}

		return null;
	},

	/**
	 * (ExtJSのラジオボタン画像を指定している)独自のClassを追加することで
	 * チェックボックスをラジオボタンの見た目に変更する.
	 * @param {Ext.data.NodeInterface} node
	 */
	changeViewCheckbox2Radio: function(node) {
		var me = this;
		if(!!node.raw && node.raw.radio!=null) {
			view = me.tree.getView()
			var elm = Ext.get(view.getNode(node));
			if(elm!=null) {
				elm.select(".x-tree-checkbox").addCls("x-tree-radio");
			}
		}

		if(node.childNodes!=null) {
			for(var idx in node.childNodes) {
				var child = node.childNodes[idx];
				me.changeViewCheckbox2Radio(child);
			}
		}
	}

};
/* ======================================================================
    SaigaiTask/Map/view/ListPopup.js
   ====================================================================== */

/**
 * 検索結果リストをポップアップ表示するクラスです.
 * @class SaigaiTask.Map.view.ListPopup
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.ListPopup =  new OpenLayers.Class(SaigaiTask.Map.view.Popup, {
	stmap: null,

	initialize: function(stmap) {
		this.stmap = stmap;
	},

	show: function(center,bbox,result, pinned) {
		var me = this;
		var stmap = me.stmap;
		// result からデータを作成する
		var count = result[0][0];
		var rows = result[1];
		var dataMapList = new Array();
		var layerInfoCache = {};
		for(var idx=0; idx<rows.length; idx++){
			var layerId = rows[idx][0];
			var featureId = rows[idx][1];
			var geom = rows[idx][2];
			var firstAttr = rows[idx][3][0];
			// データ
			var dataMap = new Array();
			// レイヤ名
			var layerInfo = layerInfoCache[layerId];
			if(layerInfo==null) {
				layerInfo = stmap.getLayerInfo(layerId);
				layerInfoCache[layerId] = layerInfo;
			}
			dataMap[lang.__('Layer name')] = layerInfo.name;
			// 名称などの属性
			var firstAttrInfo = layerInfo.getAttrInfo(firstAttr[0]);
			dataMap[lang.__('Name')] = (firstAttrInfo!=null ? firstAttrInfo.name+": "+firstAttr[2] : "name attr exists");
			dataMap[lang.__('Distance')] =  geom[2];
			dataMap[lang.__('Layer ID')] = layerId;
			dataMap[lang.__('Feature ID')] = featureId;
			dataMapList.push(dataMap);
		}
		var createDataSet = function(dataMapList){
			if(!dataMapList||dataMapList.length==0) return null;
			//var fieldSize = dataMapList[0].length;
			var fields = new Array();
			for(var key in dataMapList[0]){fields.push(key);}
			//var valueSize = dataMapList.length;
			var values = new Array();
			for(var idx=0;idx<dataMapList.length;idx++){
				var dataMap = dataMapList[idx];
				var value = new Array();
				for(var fieldsIdx in fields){
					var key = fields[fieldsIdx];
					var data = dataMap[key];
					value.push(data);
				}
				values.push(value);
			}
			return {fields:fields, values: values};
		};
		var dataset = createDataSet(dataMapList);
		console.log('dataset');
		console.log(dataset);


		//============================================
		// グリッド
		//============================================
		var createDataStore = function(dataset){
			// フィールド生成
			var fields = new Array();
			for(var idx=0; idx<dataset.fields.length; idx++){
				var name = dataset.fields[idx];
				var field = {name: name};
				fields.push(field);
			}
			// データストア生成
			var data = dataset.values;
			var store = Ext.create("Ext.data.ArrayStore",{
				fields: fields,
				data: data
			});
			return store;
		};
		var store = createDataStore(dataset);

		var createGridPanel = function(option){
			var columns = new Array();
			for(var idx=0; idx<dataset.fields.length; idx++){
				var name = dataset.fields[idx];
				var column = {text: name, dataIndex: name, flex: 1};
				if(name==lang.__('Distance')) {
					column['renderer'] = Ext.util.Format.numberRenderer('0m');
					column['flex'] = null;
					column['fixed'] = true;
					column['width'] = 60;
				}
				if(name==lang.__('Feature ID')||name==lang.__('Layer ID')){ column['hidden']=true; }
				columns.push(column);
			}
			console.log('columns');
			console.log(columns);
			var grid = Ext.create('Ext.grid.Panel',{
				store: option.store,
				stateful: true,
				collapsible: false,
				multiSelect: false,
				header: false,
				width: 250,
	//			closable: true,
				frame: false,
				stateId: 'stateGrid',
					columns: columns,
					viewConfig: {
						stripeRows: true,
						enableTextSelection: true
					}
			});
			return grid;
		};
		var option = {store:store};
		var grid = createGridPanel(option);

		// Grid のクリックイベント
		var self = this;
		var onItemClick = function(view, record, item, index, e, eOpts){
			if(stmap.popupManager!=null) {
				stmap.popupManager.close(me.popup);
			}
			var layerId = record.data[lang.__('Layer ID')];
			var fid = record.data[lang.__('Feature ID')];
			stmap.getContent(layerId, fid, center, bbox, {
				// リストへもどるためのフラグ
				fromList: true,
				// ピン留めフラグ
				pinned: me.popup.pinned
			});
			return false;
		};
		grid.addListener('itemclick',onItemClick);

		if(stmap.popupManager!=null) {
			stmap.popupManager.closeAll();
		}
		var items = [grid];
		me.showExtPopup({
			title: count+lang.__("Items"),
			map: stmap,
			olmap: stmap.map,
			center: center,
			panelWidth: grid.width,
			pinned: pinned,
			items: items
		});
	}
});
/* ======================================================================
    SaigaiTask/Map/view/ContentsFormWindow.js
   ====================================================================== */

/**
 * 登録情報ウィンドウ
 * @require SaigaiTask/Map/view.js
 * @returns {SaigaiTask.Map.view.ContentsFormWindow}
 */
SaigaiTask.Map.view.ContentsFormWindow = function() {
	this.initialize.apply(this, arguments);
};

SaigaiTask.Map.view.ContentsFormWindow.prototype = {

	stmap: null,

	/**
	 * @type {Ext.window.Window}
	 */
	window: null,

	/**
	 * @type {SaigaiTask.Map.view.ContentsFormPanel}
	 */
	contentsFormPanel: null,

	/**
	 * @type {SaigaiTask.Map.view.DrawToolbar}
	 */
	drawToolbar: null,

	/**
	 * @type {Map.view.Measure}
	 */
	measure: null,

	/**
	 * 登録情報ウィンドウを表示します.
	 * @param option.stmap 地図オブジェクト
	 * @param option.layerInfo レイヤ情報
	 * @param option.lonlat 経緯度(地図の投影法で)
	 * @param option.fid フィーチャID(更新時の場合指定)
	 * @param option.feature フィーチャ(EPSG:4326)(更新時の場合指定)
	 * @param option.content 登録情報(更新時の場合指定)
	 * @param option.drawGeometryOnly ジオメトリ描画モード（描画のみで登録処理しない）
	 */
	initialize: function(option) {
		var me = this;
		var stmap = option.stmap;
		var layerInfo = option.layerInfo;
		var fid = typeof option.fid!="undefined" ? option.fid : null;
		var feature = typeof option.feature!="undefined" ? option.feature : null;
		var content = typeof option.content!="undefined" ? option.content : null;
		var lonlat = option.lonlat;
		var drawGeometryOnly = !!option.drawGeometryOnly;

		// 登録情報ウィンドウは一度に１つしか表示させない
		if(stmap.components.contentsFormWindow!=null) {
			stmap.components.contentsFormWindow.window.close();
		}
		stmap.components.contentsFormWindow = me;

		// TODO: レイヤが非表示だったら表示する

		// Toolbar
		var tbar = null;
		var dockedItems = [];

		// 描画ツールバー
		var geomType = layerInfo.geomType;
		var isMulti = geomType.indexOf("MULTI")==0;
		var isPoint = geomType.match(/POINT$/)!=null;
		var isPolygon = geomType.match(/POLYGON$/)!=null;
		var isLinestring = geomType.match(/LINESTRING$/)!=null;
		var pseudo = /*擬似ポリゴン*/isPolygon; // 擬似ジオメトリフラグ
		var drawToolbar = me.drawToolbar = new SaigaiTask.Map.view.DrawToolbar(stmap, {
			init: false,
			geomType: geomType,
			renderTo: Ext.getBody(),
			drawPoint: isPoint || isPolygon,
			drawPolygon: isPolygon,
			drawCircle: isPolygon,
			drawLine: isLinestring || isPolygon,
			modifyFeature: isPoint==false,
			dragFeature: true,
			removeFeature: true,
			intersectLayerId: layerInfo.intersectionlayerid,
			intersectLayerName: layerInfo.intersectionlayername,
			maxDrawNum: (isMulti ? Number.MAX_VALUE : 1)
		});

		// set Toolbar option
		if(isPolygon) {
			// 区切り文字で分割
			var split = function(tbarItems) {
				var array = [];
				var items = [];
				for(var idx in tbarItems) {
					var item = tbarItems[idx];
					// 区切り文字の場合
					if(item=="-") {
						// アイテムあればtoolbarとして追加
						if(0<items.length) {
							array.push({
								xtype: "toolbar",
								dock: "top",
								items: items
							});
						}
						// 空にする
						items = [];
					}
					else {
						items.push(item);
					}
				}
				return array;
			}
			// 分割する
			var tbarItems = drawToolbar.tbarItems;
			dockedItems = dockedItems.concat(split(tbarItems));
		}
		// Polygon以外は１つのToobarでまとめる
		else {
			tbar = drawToolbar.getSimpleToolbar();
		}

		// 描画レイヤ設定
		var drawLayer = drawToolbar.drawLayer;
		drawLayer.layer.setVisibility(true);

		// 最初のフィーチャを描画
		if(feature!=null) {
			// 擬似ジオメトリ可の場合、元のジオメトリに戻す
			if(pseudo) {
				var geometry = feature.geometry;
				var isMulti = geometry.CLASS_NAME.match(/^OpenLayers.Geometry.Multi/)!=null;
				var geoms = isMulti ? geometry.components : [geometry];
				for(var idx in geoms) {
					// 擬似ジオメトリからもとのジオメトリに戻す
					var geom = geoms[idx];
					orgGeom = drawToolbar.convertPseudoGeometry(geomType, geom);
					drawLayer.drawFeatureByGeometry(orgGeom!=null?orgGeom:geom);
				}
			}
			else {
				// そのまま描画する
				drawLayer.drawFeatureByGeometry(feature.geometry);
			}
		}
		else {
			if(isPoint) {
				// クリックした位置に点を描画する
				// フィーチャがあればフィーチャの位置に点を描画する
				if(feature!=null) {
					var point = feature.geometry.getCentroid().transform(new OpenLayers.Projection("EPSG:4326"), stmap.map.getProjectionObject());
					lonlat = new OpenLayers.LonLat(point.x, point.y);
				}
				// 位置の指定がなければ中心位置に点を描画する
				if(lonlat==null) {
					lonlat = stmap.map.getCenter();
				}
				var ret = drawLayer.moveSinglePoint(lonlat);
				//drawLayer.singlePointMoveClickHandler.activate();
				drawLayer.setDragFeatureControlActivation(true);
				feature = ret.feature;
			}
		}

		// 登録情報ウィンドウを初期化
		var layerId = layerInfo.layerId;
		var contentsFormPanel = me.contentsFormPanel = new SaigaiTask.Map.view.ContentsFormPanel(stmap, layerId, feature, fid, content);
		var formPanel = contentsFormPanel.formPanel;
		var layerName = contentsFormPanel.json.layerInfo.layerName;

		// フォームのウィンドウを生成
		var win = null;
		win = me.window = Ext.create('Ext.window.Window', {
			title: layerName + ' ' + lang.__('Registration form'),
			width: 300, //height: 600,
			maxWidth: document.body.clientWidth,
			maxHeight: document.body.clientHeight,
			collapsible: true,
			tbar: tbar,
			dockedItems: dockedItems,
			layout: 'fit',
			items: drawGeometryOnly ? null : formPanel,
			buttons: [{
				text: lang.__('Registration'),
				textAlign: "left",
				icon: stmap.icon.getURL("editIconURL"),
				handler: function(){
					var form = formPanel.form;
					if(form.isValid()) {
						try{
							// ONになっている描画コントロールがあれば解除する.
							// ポリゴンレイヤで編集モードだと、編集用のPOINTも形状チェック対象になり、Invalid Geometryになるので解除する
							drawLayer.deactivateCurrentDrawControl();
							var feature = drawToolbar.getDrawFeature(geomType, {
								pseudo: pseudo// 擬似ジオメトリ
							});

							if(confirm(lang.__('Are you sure to register?<!--2-->'))){
								// ジオメトリ描画モード
								if(drawGeometryOnly) {
									var wkt = stmap.getWKT(feature);
									// この処理は汎用的でないので、イベントトリガーして実行させるようにする
									/*window.parent.frames.addlineform.the_geom.value(wkt);
									window.parent.$('#map-dialog').dialog('close');*/
									if(fid == 0 || fid==null){
										parent.$('body').trigger('onsavegeom',[wkt]);
									}else{
										parent.$('body').trigger('oneditgeom',[wkt]);
									}
								}
								else {
									var wkt = stmap.getWKT(feature);
									contentsFormPanel.submit({
										wkt: wkt==null ? "" : wkt
									});
									win.close();
								}
							}
						} catch(e) {
							console.error(e);
							if(e=="Invalid Geometry") {
								alert(lang.__("You can not register this shape. \n shape might be overlapped"));
							}
							else {
								alert(e);
							}
						}
					}
					else {
						alert(lang.__("Input data not appropriate."));
					}
				}
			}, {
				text: lang.__('Cancel'),
				handler: function(){ win.close(); }
			}],
			listeners: {
				destroy: function() {
					drawLayer.destroy();
				}
			}
		});

		// 住所ボタンのクリックイベントを定義
		formPanel.addListener("clickaddressbtn", function(args) {
			var btn = args.addressBtn;
			var field = args.textField;
			// 最初のフィーチャの中心位置を使って住所を求める
			var features = drawToolbar.drawLayer.layer.features;
			if(0<features.length) {
				var feature = features[0];
				var center = feature.geometry.getCentroid();
				center = center.transform(stmap.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));

				stmap.geocode(center)
				.done(function(results) {
					var result = results[0];
					var address = stmap.getFormattedAddress(result);
					field.setValue(address);
				});
			}
		});

		// ウィンドウ表示
		win.show();
		win.alignTo(document, "tr", [-win.getWidth(), 0]);

		var measure = me.measure = new SaigaiTask.Map.view.Measure(stmap);
		measure.stopMeasure();
	}
};
/* ======================================================================
    SaigaiTask/Map/view/HeaderToolbar.js
   ====================================================================== */

/**
 *
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.HeaderToolbar = function() {
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.HeaderToolbar.prototype = {
	map: null,
	tbar: null,
	measure: null,
	baselayerCombo: null,
	initialize: function(map) {
		var me = this;
		me.map = map;
		var headerTbarItems = [];

		// ツールバーを初期化
		var headerTbar = Ext.create("Ext.toolbar.Toolbar", {
			items: headerTbarItems
		});
		me.tbar = headerTbar;

		// ベースレイヤ切り替えコンボボックスを追加
		me.updateBaselayerCombo();

		// "loadendecommap"イベントで凡例パネルを再描画
		map.events.register("loadendecommap", map, function(){
			me.updateBaselayerCombo();
		});
	},

	/**
	 * ベースレイヤ切替コンボボックスを更新
	 */
	updateBaselayerCombo: function() {
		var me = this;
		var map = me.map;

		// data 作成
		var baseLayers = [];
		for(var ecommapsIdx in map.ecommaps) {
			var ecommap = map.ecommaps[ecommapsIdx];
			baseLayers = baseLayers.concat(ecommap.getBaseLayerInfos());
		}

		// Store の更新
		var store = null;
		if(me.baselayerCombo==null) {
			// コンボボックスがまだない場合は新規作成
			var store = Ext.create('Ext.data.Store', {
				fields: ['layerId', 'name'],
				data: baseLayers
			});
		}
		else {
			// data の入れ替え
			store = me.baselayerCombo.getStore();
			store.removeAll();
			store.add(baseLayers);
		}

		// 選択値
		var value = null;
		for(idx in baseLayers) {
			var baseLayer = baseLayers[idx];
			if(baseLayer.visibility) {
				value = baseLayer.layerId;
				break;
			}
		}

		// 選択値の更新
		var baselayerCombo = null;
		if(me.baselayerCombo==null) {
			baselayerCombo = me.baselayerCombo = Ext.create('Ext.form.ComboBox', {
				store: store,
				queryMode: 'local',
				displayField: 'name',
				valueField: 'layerId',
				value: value,
				listeners: {
					change: function(combo, newValue, oldValue, eOpts){
						map.setBaseLayerById(newValue);
					}
				}
			});
			me.tbar.add(baselayerCombo);
		}
		else {
			me.baselayerCombo.setValue(value);
		}

		// 初期表示がすべて非表示の場合もあるため、
		// 選択された背景地図レイヤを表示
		map.setBaseLayerById(value);

		me.baselayerCombo = baselayerCombo;
		me.tbar.add(baselayerCombo);
		//距離・面積計測を追加 (ツールバーに移動)
		//var measure = me.measure = new SaigaiTask.Map.view.Measure(map);
		//me.tbar.add(measure.measure);
	}
};
/* ======================================================================
    SaigaiTask/Map/control/MousePosition60.js
   ====================================================================== */

/**
 * マウスカーソル位置の経緯度を60進(DMS)表記で表示するクラスです.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.MousePosition60 = OpenLayers.Class(OpenLayers.Control.MousePosition, {

    initialize: function (options) {
        // 画面右下に表示する CSSクラス を指定
        // 指定しないと、CLASS_NAME で指定されてしまうため
        OpenLayers.Util.extend(options, {
            "displayClass": "olControlMousePosition"
        })
        OpenLayers.Control.MousePosition.prototype.initialize.apply(this, [options]);
    },

    /**
     * Method: formatOutput
     * Override to provide custom display output
     *
     * Parameters:
     * lonLat - {<OpenLayers.LonLat>} Location to display
     */
    formatOutput: function(lonLat) {
        var digits = parseInt(this.numDigits);
        var dx = lonLat.lon;
        var hx = parseInt(dx);
        var mx = parseInt((dx-hx)*60);
        var sx = ((dx-hx)*60-mx)*60;

        var dy = lonLat.lat;
        var hy = parseInt(dy);
        var my = parseInt((dy-hy)*60);
        var sy = ((dy-hy)*60-my)*60;

        var newHtml =
            this.prefix +
            hx+"°"+mx+"'"+sx.toFixed(1) +
            this.separator +
            hy+"°"+my+"'"+sy.toFixed(1) +
            this.suffix;
        return newHtml;
    },

    CLASS_NAME: "SaigaiTask.Map.control.MousePosition60"
});
/* ======================================================================
    SaigaiTask/Map/Layer/KMLLayer.js
   ====================================================================== */

/**
 * KMLレイヤ
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 * requires OpenLayers.Format.KMLStyle.js
 */
SaigaiTask.Map.Layer.KMLLayer = new OpenLayers.Class(OpenLayers.Layer.Vector, {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * KMLレイヤ情報
	 * @type {SaigaiTask.Map.Layer.LayerInfo}
	 */
	layerInfo: null,

	/**
	 * @type {OpenLayers.Format.KMLStyle}
	 */
	kmlFormat: null,

	/**
	 * @type {OpenLayers.Control.SelectFeature}
	 */
	kmlSelectControl: null,

	/**
	 * リロード秒数
	 * default 0
	 * @type {Number}
	 */
	reloadSec: 0,

	/**
	 * リロードのタイマーID
	 * @type {Number}
	 */
	reloadTimerId: null,

	/**
	 *
	 * @param layerInfo kmlLayerInfo
	 */
	initialize: function(layerInfo) {
		// 引数を処理
		var me = this;
		me.layerInfo = layerInfo;
		var ecommapInfo = layerInfo.ecommap;
		var stmap = me.stmap = ecommapInfo.stmap;
		me.kmlSelectControl = stmap.controls["kmlSelectControl"];

		var options = {
			visibility: layerInfo.visibility,
			attribution: layerInfo.attribution
		};

		// KMLフォーマットの初期化
		var wgs84 = new OpenLayers.Projection("EPSG:4326");
		var internalProjection = wgs84;
		if(!!stmap.epsg) internalProjection = new OpenLayers.Projection("EPSG:"+stmap.epsg);
		me.kmlFormat = new OpenLayers.Format.KMLStyle({
			extractStyles: true,
			internalProjection: internalProjection
		});

		// Vectorレイヤの初期化
		OpenLayers.Layer.Vector.prototype.initialize.apply(this, [layerInfo.name, options]);

		// リロード秒数の取得
		var layerInfo = me.layerInfo;
		if(layerInfo.reload!=null) {
			try {
				var reloadJson = JSON.parse(layerInfo.reload);
				if($.isNumeric(reloadJson.sec)) {
					me.reloadSec = reloadJson.sec;
				}
			} catch (e) {
				logger.warn(e);
			}
		}

		//<span class="ja">初回読み込み</span><span class="en">Load for the first time</span>
		// 初期表示で、キャッシュを読まないようにする
		if (me.visibility) {
			me.loadKMLFeature({
				data: {
					reload: true
				}
			});
		}

		// イベントハンドラの初期化
		me.events.on({
			"visibilitychanged": function() {
				if(me.getVisibility()) {
					// 強制リロード
					me.loadKMLFeature({
						data: {
							reload: true
						}
					});
				}
			},
			"featureselected": function(e) {
				me.kmlPopup = new SaigaiTask.Map.view.KMLPopup(me.stmap);
				me.kmlPopup.show(e.feature, layerInfo);
				me.kmlSelectControl.unselectAll();
			}
		});

		layerInfo.layer = this;
		me.stmap.map.addLayer(me);
		// クリック可能なら SelectControl に追加
		if(layerInfo.searchable) {
			var layers = [me].concat(me.kmlSelectControl.layers);
			me.kmlSelectControl.setLayer(layers)
			if(!me.kmlSelectControl.active) me.kmlSelectControl.activate();
		}
	},

	loadKMLFeature: function(option) {
		//<span class="ja">URLからKML読み込み</span><span class="en">Load KML from URL</span>
		//var url = "/map/kml?mid="+this.mapId+"&kml="+layerInfo.layerId+(reloadSec>0?"&sec="+reloadSec:"")+"&"+(Math.floor(new Date().getTime()/1000));
		//var url = this.kmlURL+"mid="+this.mapId+"&url="+escape(kmlUrl)+(reloadSec>0?"&sec="+reloadSec:"")+"&"+(Math.floor(new Date().getTime()/1000));

		var me = this;
		var kmlLayer = me;

		var data = {
			url: me.layerInfo.wfsURL
		};
		if(0<me.reloadSec) {
			data.reloadSec = me.reloadSec;
		}

		// 引数の値を優先してセット
		if(!!option) {
			if(!!option.data) {
				$.extend(data, option.data);
			}
		}

		jQuery.ajax({
			url: SaigaiTask.contextPath+"/page/map/kml/",
			async: true,
			dataType: "text",
			data: data,
			cache: false
		}).done(function(data) {
			if (data) {
				var features = me.kmlFormat.read(data);
				kmlLayer.removeAllFeatures();
				kmlLayer.addFeatures(features);
				for (var i=0; i<features.length; i++) {
					var feature = features[i];
					var style = feature.style;
					if(!!style) {
						style.cursor = "pointer";
						//<span class="ja">テキストの場合はfontColorが設定されている</span><span class="en">Set fontColor in case of text</span>
						if (style.fontColor) {
							style.label = feature.attributes.name;
							style.fontWeight = "bold";
							style.labelAlign = "lt";
						}
					}
				}
				kmlLayer.redraw();
			}
		}).fail(function(xhr, textStatus, errorThrown) {
			alert(lang.__("Failed to get {0}", me.name));
		}).complete(function(xhr, textStatus) {
		//
		//<span class="ja">リロード指定時</span><span class="en">When identifying reload</span>
			if (me.reloadTimerId==null) {
			// リロードインターバルの起動
			if (me.reloadSec > 0) {
					me.reloadTimerId = setTimeout(function() {
						me.reloadTimerId = null;
					if (me.visibility) me.loadKMLFeature();
				}, me.reloadSec*1000);
			}
		}
		});

	},

	/**
	 * @see eMapBase.openKMLPopup
	 */
	openKMLPopup: function(feature, layerInfo) {
		var me = this;
		var stmap = me.stmap;
		if(stmap.popupManager!=null) {
			stmap.popupManager.closeAll();
		}

		try {
			var self = this;
			var lonlat = feature.geometry.getBounds().getCenterLonLat().clone();
			//<span class="ja">Featureは地図座標なので一旦緯度経度に戻す</span>
			//<span class="en">Because feature is map coordinate, return to longtitude-latitude once </span>
			if (me.stmap.epsg!=4326) lonlat.transform(me.stmap.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));

			var popupDiv = document.createElement('div');
			var div, span;

			//Attrs
			div = document.createElement('div');
			div.className = "popup_attr";
			//<span class="ja">aタグはtargetとhrefのみにする</span><span class="en">Set only 'target' and 'href' for 'A' tag</span>
			if (feature.attributes.description) {
				div.innerHTML = (feature.attributes.name ? "<h3>"+SaigaiTask.Map.util.CommonUtil.escapeXml(feature.attributes.name)+"</h3>" : "")
					+feature.attributes.description.replace(/<\s*a\s+/ig, '<a target="_blank" ').replace(/onclick\s*=\s*"[^"]*"/ig,'');
				//attrDiv.style.width = w+"px";
			} else if (feature.attributes.name) {
				div.innerHTML = "<h3>"+SaigaiTask.Map.util.CommonUtil.escapeXml(feature.attributes.name)+"</h3>";
			}

			try {
				var tbody = null;
				var td;
				for (var key in feature.attributes) {
					if (key != "name" && key != "description" && key != "styleUrl") {
						if (feature.attributes[key].value) {
							if (!tbody) tbody = document.createElement('tbody');
							var attrTr = document.createElement('tr');
							td = document.createElement('td');
							attrTr.appendChild(td);
							td.innerHTML = key;
							td = document.createElement('td');
							td.innerHTML = feature.attributes[key].value;
							attrTr.appendChild(td);
							tbody.appendChild(attrTr);
						}
					}
				}
				if (tbody) {
					table = document.createElement('table');
					table.cellSpacing = 0;
					table.cellPadding = 0;
					table.appendChild(tbody);
					div.appendChild(table);
				}
			} catch (e) {}

			popupDiv.appendChild(div);

			// DIV用のパネル（ヘッダーなし）
			var panel = Ext.create('Ext.panel.Panel', {
				width: 200,
				contentEl: popupDiv
			});

			// ExtPopupのオプション
			var option = {
				map: me.stmap,
				olmap: me.stmap.map,
				center: lonlat,
				items: [panel],
				title: layerInfo.name,
				pinned: false
			};
			var popup = SaigaiTask.Map.view.Popup.showExtPopup(option);
		} catch (e) { console.error(e); }
	},

	CLASS_NAME: "SaigaiTask.Map.Layer.KMLLayer"
});

SaigaiTask.Map.Layer.KMLLayer.type = SaigaiTask.Map.Layer.Type.KML;
/* ======================================================================
    OpenLayers/Layer/Google/v3.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * Google Maps Javascript API の APIバージョン 3.20 が削除された影響で、
 * Googleマップを初期表示の背景地図とすると表示されない不具合の対応。
 * @see https://github.com/openlayers/openlayers/issues/1450
 */
OpenLayers.Layer.Google.v3.setGMapVisibility = function(visible) {
	var cache = OpenLayers.Layer.Google.cache[this.map.id];
	var map = this.map;
	if (cache) {
		var type = this.type;
		var layers = map.layers;
		var layer;
		for (var i=layers.length-1; i>=0; --i) {
			layer = layers[i];
			if (layer instanceof OpenLayers.Layer.Google &&
						layer.visibility === true && layer.inRange === true) {
				type = layer.type;
				visible = true;
				break;
			}
		}
		var container = this.mapObject.getDiv();
		if (visible === true) {
			if (container.parentNode !== map.div) {
				// begin of issues 1450 
				if (!cache.rendered) {
					var me = this;
					google.maps.event.addListenerOnce(this.mapObject, 'tilesloaded', function() {
						cache.rendered = true;
						me.setGMapVisibility(me.getVisibility());
						me.moveTo(me.map.getCenter());
						cache.googleControl.appendChild(map.viewPortDiv);
					});
				} else {
					cache.googleControl.appendChild(map.viewPortDiv);
				}
				map.div.appendChild(container);
				google.maps.event.trigger(this.mapObject, 'resize');
				// end of issues 1450 
			}
			this.mapObject.setMapTypeId(type);
		} else if (cache.googleControl.hasChildNodes()) {
			map.div.appendChild(map.viewPortDiv);
			map.div.removeChild(container);
		}
	}
};
/* ======================================================================
    SaigaiTask/Map/control/SyncControl.js
   ====================================================================== */

/**
 * 複数地図の同期を制御するクラスです.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.SyncControl = new OpenLayers.Class(OpenLayers.Control, {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * 中心位置を同期するかどうかのフラグ
	 * @type {Boolean}
	 */
	syncCenter: true,

	/**
	 * 縮尺を同期するかどうかのフラグ
	 * @type {Boolean}
	 */
	syncZoom: true,

	/**
	 * 同期グループ
	 * @type {Array<Map>}
	 */
	group: null,

	/**
	 * 同期状態
	 * @type {Object}
	 */
	state: null,

	initialize: function(stmap) {
		var me = this;
		me.stmap = stmap;
		me.group = [stmap];
		me.state = {
			/** 移動中 */
			moving: false
		};

		var olmap = stmap.map;
		olmap.events.on({
			"move": function() {
				me.moveEnd();
			},
			"zoomend": function() {
				me.zoomEnd();
			}
		});

		OpenLayers.Control.prototype.initialize.apply(this, []);
	},

	/**
	 * グループをマージして1つにします
	 * @param {SaigaiTask.Map.control.SyncControl}
	 */
	mergeGroup: function(syncControl) {
		var me = this;
		var concatGroup = me.group.concat(syncControl.group);
		me.group = syncControl.group = concatGroup;
		syncControl.state = me.state;
	},

	/**
	 * グループから取り除きます
	 * @param {SaigaiTask.Map.control.SyncControl}
	 */
	removeGroup: function(syncControl) {
		var me = this;
		me.group = jQuery.grep(me.group, function(value) {
			return value != syncControl.stmap;
		});
	},

	/**
	 * 地図移動時のハンドラです.
	 */
	moveEnd: function() {
		var me = this;
		var state = me.state;
		if(me.active && state.moving==false) {
			state.moving = true;
			//console.log("move end");
			var group = me.group;
			for(var idx in group) {
				var stmap = group[idx];
				// 動かした地図自身なら同期処理はやる必要がない.
				if(me.stmap==stmap) continue;
				// 中心位置を同期
				var center = me.stmap.getCenter();
				//console.log(center);
				stmap.setCenter(center);
				//console.log(stmap.getCenter());
			}
			state.moving = false;
		}
	},

	/**
	 * 地図移動時のハンドラです.
	 */
	zoomEnd: function() {
		var me = this;
		var state = me.state;
		if(me.active && state.moving==false) {
			state.moving = true;
			var group = me.group;
			for(var idx in group) {
				var stmap = group[idx];
				// 動かした地図自身なら同期処理はやる必要がない.
				if(me.stmap==stmap) continue;
				var center = me.stmap.getCenter();
				// ズームレベルを同期
				// resolution(解像度)でやるべき？
				var zoom = me.stmap.map.getZoom();
				stmap.setCenter(center, zoom);
			}
			state.moving = false;
		}
	}
});
/* ======================================================================
    SaigaiTask/Map/Layer/PdfRangeLayer.js
   ====================================================================== */

/**
 * PDF Range Layer
 * @requires SaigaiTask/Map/Layer.js
 */
SaigaiTask.Map.Layer.PdfRangeLayer = new OpenLayers.Class(OpenLayers.Layer.Vector, {

	/**
	 * @type {SaigaiTask.Map.view.PrintPreviewWindow}
	 */
	printPreviewWindow: null,
	
	/** <span class="ja">印刷範囲表示レイヤ</span><span class="ja">Layer to display print area</span> */
	pdfRangeLayer : null,

	/** <span class="ja">印刷範囲形状</span><span class="en">Print range shape</span> */
	printFeature : null,

	/** <span class="ja">用紙縦横比</span><span class="en"></span> */
	paperRate : {'a':0.7073171, 'b':0.7074176},
	
	/** 印刷範囲用ノードレイヤ **/
	printRangeNodeLayer : null,
	/** 印刷範囲用ノード **/
	printRangeNode : null,
	/** 印刷範囲用ノードマーカー **/
	printRangeNodeMaker : [],
	/** 印刷範囲用ノードドラッグイベント **/
	dragNodeMarker : null,
	/** 画像範囲用ノードドラッグイベント **/
	dragImageNodeMarker : null,
	/** **/
	dragEvent : "",
	/**  **/
	resizeOrigin : null,

	initialize: function(printPreviewWindow) {
		var me = this, self = this, layer=this;
		me.printPreviewWindow = printPreviewWindow;
	},
	
	initLayer: function() {
		var me = this, self = this, layer=this;
		var printPreviewWindow = me.printPreviewWindow;
		var stmap = printPreviewWindow.stmap;
		var map = stmap.map;

		if (!self.pdfRangeLayer) {
			me.pdfRangeLayer = this;

			var name = "PdfRangeLayer";
			OpenLayers.Layer.Vector.prototype.initialize.apply(this, [name]);

			// LayerSwitcher非表示
			me.displayInLayerSwitcher = false;
			map.addLayer(layer);

			// スタイルを赤枠にする
			layer.styleMap.styles['default'] = new OpenLayers.Style({
				fillColor: "#FFFFFF", fillOpacity: 0.25,
				strokeColor: "#FF0000", strokeOpacity: 1, strokeWidth: 1
			});
		}

		if (!this.printRangeNodeLayer){
			this.printRangeNodeLayer = new OpenLayers.Layer.Markers('rangeNode');
			this.printRangeNode = new OpenLayers.Icon(stmap.icon.getURL("pointnodeIconURL"), new OpenLayers.Size(9,9), new OpenLayers.Pixel(-5,-5));
			map.addLayer(self.printRangeNodeLayer);
		}

		self.dragNodeMarker = new OpenLayers.Control.DragMarker(
				this.printRangeNodeLayer, {
					onStart:function(marker){
						self.nodeDragStart(marker, self.pdfRangeLayer);
					},
					onDrag:function(marker){
						self.nodeDrag(marker, self.pdfRangeLayer);
					},
					onComplete:function(marker){
						self.nodeDragComplete(marker, self.pdfRangeLayer);
						if (marker) marker.events.triggerEvent("mouseout");
					}
		});
		map.addControl(this.dragNodeMarker);
		this.dragNodeMarker.activate();
		self.dragImageNodeMarker = new OpenLayers.Control.DragMarker(
			this.printRangeNodeLayer, {
				onStart:function(marker){
					self.nodeDragStart(marker, self.imageRangeLayer);
				},
				onDrag:function(marker){
					self.nodeDrag(marker, self.imageRangeLayer);
				},
				onComplete:function(marker){
					self.nodeDragComplete(marker, self.imageRangeLayer);
					if (marker) marker.events.triggerEvent("mouseout");
				}
			}
		);
		map.addControl(this.dragImageNodeMarker);
		this.dragImageNodeMarker.activate();
	},

	onHideDialog : function()
	{
		//範囲レイヤ非表示
		this.pdfRangeLayer.setVisibility(false);
		this.printRangeNodeLayer.setVisibility(false);

		//<span class="ja">範囲クリア</span>
		//<span class="en">Clear the range</span>
		if (this.printFeature) this.pdfRangeLayer.removeFeatures([this.printFeature]);
		if (this.printFeatureInner != null){
			for (var i = 0; i < this.printFeatureInner.length; i++){
				this.pdfRangeLayer.removeFeatures([this.printFeatureInner[i]]);
			}
		}
		this.printFeature = null;

		// ノードマーカーの削除
		this.dragNodeMarker.deactivate();
		this.dragImageNodeMarker.deactivate();
		if (this.printRangeNodeMaker.length){
			this.printRangeNodeLayer.clearMarkers();
		}
		this.printRangeNodeMarker = [];
	},

	showPrintRange: function(bbox) {
		var me = this;
		me.initLayer();
		
		var map = this.map;
		try {
			//<span class="ja">範囲指定がなければ表示範囲</span>
			//<span class="en">If the range is not specified, display range</span>
			if (!bbox) bbox = map.getExtent();
			if (this.printFeature) this.pdfRangeLayer.removeFeatures([this.printFeature]);
			var points = this.getPageRange(bbox).toGeometry().components[0].components;
			points[0] = points[0].clone();//<span class="ja">始点と終点が同じObjectなので始点をclone</span><span class="en"></span>
			this.printFeature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.LineString(points), null,
				{strokeColor:"#FF0000", strokeOpacity:0.7, strokeWidth:4, cursor:'pointer'});
			this.addFeatures([this.printFeature]);
			
			//一番上のレイヤにする
			this.moveToFrontLayer(this.pdfRangeLayer);
			this.pdfRangeLayer.setVisibility(true);
				
		} catch (e) { console.error(e); }
	},
	
	/**　選択ノード設定
	 * @param feature
	 */
	setPrintRangeNode : function(feature)
	{
		var bounds = feature.geometry.getBounds();
		this.printRangeNodeLayer.clearMarkers();
		var lonLat = {};
		var tag = {}

		// 上
		lonLat.lon = bounds.left + ((bounds.right - bounds.left)/2);
		lonLat.lat = bounds.top;
		tag = {math : 'y', pos : 't'};
		this.addPrintRangeNode(((this.dragEvent == "pdf") ? this.dragNodeMarker : this.dragImageNodeMarker), feature, new OpenLayers.LonLat(lonLat.lon, lonLat.lat), this.printRangeNode.clone(), 'n-resize' ,tag);
		// 下
		lonLat.lon = bounds.left + ((bounds.right - bounds.left)/2);
		lonLat.lat = bounds.bottom;
		tag = {math : 'y', pos : 'b'};
		this.addPrintRangeNode(((this.dragEvent == "pdf") ? this.dragNodeMarker : this.dragImageNodeMarker), feature, new OpenLayers.LonLat(lonLat.lon, lonLat.lat), this.printRangeNode.clone(), 's-resize' ,tag);
		// 左
		lonLat.lon = bounds.left;
		lonLat.lat = bounds.top + ((bounds.bottom - bounds.top)/2);
		tag = {math : 'x', pos : 'l'};
		this.addPrintRangeNode(((this.dragEvent == "pdf") ? this.dragNodeMarker : this.dragImageNodeMarker), feature, new OpenLayers.LonLat(lonLat.lon, lonLat.lat), this.printRangeNode.clone(), 'w-resize' ,tag);
		// 右
		lonLat.lon = bounds.right;
		lonLat.lat = bounds.top + ((bounds.bottom - bounds.top)/2);
		tag = {math : 'x', pos : 'r'};
		this.addPrintRangeNode(((this.dragEvent == "pdf") ? this.dragNodeMarker : this.dragImageNodeMarker), feature, new OpenLayers.LonLat(lonLat.lon, lonLat.lat), this.printRangeNode.clone(), 'e-resize' ,tag);
		// 左上
		lonLat.lon = bounds.left;
		lonLat.lat = bounds.top;
		tag = {math : 'y', pos : 'tl'};
		this.addPrintRangeNode(((this.dragEvent == "pdf") ? this.dragNodeMarker : this.dragImageNodeMarker), feature, new OpenLayers.LonLat(lonLat.lon, lonLat.lat), this.printRangeNode.clone(), 'nw-resize' ,tag);
		// 右上
		lonLat.lon = bounds.right;
		lonLat.lat = bounds.top;
		tag = {math : 'y', pos : 'tr'};
		this.addPrintRangeNode(((this.dragEvent == "pdf") ? this.dragNodeMarker : this.dragImageNodeMarker), feature, new OpenLayers.LonLat(lonLat.lon, lonLat.lat), this.printRangeNode.clone(), 'ne-resize' ,tag);
		// 左下
		lonLat.lon = bounds.left;
		lonLat.lat = bounds.bottom;
		tag = {math : 'y', pos : 'bl'};
		this.addPrintRangeNode(((this.dragEvent == "pdf") ? this.dragNodeMarker : this.dragImageNodeMarker), feature, new OpenLayers.LonLat(lonLat.lon, lonLat.lat), this.printRangeNode.clone(), 'sw-resize' ,tag);
		// 右下
		lonLat.lon = bounds.right;
		lonLat.lat = bounds.bottom;
		tag = {math : 'y', pos : 'br'};
		this.addPrintRangeNode(((this.dragEvent == "pdf") ? this.dragNodeMarker : this.dragImageNodeMarker), feature, new OpenLayers.LonLat(lonLat.lon, lonLat.lat), this.printRangeNode.clone(), 'se-resize' ,tag);
		this.moveToFrontLayer(this.printRangeNodeLayer);
	},

	/** 選択ノード追加
	 * @parama control 選択マーカーレイヤ
	 * @parama feature 対象フィーチャー
	 * @parama lonlat lonlat
	 * @parama icon 表示画像
	 * @parama cursor カーソル
	 * @parama tag その他情報
	 */
	addPrintRangeNode : function(control, feature, lonlat, icon, cursor ,tag)
	{
		icon.imageDiv.style.cursor = cursor;
		var marker = new OpenLayers.Marker(lonlat, icon);
		marker.linkid = feature.id;
		marker.tag = tag;
		this.printRangeNodeLayer.addMarker(marker);
		this.printRangeNodeMaker[this.printRangeNodeMaker.length] = marker;
		var self = this;

		if (control) {
			marker.events.register("mouseover", marker, function(){
				control.overFeature(this);
			});
			marker.events.register("mouseout", marker, function(){
				control.outFeature(this);
			});
		}
		// 初回アクション時にイベントが反応しない時がある為、一度トリガーさせる

		marker.events.triggerEvent("mouseover");
		marker.events.triggerEvent("mouseout");
	},

	/** 選択ノードドラッグ開始
	 * @parama marker ドラッグ開始されたマーカー
	 * @parama layer 対象レイヤ
	 */
	nodeDragStart : function(marker, layer)
	{
		if (!marker) return;
		var feature = layer.getFeatureById(marker.linkid);
		try {
			this.resizeOrigin = null;
			//外枠取得
			var bounds = feature.geometry.getBounds();
			//始点取得
			var x = 0;
			var y = 0;
			// 上下位置設定
			//if (this.dragEvent == "pdf"){
				// 上辺
				if (marker.tag.pos.indexOf("t") != -1){
					y = bounds.bottom;
				}
				// 下辺
				else if (marker.tag.pos.indexOf("b") != -1){
					y = bounds.top;
				}
				// その他
				else {
					y = ((bounds.bottom - bounds.top) / 2) + bounds.top;
				}
				// 左右位置設定
				// 右辺
				if (marker.tag.pos.indexOf("r") != -1){
					x = bounds.left;
				}
				// 左辺
				else if (marker.tag.pos.indexOf("l") != -1){
					x = bounds.right;
				}
				// その他
				else {
					x = ((bounds.right - bounds.left) / 2) + bounds.left;
				}
			//}
			//else{
			//	var isLeft = (marker.tag.pos.indexOf("l") != -1) ? true : false;
			//	var isTop = (marker.tag.pos.indexOf("t") != -1) ? true : false;
			//	x = (isLeft) ? bounds.right : bounds.left;
			//	y = (isTop) ? bounds.bottom : bounds.top;
			//}
			this.resizeOrigin = new OpenLayers.Geometry.Point(x,y);
			//Point内の変数に移動前のlonlat格納
			this.resizeOrigin.prevLon = marker.lonlat.lon;
			this.resizeOrigin.prevLat = marker.lonlat.lat;

			//選択解除と他のノードの非表示
			var markers = this.printRangeNodeLayer.markers;
			for (var i=markers.length-1; i>=0; i--) {
				if (markers[i] != marker) {
					this.printRangeNodeLayer.removeMarker(markers[i]);
				}
			}
		}
		catch (e) {
			console.error(e);
		}
	},
	/** 選択ノードドラッグ
	 * @parama marker ドラッグ中のマーカー
	 * @parama layer 対象レイヤ
	 */
	nodeDrag : function(marker, layer)
	{
		if (this.resizeOrigin) {
			var lonlat = marker.lonlat;
			var feature = layer.getFeatureById(marker.linkid);
			this.resizeFeature(feature, this.resizeOrigin, lonlat, layer ,marker.tag);
		}
	},
	/** 選択ノードドラッグ完了
	 * @parama marker ドラッグ完了したマーカー
	 * @parama layer 対象レイヤ
	 */
	nodeDragComplete : function(marker, layer)
	{
		try {
			if (this.resizeOrigin) {
				this.resizeOrigin = null;
				var feature = layer.getFeatureById(marker.linkid);
				this.setPrintRangeNode(((this.dragEvent == "pdf") ? this.printFeature:this.imageRangeFeature));
			}
		}
		catch (e) {
			console.error(e);
		}
	},
	/** 開始点と終了店の外接矩形内にfeatureをリサイズ
	 * @param feature リサイズするFeature
	 * @param originGeometry ドラッグ開始時の地図座標範囲 前回のリサイズ時のマウス位置も記録する
	 * @param lonlat マウス位置の地図座標
	 * @param layer 対象レイヤ
	 * @param tag タグ {math:計算方式}
	 */
	resizeFeature : function(feature, originGeometry, lonlat, layer ,tag)
	{
		try {
			var geometry = feature.geometry;
			var dx0 = originGeometry.prevLon - originGeometry.x;
			var dy0 = originGeometry.prevLat - originGeometry.y;
			var dx1 = lonlat.lon - originGeometry.x;
			var dy1 = lonlat.lat - originGeometry.y;

			originGeometry.prevLon = lonlat.lon;
			originGeometry.prevLat = lonlat.lat;
			var scale ;
			// 縦ベース
			if (tag.math == "y"){
				scale = dy1 / dy0;
			}
			// 横ベース
			else {
				scale = dx1 / dx0;
			}

			if(scale == 0) return;

			var ratio = 1;
			if (this.dragEvent != "pdf"){
				if (tag.pos.length == 2){
					ratio = (dx1 / dx0) / scale;
				}
				else{
					if (tag.math == "y"){
						ratio = 1 / scale;
					}
					else{
						var points = geometry.components;
						var bounds = feature.geometry.getBounds();
						var res = this.eMap.getResolution();
						points[0].y = bounds.bottom;
						points[1].y = bounds.top;
						points[2].y = bounds.top;
						points[3].y = bounds.bottom;
						points[4].y = bounds.bottom;
						if (tag.pos == "l"){
							bounds.left = lonlat.lon;
							points[0].x = bounds.left
							points[1].x = bounds.left;
							points[2].x = bounds.right;
							points[3].x = bounds.right;
							points[4].x = bounds.left;
						}
						else{
							bounds.right = lonlat.lon;
							points[0].x = bounds.left;
							points[1].x = bounds.left;
							points[2].x = bounds.right;
							points[3].x = bounds.right;
							points[4].x = bounds.left;
						}
					}
				}
			}
			if (!(this.dragEvent != "pdf" && (tag.pos == "l" || tag.pos == "r"))){
				geometry.resize(scale, originGeometry, ratio);
			}
			layer.drawFeature(feature);
		}
		catch (e) {
			console.error(e);
		}
	},

	getPageRange : function(bbox)
	{
		var me = this;
		var values = me.printPreviewWindow.getValues();
		
		//<span class="ja">bboxに内接する設定ページ設定の範囲を返却</span>
		//<span class="en">Return the range of page setting inside bbox</span>
		var paperType = values.pagesize.substr(0,1);
		var cols = values.cols;
		var rows = values.rows;
		var yoko = values.rotate=="1";
		//<span class="ja">仮想ページ高さを1としたときの幅を取得</span>
		//<span class="en">Get the width when considering virtual page's height as 1</span>
		var pageWidth = this.paperRate[paperType];
		if (yoko) pageWidth = 1/pageWidth;
		pageWidth = pageWidth*cols / rows;
		
		var w = bbox.getWidth();
		var h = bbox.getHeight();
		if (w/h < pageWidth) {
			//<span class="ja">高さを変える</span>
			//<span class="en">Change the height</span>
			h = w/pageWidth;
			var ch = (bbox.top+bbox.bottom)/2;
			return new OpenLayers.Bounds(bbox.left, ch-h/2, bbox.right,ch+h/2);
		} else {
			//<span class="ja">幅を変える</span>
			//<span class="en">Change the width</span>
			w = h*pageWidth;
			var cw = (bbox.right+bbox.left)/2;
			return new OpenLayers.Bounds(cw-w/2, bbox.bottom, cw+w/2, bbox.top);
		}
	},

	/** <span class="ja">範囲設定ダイアログ表示</span><span class="en">Display dialog to set the range</span> */
	showPdfRangeDialog : function()
	{
		var self = this;
		var printPreviewWindow = this.printPreviewWindow;
		var map = printPreviewWindow.stmap.map;
		if (!this.pdfRangeDialog) {
			var dialog = Ext.create('Ext.window.Window', {
				id: "pdfRangeDialog",
				title:lang.__('印刷範囲設定'),
				bodyStyle: {
					"padding": "5px",
					"text-align": "center",
					"background-Color": "white"
				},
				html: Ext.DomHelper.createHtml({
					tag: "div",
					children: [{
						tag: "div",
						html: '<span style="font-size:0.8em;white-space:nowrap;">'+
							lang.__('赤い枠をドラッグすると出力範囲が移動し、<br>各ノードをドラッグすると出力範囲の変更が出来ます。')+
							'</span>'
					}]
				}),
				closeAction: "hide",
				buttonAlign: "center",
				buttons: [{
					text: lang.__('範囲設定終了'),
					handler: function() {
						dialog.hide();
					}
				}]
			});
			dialog.on("hide",  function(){ self._hidedPdfRangeDialog(); });
			this.pdfRangeDialog = dialog;
		}

		// 地図画面の中央に表示
		this.pdfRangeDialog.show();
		var x = -this.pdfRangeDialog.getWidth()/2;
		var y = -this.pdfRangeDialog.getHeight()/2;
		this.pdfRangeDialog.alignTo("map", "c", [x, y]);
		
		this.dragEvent = "pdf";
		this.moveControl = new OpenLayers.Control.DragFeature(this.pdfRangeLayer,{
			dragCallbacks  : {
				down : function(e){
					self.moveFeatureStart(e);
					this.downFeature(e);
				},
				up : function(e){
					this.upFeature(e);
					self.moveFeatureEnd(e);
				}
			}
		});
		this.map.addControl(this.moveControl);
		this.moveControl.activate();
		this.setPrintRangeNode(this.printFeature);
		this.pdfRangeLayer.setVisibility(true);
		this.moveToFrontLayer(this.pdfRangeLayer);
		this.moveToFrontLayer(this.printRangeNodeLayer);
		this.pdfRangeLayer.setVisibility(true);
		this.printRangeNodeLayer.setVisibility(true);
	},
	moveFeatureStart : function(e){
		if (this.printRangeNodeMaker.length){
			this.printRangeNodeLayer.clearMarkers();
		}
	},
	moveFeatureEnd : function(e){
		this.setPrintRangeNode(this.printFeature);
	},
	moveImageFeatureStart : function(e){
		if (this.printRangeNodeMaker.length){
			this.printRangeNodeLayer.clearMarkers();
		}
	},
	moveImageFeatureEnd : function(e){
		this.setPrintRangeNode(this.imageRangeFeature);
	},
	/** <span class="ja">範囲設定ダイアログ非表示</span><span class="en">Hide the range setting dialog</span> */
	_hidedPdfRangeDialog : function()
	{
		var self = this;
		var printPreviewWindow = this.printPreviewWindow;
		var map = printPreviewWindow.stmap.map;
		printPreviewWindow.win.show();
		if (this.printRangeNodeMaker.length){
			this.printRangeNodeLayer.clearMarkers();
		}
		//<span class="ja">範囲ポリゴンの編集終了</span>
		//<span class="en">Finish editing range polygon</span>
		this.moveControl.deactivate();

		// BBOXを保存
		printPreviewWindow.values.bbox = this.getBBOX();

		// プレビュー画像を更新
		printPreviewWindow.showPreview();
	},

	getBBOX: function() {
		var bbox = null;
		if(!!this.printFeature) {
			var bounds = this.printFeature.geometry.getBounds();
			//if(!bounds) bounds = this.eMap.getBounds();
			//if (bounds) bounds = this.eMap.transformToLonLat(bounds, true);
			//else bounds = this.eMap.getBounds();
			var bbox =
				Math.min(bounds.left, bounds.right)+","+
				Math.min(bounds.bottom, bounds.top)+","+
				Math.max(bounds.left, bounds.right)+","+
				Math.max(bounds.bottom, bounds.top);
		}
		return bbox;
	},

	moveToFrontLayer : function(layer)
	{
		var me = this, self = this;
		var printPreviewWindow = this.printPreviewWindow;
		var map = printPreviewWindow.stmap.map;

		map.setLayerIndex(layer, map.layers.length);
		map.resetLayersZIndex();
	},

	////////////////////////////////////////////////////////////////
	// 印刷範囲保存
	////////////////////////////////////////////////////////////////

	/** <span class="ja">印刷範囲一覧ダイアログを表示する</span><span class="en">Display Search history list dialog</span> */
	showRangeListDialog : function()
	{
		var me = this, self = this, layer=this;
		var printPreviewWindow = me.printPreviewWindow;
		var stmap = printPreviewWindow.stmap;
		var map = stmap.map;

		if (!this.rangeListDialog) {
			var types = Ext.data.Types;
			Ext.define('SaigaiTask.model.PdfRange', {
				extend: 'Ext.data.Model',
				fields: [{
					name: 'id',
					type: types.NUMBER
				}, {
					name: 'name',
					type: types.STRING
				}, {
					name: 'created',
					type: types.STRING
				}, {
					name: 'options',
					type: types.STRING
				}, {
					name: 'range',
					type: types.STRING
				}, {
					name: 'status',
					type: types.INT
				}, {
					name: 'user_id',
					type: types.NUMBER
				}, {
					name: 'user_name',
					type: types.STRING
				}]
			});
			
			var dialog = Ext.create('Ext.window.Window', {
				id: "rangeListDialog",
				title:lang.__("印刷設定読み込み"),
				width: 420,
				height: 300,
				layout: "fit",
				items: [{
					xtype: "grid",
					loadMask: true,
					emptyText: lang.__("保存された印刷設定はありません。"),
					store: {
						model: "SaigaiTask.model.PdfRange",
						autoLoad: true,
						proxy: {
							type: "ajax",
							url: SaigaiTask.contextPath+"/page/map/pdfRange/list",
							reader: {
								type: "json",
								root: "items"
							}
						}
					},
					overflowY: "auto", // scrollbar
					layout: "column",
					columns: [{
						text: lang.__("印刷設定名称"),
						dataIndex: "name",
						width: 255
					}, {
						text: lang.__("保存日時"),
						dataIndex: "created",
						width: 150
					}]
				}],
				closeAction: "hide",
				buttonAlign: "left",
				buttons: [{
					icon: stmap.icon.getURL("folderOpenIconURL"),
					text: lang.__('印刷設定読み込み'),
					handler: function() {
						alert("実装中");
						dialog.hide();
					}
				}, {
					xtype: "checkbox",
					boxLabel: lang.__('印刷範囲のみ')
				}, {
					xtype: "tbfill"
				}, {
					icon: stmap.icon.getURL("deleteIconURL"),
					text: lang.__('削除'),
					handler: function() {
						alert("実装中");
					}
				}, {
					xtype: "tbfill"
				}, {
					icon: stmap.icon.getURL("closeIconURL"),
					text: lang.__('閉じる'),
					handler: function() {
						alert("実装中");
						dialog.hide();
					}
				}],
				listeners: {
					hide: function() {
						// 印刷ダイアログを表示
						printPreviewWindow.win.show();
					}
				}
			});
			this.rangeListDialog = dialog;
			this.rangeListDialog.show();
			var x = -dialog.getWidth()/2;
			var y = -dialog.getHeight()/2;
			this.rangeListDialog.alignTo("map", "c", [x, y]);
		} else {
			this.rangeListDialog.show();
			this.onRangeListSelect();
			//<span class="ja">リスト更新</span><span class="en">Update list</span>
			this.initRangeList();
		}
		this.pdfDialog.domNode.style.display='none';
	},
	/** <span class="ja">検索履歴読み込み一覧ダイアログを閉じる</span><span class="en">Read the search history and close list dialog</span> */
	closeRangeListDialog : function()
	{
		if (this.rangeListDialog) this.rangeListDialog.hide();
		this.pdfDialog.domNode.style.display='';
	},

	CLASS_NAME: "SaigaiTask.Map.Layer.PdfRangeLayer"
});
/* ======================================================================
    SaigaiTask/Map/view/SelectFeatureWindow.js
   ====================================================================== */

/**
 * 登録情報ウィンドウ
 * @require SaigaiTask/Map/view.js
 * @returns {SaigaiTask.Map.view.SelectFeatureWindow}
 */
SaigaiTask.Map.view.SelectFeatureWindow = function() {
	this.initialize.apply(this, arguments);
};

SaigaiTask.Map.view.SelectFeatureWindow.prototype = {

	stmap: null,

	/**
	 * @type {Ext.window.Window}
	 */
	window: null,

	/**
	 * @type {Ext.grid.Panel}
	 */
	grid: null,

	/**
	 * 選択解除
	 * Ext.grid.column.Action の items に登録した Object
	 * @type {Object}
	 */
	removeActionColumnItem: null,

	/**
	 * 一括変更ボタン
	 * @type {Ext.button.Button}
	 */
	slimerButton: null,

	/**
	 * 登録情報ウィンドウを表示します.
	 * @param option.stmap 地図オブジェクト
	 */
	initialize: function(option) {
		var me = this;
		var stmap = option.stmap;
		var featureData = option.featureData;
		var nameAttr = featureData.nameAttr;

		// グリッドパネルの作成
		var fields = ["nameAttr", "layerId", "featureId"];
		var store = Ext.create("Ext.data.ArrayStore",{
			fields: fields,
			data: [fields] // ダミーデータとしてフィールドを登録
		});
		me.removeActionColumnItem = {
			icon: stmap.icon.getURL("removeIconURL"),
			tooltip: lang.__("Cancel<!--4-->")
		};
		me.grid = Ext.create('Ext.grid.Panel',{
			store: store,
			stateful: true,
			collapsible: false,
			multiSelect: false,
			header: false,
			width: 250,
//			closable: true,
			frame: false,
			stateId: 'stateGrid',
			columns: [{
				//text: nameAttr[1],
				text: lang.__("Name"),
				dataIndex: "nameAttr",
				flex: 1
			}, {
				xtype: "actioncolumn",
				width: 30,
				//text: "解除",
				items: [me.removeActionColumnItem],
				renderer : function(val, metadata, record) {
					metadata.style = 'cursor: pointer;';
					return val;
				}
			}],
			viewConfig: {
				stripeRows: true,
				enableTextSelection: true
			}
		});

		// グリッド作成後にダミーデータを削除
		store.removeAll();
		me.add(featureData);

		// ウィンドウを生成
		me.slimerButton = Ext.create("Ext.button.Button", {
			text: lang.__('Bulk change'),
			textAlign: "center"
		});
		me.window = Ext.create('Ext.window.Window', {
			title: lang.__('Hide select.<!--2-->'),
			width: 300, //height: 600,
			maxWidth: document.body.clientWidth,
			maxHeight: document.body.clientHeight,
			collapsible: true,
			layout: 'fit',
			items: me.grid,
			dockedItems: [{
				xtype: 'toolbar',
				dock: 'bottom',
				ui: 'footer',
				layout: 'fit',
				items: [me.slimerButton]
			}]
		});
	},

	/**
	 * フィーチャをグリッドに追加します.
	 * @param {SaigaiTask.Map.control.SelectFeatureControl.FeatureData} featureData
	 */
	add: function(featureData) {
		var me = this;
		var grid = me.grid;
		var store = grid.getStore();
		store.add({
			"nameAttr": featureData.nameAttr[1]+":"+featureData.nameAttr[2],
			"layerId": featureData.layerId,
			"featureId": featureData.featureId
		});
	},

	/**
	 * フィーチャをグリッドから削除します.
	 * @param {SaigaiTask.Map.control.SelectFeatureControl.FeatureData} featureData
	 */
	remove: function(featureData) {
		var me = this;
		var grid = me.grid;
		var store = grid.getStore();
		var index = store.findBy(function(record, id) {
			var data = record.getData();
			if(data.layerId!=featureData.layerId) return false;
			if(data.featureId!=featureData.featureId) return false;
			return true;
		});
		if(index!=-1) {
			store.removeAt(index);
		}
	},

	/**
	 * ウィンドウを表示します.
	 */
	show: function() {
		var me = this;
		var win = me.window;
		win.show();
		win.alignTo(document, "tr", [-win.getWidth(), 0/*-win.getHeight()*/]);
	}
};
/* ======================================================================
    SaigaiTask/Map/view/Measure.js
   ====================================================================== */

/**
 *
 *  @requires SaigaiTask/Map/view.js
 *  author: nakano
 *  距離面積計測機能
 */

SaigaiTask.Map.view.Measure = function() {
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.Measure.prototype = {

		map: null,
		measure: null,
		/** 距離計測コントロール */
		DIST : null,
		/** 面積計測コントロール */
		AREA : null,
		/** 円計測コントロール */
		CIRCLE : null,

		/** 計測結果表示用 */
		measureLayer : null,

		/** 描画予定の図形種別 */
		featureMode : "LINE",

		/** 初期化フラグ */
		initdrawlayer : true,
		/**
		 * コンストラクタ
		 */
		initialize: function(map) {
			var me = this;
			me.map = map;
			distresult = 0;
			arearesult = 0;
			// イベントの設定
			me.onEvent();
/*
			me.measure = Ext.create("Ext.button.Button", {
				//text : '距離面積計測',
				icon: map.icon.getURL("rulerIconURL"),
				//margin : "0 5 0 5",
				tooltip: '距離面積計測',
				listeners: {
					click: function() {
						me.showMenu();
						//me.onEvent();
					}
				}
			});
*/
		},

		/** 各種イベントの設定**/
		onEvent : function(){
			var me = this;
			/* 計測モードで描画したものを計測 */
			if(typeof map.components.contentsFormWindow == "undefined" || map.components.contentsFormWindow == null || !(!!map.components.contentsFormWindow && map.components.contentsFormWindow.drawToolbar.drawLayer.layer.visibility)){
				// 距離を計測
				$(document).on('click','#measure_type_dist',function(){
					me.startMeasureDist();
				});
				// 面積を計測
				$(document).on('click','#measure_type_area',function(){
					me.startMeasureArea();
				});
				// 人口と世帯数表示
				$(document).on('click','#measure_type_people',function(){
					me.startMeasurePeople();
				});
			}
			/* 新規登録で描画したものを計測 */
			else{
				me.startMeasure();
			}

		},

		offEvent : function(){
			var me = this;
			$(document).off('click','#measure_type_dist');
			$(document).off('click','#measure_type_area');
			$(document).off('click','#measure_type_people');
		},

		/** 距離計測開始 */
		startMeasureDist : function()
		{
			var me = this;
			me.featureMode = "DIST";
			me.initMeasureLayer();
			me.setPanelVisible('DIST');
			$("#measure_dist").attr('value', "0");
			$("#measure_dist_units").attr('value', "");
			me._startMeasure(false);
		},
		/** 面積計測開始 */
		startMeasureArea : function()
		{
			var me = this;
			// 面積と人口を切り替える時は初期化しないようにする
			if(me.featureMode != "PEOPLE"){
				me.initMeasureLayer();
				me._startMeasure(true);
				$("#measure_area").attr('value', "0");
				$("#measure_area_units").attr('value', "");
			}
			me.featureMode = "AREA";
			me.setPanelVisible('AREA');
			//this.setPanelVisible('OUTER');
		},
		/** 人口数計測開始 */
		startMeasurePeople : function()
		{
			var me = this;
			// 面積と人口を切り替える時は初期化しないようにする
			if(me.featureMode != "AREA"){
				me.initMeasureLayer();
				me._startMeasure(true);
				$("#measure_people").attr('value', "0");
				$("#measure_house").attr('value', "0");
			}
			me.featureMode = "PEOPLE";
			me.setPanelVisible('PEOPLE');

		},
		/** 登録レイヤの計測開始 */
		startMeasure : function()
		{
			$("#measure_dist_span").css('display',"");
			$("#measure_area_span").css('display',"");
			$("#measure_people_span").css('display',"")
			$("#buttons").hide();

			this._startMeasure(true);
		},
		/** 計測結果レイヤを初期化して地図に追加 */
		initMeasureLayer : function()
		{
			if (this.measureLayer) {
				//形状削除
				this.measureLayer.removeAllFeatures(this.measureLayer.features);
			} else {
				//生成
				this.measureLayer = new OpenLayers.Layer.Vector(lang.__("Measurement results"));
			}
			//スタイル設定

			this.map.map.addLayer(this.measureLayer);
		},

		stopMeasure : function()
		{
			//ラジオを未選択に
			//$("#measure_type_dist").attr("checked", false);
			//$("#measure_type_area").attr("checked", false);
			//this.setPanelVisible();
			//$("#measure_widget").toggle();
			this._deactivateMeasure();
			if(this.measureLayer){
				this.map.map.removeLayer(this.measureLayer);
				this.measureLayer = null;
				distresult = 0;
				arearesult = 0;
			}
			$('#measure').dialog('close');
		},

		setPanelVisible : function(type)
		{
			var distDisplay = type=="DIST" ? "block" : "none";
			var areaDisplay = type=="AREA" ? "block" : "none";
			//var outerDisplay = type=="OUTER" ? "" : "none";
			var peopleDisplay = type=="PEOPLE" ? "block" : "none";
			var controlDisplay = type ? "block" : "none";
			$("#measure_dist_span").css('display',distDisplay);
			$("#measure_area_span").css('display',areaDisplay);
			//$("#measure_outer_span").css('display',outerDisplay);
			$("#measure_people_span").css('display',peopleDisplay);
			$("#measure_control_span").css('display',controlDisplay);
		},

		addCenterMeasure : function()
		{
			var lonlat = this.map.map.getCenter();
			this._addMeasurePoint(lonlat.lon, lonlat.lat);
		},
		undoMeasurePoint : function()
		{
			this._undoMeasurePoint();
		},

		////////////////////////////////
		//	計測
		/** 計測開始 */
		_startMeasure : function(areadraw)
		{
			var me = this;
			//初期化
			if (!me.DIST) {
				var style = new OpenLayers.Style();
				style.addRules([new OpenLayers.Rule({symbolizer:{
					"Point": {pointRadius: 4,graphicName: "square",fillColor: "#FFFFFF",fillOpacity: 1,strokeWidth: 1,strokeOpacity: 1,strokeColor: "#333333"},
					"Line": {strokeWidth: 3,strokeOpacity: 1,strokeColor: "#FF0000",strokeDashstyle: "dash"},
					"Polygon": {strokeWidth: 2,strokeOpacity: 1,strokeColor: "#FF0000",fillColor: "#FFFFFF",fillOpacity: 0.3}
				}})]);

				var measureOptions = {
						handlerOptions: {
							style:"default",
							layerOptions:{
								styleMap:new OpenLayers.StyleMap({"default":style})
							},
							persist:true/*, move: function(){if(!!map.components.contentsFormWindow && map.components.contentsFormWindow.drawToolbar.drawLayer.layer.visibility){me.stopMeasure();}}*/
						}
				};
				me.DIST = new OpenLayers.Control.Measure(OpenLayers.Handler.Path, measureOptions);
				me.DIST.geodesic = true;
				me.map.map.addControl(me.DIST);

				me.AREA = new OpenLayers.Control.Measure(OpenLayers.Handler.Polygon, measureOptions);
				me.AREA.geodesic = true;
				me.map.map.addControl(me.AREA);

				me.CIRCLE = new OpenLayers.Control.Measure(OpenLayers.Handler.RegularPolygon, {
					handlerOptions: {sides: 40}, // 頂点数
					eventListeners: {
						"deactivate": function() {
							// 前の半径ポップアップがあったら閉じる
							if(!!stmap.popupManager) {
								stmap.popupManager.closeAll();
							}
						}
					},
					callbacks: {
						// dragging
						"move": function(geometry) {
							// 円の半径を求める
							// 単位がメートルの座標系に変換
							if(map.map.units!="m") {
								geometry = geometry.clone().transform(map.map.getProjectionObject(), new OpenLayers.Projection("EPSG:900913"));
							}
							// 円の面積 A = Pi * r^2
							// r = Sqrt(A / Pi) = 0.56419 * Sqrt(A)
							var area = geometry.getArea();
							var radius = 0.565352 * Math.sqrt(area);

							// 前の半径ポップアップがあったら閉じる
							if(!!stmap.popupManager) {
								stmap.popupManager.closeAll();
							}

							// 円の半径を表示する
							var centroid = geometry.getCentroid();
							var center = new OpenLayers.LonLat(centroid.x, centroid.y).transform(stmap.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));
							popup = new SaigaiTask.Map.view.Popup();
							var radiusText = parseInt(radius)+"m";
							if(10000 < radius) radiusText =(radius/1000).toFixed(2)+"km";
							popup.showExtPopup({
								map: stmap,
								olmap: stmap.map,
								center: center,
								size: new OpenLayers.Size(150,10),
								title: radiusText
							});
						}
					}
				}, measureOptions);
				me.CIRCLE.geodesic = true;
				me.map.map.addControl(me.CIRCLE);

				//ダブルクリック無効
				//this.DIST.handler.dblclick = this.mapControls['MEASURE'].handler.click;
				//this.AREA.handler.dblclick = this.mapControls['MEASUREAREA'].handler.click;

				this.DIST.partialDelay = 0;
				this.AREA.partialDelay = 0;
				this.CIRCLE.partialDelay = 0;
			}

			var contentsFormWindow = map.components.contentsFormWindow;
			// 登録情報編集ウィンドウが表示されているかチェック
			if(!!contentsFormWindow && contentsFormWindow.drawToolbar.drawLayer.layer.visibility) {
				var drawToolbar = contentsFormWindow.drawToolbar;
				var features = drawToolbar.drawLayer.drawFeatures;
				var linebtn, polygonbtn, circlebtn, modifybtn;

				for(i = 0;i < drawToolbar.tbarItems.length; i++){
					if(drawToolbar.tbarItems[i].iconCls == "draw-line-icon")
						linebtn = drawToolbar.tbarItems[i];
					if(drawToolbar.tbarItems[i].iconCls == "draw-polygon-icon")
						polygonbtn = drawToolbar.tbarItems[i];
					if(drawToolbar.tbarItems[i].iconCls == "draw-circle-icon")
						circlebtn = drawToolbar.tbarItems[i];
				}

				var drawLayer =  contentsFormWindow.drawToolbar.drawLayer;
				if(me.initdrawlayer){
					drawLayer.layer.events.on({
						"featureadded": function(evt) {
							var distunit = $("#measure_dist_units").html() == 'm';
							if(distunit){
								var dist = parseFloat($("#measure_dist").val());
							}else{
								var dist = parseFloat($("#measure_dist").val()) * 1000;
							}
							var areaunit = $("#measure_area_units").html() == 'm';
							if(areaunit){
								var area = parseFloat($("#measure_area").val());
							}else{
								var area = parseFloat($("#measure_area").val()) * 1000000;
							}
							var peopleval = $("#measure_people").val();
							if (typeof peopleval == "undefined") var people = 0;
							else {
								if (peopleval.indexOf(",") != -1) var people = parseInt(peopleval.split(',').join('').trim());
								else var people = parseInt(peopleval);
							}
							var houseval = $("#measure_house").val();
							if (typeof houseval == "undefined") var house = 0;
							else{
								if (houseval.indexOf(",") != -1) var house = parseInt(houseval.split(',').join('').trim());
								else var house = parseInt(houseval);
							}
							if(linebtn.pressed){
								var line = Math.floor(me.DIST.getBestLength(features.line[features.line.length-1].geometry)[0]*1000)/1000.0;
								if(me.DIST.getBestLength(features.line[features.line.length-1].geometry)[1] == 'km')
									line *= 1000;
								dist += line;
								dist = dist.toPrecision(4);
								if(dist < 1000){
									$("#measure_dist").attr('value', dist);
									$("#measure_dist_units").html('m');
								}else{
									$("#measure_dist").attr('value', dist/1000);
									$("#measure_dist_units").html('km');
								}
							}
							else if(polygonbtn.pressed){
								var polygon = Math.floor(me.AREA.getBestArea(features.polygon[features.polygon.length-1].geometry)[0]*1000)/1000.0;
								if(me.AREA.getBestArea(features.polygon[features.polygon.length-1].geometry)[1] == 'km')
									polygon *= 1000000;
								area = parseFloat(area);
								area += polygon;

								var polygons = features.polygon[features.polygon.length-1].geometry.clone().transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
								var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+polygons, SaigaiTask.csrfToken);
								ajaxData.doAjax()
								.done(function(data, statusText, jqXHR){
									if('people' in data){
										people += data.people;
									}
									if('house' in data){
										house += data.house;
									}
									$("#measure_people").attr('value', separateComma(people));
									$("#measure_house").attr('value', separateComma(house));
								}).fail(function(jqXHR, statusText, errorThrown){
									console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
								});

							}
							else if (circlebtn.pressed){
								var circle = Math.floor(me.CIRCLE.getBestArea(features.circle[features.circle.length-1].geometry)[0]*1000)/1000.0;
								if(me.CIRCLE.getBestArea(features.circle[features.circle.length-1].geometry)[1] == 'km')
									circle *= 1000000;
								area = parseFloat(area);
								area += circle;

								var circles = features.circle[features.circle.length-1].geometry.clone().transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
								var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+circles, SaigaiTask.csrfToken);
								ajaxData.doAjax()
								.done(function(data, statusText, jqXHR){
									if('people' in data){
										people += data.people
									}
									if('house' in data){
										house += data.house;
									}
									$("#measure_people").attr('value', separateComma(people));
									$("#measure_house").attr('value', separateComma(house));
								}).fail(function(jqXHR, statusText, errorThrown){
									console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
								});
							}
							area = area.toPrecision(6);
							if(area < 1000000){
								$("#measure_area").attr('value', area);
								$("#measure_area_units").html('m');
							}else{
								$("#measure_area").attr('value', area/1000000);
								$("#measure_area_units").html('km');
							}
							/*$("#measure_people").attr('value', people);
							$("#measure_house").attr('value', house);*/
						},
						"featureremoved" : function(evt){
							dist = 0;
							dist = dist.toPrecision(4);
							area = 0;
							area = area.toPrecision(6);
							$("#measure_dist").attr('value', dist);
							$("#measure_area").attr('value', area);
							$("#measure_people").attr('value', "0");
							$("#measure_house").attr('value', "0");
							features.polygon = [];
							features.circle = [];
							features.line = [];
						},
						"featuremoved" : function(evt) {
							var people = 0;
							var house = 0;
							for(i = 0;i < features.polygon.length;i++){
								var polygons = features.polygon[i].geometry.clone().transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
								var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+polygons, SaigaiTask.csrfToken);
								ajaxData.doAjax()
								.done(function(data, statusText, jqXHR){
									if('people' in data){
										people += data.people;
									}
									if('house' in data){
										house += data.house;
									}
									$("#measure_people").attr('value', separateComma(people));
									$("#measure_house").attr('value', separateComma(house));
								}).fail(function(jqXHR, statusText, errorThrown){
									console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
								});
							}
							for(i = 0;i < features.circle.length;i++){
								var circles = features.circle[i].geometry.clone().transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
								var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+circles, SaigaiTask.csrfToken);
								ajaxData.doAjax()
								.done(function(data, statusText, jqXHR){
									if('people' in data){
										people += data.people;
									}
									if('house' in data){
										house += data.house;
									}
									$("#measure_people").attr('value', separateComma(people));
									$("#measure_house").attr('value', separateComma(house));
								}).fail(function(jqXHR, statusText, errorThrown){
									console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
								});
							}
						},
						"featuremodified" : function(evt){
							if(evt.feature.geometry.id.match("LineString")){
								dist = 0;
								for(i = 0;i < features.line.length; i++){
									var line = Math.floor(me.DIST.getBestLength(features.line[i].geometry)[0]*1000)/1000.0;
									if(me.DIST.getBestLength(features.line[i].geometry)[1] == 'km')
										line *= 1000;
									dist = parseFloat(dist);
									dist += line;
									dist = dist.toPrecision(4);
									if(dist < 1000){
										$("#measure_dist").attr('value', dist);
										$("#measure_dist_units").html('m');
									}else{
										$("#measure_dist").attr('value', dist/1000);
										$("#measure_dist_units").html('km');
									}
								}
							}else if(evt.feature.geometry.id.match("Polygon")){
								area = 0;
								for(i = 0;i < features.polygon.length; i++){
									var polygon = Math.floor(me.AREA.getBestArea(features.polygon[i].geometry)[0]*1000)/1000.0;
									if(me.AREA.getBestArea(features.polygon[i].geometry)[1] == 'km')
										polygon *= 1000000;
									area = parseFloat(area);
									area += polygon;
								}
								for(i = 0;i < features.circle.length; i++){
									var circle = Math.floor(me.CIRCLE.getBestArea(features.circle[i].geometry)[0]*1000)/1000.0;
									if(me.CIRCLE.getBestArea(features.circle[i].geometry)[1] == 'km')
										circle *= 1000000;
									area = parseFloat(area);
									area += circle;
								}
								area = area.toPrecision(6);
								if(area < 1000000){
									$("#measure_area").attr('value', area);
									$("#measure_area_units").html('m');
								}else{
									$("#measure_area").attr('value', area/1000000);
									$("#measure_area_units").html('km');
								}
								var people = 0;
								var house = 0;
								for(i = 0;i < features.polygon.length;i++){
									var polygons = features.polygon[i].geometry.clone().transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
									var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+polygons, SaigaiTask.csrfToken);
									ajaxData.doAjax()
									.done(function(data, statusText, jqXHR){
										if('people' in data){
											people += data.people;
										}
										if('house' in data){
											house += data.house;
										}
										$("#measure_people").attr('value', separateComma(people));
										$("#measure_house").attr('value', separateComma(house));
									}).fail(function(jqXHR, statusText, errorThrown){
										console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
									});
								}
								for(i = 0;i < features.circle.length;i++){
									var circles = features.circle[i].geometry.clone().transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
									var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+circles, SaigaiTask.csrfToken);
									ajaxData.doAjax()
									.done(function(data, statusText, jqXHR){
										if('people' in data){
											people += data.people;
										}
										if('house' in data){
											house += data.house;
										}
										$("#measure_people").attr('value', separateComma(people));
										$("#measure_house").attr('value', separateComma(house));
									}).fail(function(jqXHR, statusText, errorThrown){
										console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
									});
								}
							}
						}
					});
					me.initdrawlayer = false;
				}
			}else{
				var control = areadraw?this.AREA:this.DIST;
				this._deactivateMeasure();
				var self = this;
				control.activate();
				control.events.on({
					"measurepartial": this.measureCallback,
					"measure": function(event){
						self.measureComplete(event);
					}
				});
			}
		},
		/** ダブルクリックで計測完了時のCallback */
		measureComplete : function(event)
		{

			//計測結果Vectorレイヤにコピー
			this.measureLayer.addFeatures([new OpenLayers.Feature.Vector(event.geometry)]);

			this._deactivateMeasure();
			//ラジオを未選択に
			/*
			$("#measure_type_dist").attr("checked", false);
			$("#measure_type_area").attr("checked", false);
			*/

			var me = this;
			if(!event.geometry.toString().search('LINESTRING')){
				if($("#measure_dist_units").text() == 'km'){
					if(event.units == 'km'){
						//distresult = distresult + Math.floor(event.measure * 1000) / 1000.0;
						distresult = Math.floor(event.measure * 1000) / 1000.0;
					}else{
						//distresult = distresult + Math.floor(event.measure * 1000) / 1000.0 * 0.001;
						distresult = Math.floor(event.measure * 1000) / 1000.0 * 0.001;
					}
					$("#measure_dist_units").html('km');
				}else{
					if(event.units == 'km'){
						//distresult = distresult + Math.floor(event.measure * 1000) / 1000.0 * 1000;
						distresult = Math.floor(event.measure * 1000) / 1000.0 * 1000;
					}else{
						//distresult = distresult + Math.floor(event.measure * 1000) / 1000.0;
						distresult = Math.floor(event.measure * 1000) / 1000.0;
					}
					if(distresult < 1000){
						$("#measure_dist_units").html('m');
					}else{
						distresult = distresult * 0.001;
						$("#measure_dist_units").html('km');
					}
				}
				// 有効桁数4桁にする
				distresult = distresult.toPrecision(4);
				$("#measure_dist").attr('value', distresult);
			}

			if(!event.geometry.toString().search('POLYGON')){

				if(me.featureMode == "AREA" || me.featureMode == "PEOPLE"){
					// 描画完了時に演算する
					var polygons = event.geometry.transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
					var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+polygons, SaigaiTask.csrfToken);
					ajaxData.doAjax()
					.done(function(data, statusText, jqXHR){
						if('people' in data){
							$("#measure_people").attr('value', separateComma(data.people));
						}else{
							$("#measure_people").attr('value', "0");
						}
						if('house' in data){
							$("#measure_house").attr('value', separateComma(data.house));
						}else{
							$("#measure_house").attr('value', "0");
						}
					}).fail(function(jqXHR, statusText, errorThrown){
						console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
					});
				}

				if($("#measure_area_units").text() == 'km'){
					if(event.units == 'km'){
						arearesult = Math.floor(event.measure * 1000000) / 1000000.0;
					}else{
						arearesult = Math.floor(event.measure * 1000000) / 1000000.0 * 1.0e-6;
					}
					$("#measure_area_units").html('km');
				}else{
					if(event.units == 'km'){
						arearesult = Math.floor(event.measure * 1000000) / 1000000.0 * 1.0e+6;
					}else{
						arearesult = Math.floor(event.measure * 1000000) / 1000000.0;
					}
					if(arearesult < 1.0e+6){
						$("#measure_area_units").html('m');
					}else{
						arearesult = arearesult * 1.0e-6;
						$("#measure_area_units").html('km');
					}
				}
				// 有効桁数6桁にする
				arearesult = arearesult.toPrecision(6);
				$("#measure_area").attr('value', arearesult);
			}
		},

		/** 計測を終了 */
		_deactivateMeasure : function()
		{
			var control = this.DIST;
			if (control) {
				control.events.remove("measure");
				control.events.remove("measurepartial");
				control.deactivate();
			}
			var control = this.AREA;
			if (control) {
				control.events.remove("measure");
				control.events.remove("measurepartial");
				control.deactivate();
			}
		},

		/**
		 * 距離・面積計測を行うためのメニューを表示します
		 */
		showMenu: function() {
			var self = this;
			$('#measure').remove();
			$('#content_main').append('<div id="measure" style="display:none;">');
			// 登録フォームが表示されていなければ、計測用のジオメトリを描画し計測
			if(map.components.contentsFormWindow == null || !(!!map.components.contentsFormWindow && map.components.contentsFormWindow.drawToolbar.drawLayer.layer.visibility)){
				$('#measure').load(SaigaiTask.PageURL.baseurl + 'measure/measure/', function(responseText, textStatus, jqXHR){
					if(!(!!map.components.contentsFormWindow && map.components.contentsFormWindow.drawToolbar.drawLayer.layer.visibility)){
						self.onEvent();
					}
				});
			// 登録フォームが表示されていれば登録するジオメトリの計測
			}else{
				$('#measure').load(SaigaiTask.PageURL.baseurl + 'measure/measure/', function(responseText, textStatus, jqXHR) {
					//self.onEvent();
					// ラジオを消す
					$("#buttons").attr("style","display:none")
					// 距離INPUT表示
					$("#measure_dist_span").css('display',"block");
					// 面積INPUT表示
					$("#measure_area_span").css('display',"block");
					// 人口INPUT表示
					$("#measure_people_span").css('display',"block");
					// 計測結果の初期化(距離は有効数字4桁、面積は有効数字6桁)
					dist = 0;
					dist = dist.toPrecision(4);
					area = 0;
					area = area.toPrecision(6);
					$("#measure_dist").attr('value', dist);
					$("#measure_area").attr('value', area);
					$("#measure_people").attr('value', "0");
					$("#measure_house").attr('value', "0");

					if(!this.DIST){

						var style = new OpenLayers.Style();
						style.addRules([new OpenLayers.Rule({symbolizer:{
							"Point": {pointRadius: 4,graphicName: "square",fillColor: "#FFFFFF",fillOpacity: 1,strokeWidth: 1,strokeOpacity: 1,strokeColor: "#333333"},
							"Line": {strokeWidth: 3,strokeOpacity: 1,strokeColor: "#FF0000",strokeDashstyle: "dash"},
							"Polygon": {strokeWidth: 2,strokeOpacity: 1,strokeColor: "#FF0000",fillColor: "#FFFFFF",fillOpacity: 0.3}
						}})]);
						var measureOptions = {handlerOptions: {style:"default", layerOptions:{styleMap:new OpenLayers.StyleMap({"default":style})}, persist:true }};
						var me = this;
						me.DIST = new OpenLayers.Control.Measure(OpenLayers.Handler.Path, measureOptions);
						me.DIST.geodesic = true;
						map.map.addControl(me.DIST);
						me.AREA = new OpenLayers.Control.Measure(OpenLayers.Handler.Polygon, measureOptions);
						me.AREA.geodesic = true;
						map.map.addControl(me.AREA);
						me.CIRCLE = new OpenLayers.Control.Measure(OpenLayers.Handler.RegularPolygon, {
							handlerOptions: {sides: 40}, // 頂点数
							eventListeners: {
								"deactivate": function() {
									// 前の半径ポップアップがあったら閉じる
									if(!!stmap.popupManager) {
										stmap.popupManager.closeAll();
									}
								}
							},
							callbacks: {
								// dragging
								"move": function(geometry) {
									// 円の半径を求める
									// 単位がメートルの座標系に変換
									if(map.map.units!="m") {
										geometry = geometry.clone().transform(map.map.getProjectionObject(), new OpenLayers.Projection("EPSG:900913"));
									}
									// 円の面積 A = Pi * r^2
									// r = Sqrt(A / Pi) = 0.56419 * Sqrt(A)
									var area = geometry.getArea();
									var radius = 0.565352 * Math.sqrt(area);

									// 前の半径ポップアップがあったら閉じる
									if(!!stmap.popupManager) {
										stmap.popupManager.closeAll();
									}

									// 円の半径を表示する
									var centroid = geometry.getCentroid();
									var center = new OpenLayers.LonLat(centroid.x, centroid.y).transform(stmap.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));
									popup = new SaigaiTask.Map.view.Popup();
									var radiusText = parseInt(radius)+"m";
									if(10000 < radius) radiusText =(radius/1000).toFixed(2)+"km";
									popup.showExtPopup({
										map: stmap,
										olmap: stmap.map,
										center: center,
										size: new OpenLayers.Size(150,10),
										title: radiusText
									});
								}
							}
						});
						me.CIRCLE.geodesic = true;
						map.map.addControl(me.CIRCLE);
					}
					var contentsFormWindow = map.components.contentsFormWindow;
					var drawToolbar = contentsFormWindow.drawToolbar;
					var features = drawToolbar.drawLayer.drawFeatures;
					var dist = 0;
					var area = 0;
					var people = 0;
					var house = 0;
					for(var i=0; i<features.line.length;i++){
						var line = Math.floor(me.DIST.getBestLength(features.line[i].geometry)[0]*1000)/1000.0;
						if(me.DIST.getBestLength(features.line[i].geometry)[1] == 'km')
							line *= 1000;
						dist += line;
					}
					dist = dist.toPrecision(4);
					if(dist < 1000){
						$("#measure_dist").attr('value', dist);
						$("#measure_dist_units").html('m');
					}else{
						$("#measure_dist").attr('value', dist/1000);
						$("#measure_dist_units").html('km');
					}
					for(var i=0; i< features.polygon.length;i++){
						var polygon = Math.floor(me.AREA.getBestArea(features.polygon[i].geometry)[0]*1000000)/1000000.0;
						if(me.AREA.getBestArea(features.polygon[i].geometry)[1] == 'km')
							polygon *= 1000000;
						area += polygon;

						var polygons = features.polygon[i].geometry.clone().transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
						var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+polygons, SaigaiTask.csrfToken);
						ajaxData.doAjax()
						.done(function(data, statusText, jqXHR){
							if('people' in data){
								people += data.people
							}
							if('house' in data){
								house += data.house;
							}
							$("#measure_people").attr('value', separateComma(people));
							$("#measure_house").attr('value', separateComma(house));
						}).fail(function(jqXHR, statusText, errorThrown){
							console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
						});
					}
					for(var i=0; i< features.circle.length;i++){
						var circle = Math.floor(me.CIRCLE.getBestArea(features.circle[i].geometry)[0]*1000000)/1000000.0;
						if(me.CIRCLE.getBestArea(features.circle[i].geometry)[1] == 'km')
							circle *= 1000000;
						area += circle;

						var circles = features.circle[i].geometry.clone().transform(new OpenLayers.Projection("EPSG:"+map.epsg), new OpenLayers.Projection("EPSG:4326")).toString();
						var ajaxData = new GetDatas(SaigaiTask.contextPath+"/page/decisionsupport/JSON_WKTAreaPeople", "wkts="+circles, SaigaiTask.csrfToken);
						ajaxData.doAjax()
						.done(function(data, statusText, jqXHR){
							if('people' in data){
								people += data.people
							}
							if('house' in data){
								house += data.house;
							}
							$("#measure_people").attr('value', separateComma(people));
							$("#measure_house").attr('value', separateComma(house));
						}).fail(function(jqXHR, statusText, errorThrown){
							console.log("JSON_BBOXAreaPeople is error! StatusCode=" + jqXHR.status);
						});
					}
					area = area.toPrecision(6);
					if(area < 1000000){
						$("#measure_area").attr('value', area);
						$("#measure_area_units").html('m');
					}else{
						$("#measure_area").attr('value', area/1000000);
						$("#measure_area_units").html('km');
					}
					// ここだけ対応すれば良い？？
					$("#measure_people").attr('value',separateComma(people));
					$("#measure_house").attr('value',separateComma(house));

				});
			}

			$('#buttons').css('display', 'none');
			$('#measure').dialog({
				title: lang.__("Measure distance and area"),
				position: {
				    my: "top",
				    at: "top",
				    of: window
				},
				buttons: [{
					text: lang.__("Close"),
					click: function() {
						self.stopMeasure();
						self.offEvent();
						$('#measure').dialog('destroy');
						$('#measure').remove();
						return false;
					}
				}],
				close: function(){
					self.stopMeasure();
					self.offEvent();
					$('#measure').dialog('destroy');
					$('#measure').remove();
				}
			});
		}
}

// Ajax用クラス
function GetDatas(){
	this.initialize.apply(this, arguments);
}
GetDatas.prototype = {
	initialize : function(url, param, token){
		this.url = url;
		this.param = param;
		this.token = token;
	},
	doAjax : function(){
		var jqXHR = $.ajax({
			url : this.url,
			headers: {"X-CSRF-Token":this.token},
			dataType : "json",
			data : this.param,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8"
		});
		return jqXHR.promise();
	}
}

/*
 * 数値のカンマ区切り(正規表現)
 */
function separateComma(num){
	return String(num).replace( /(\d)(?=(\d\d\d)+(?!\d))/g, '$1,');
}
/* ======================================================================
    SaigaiTask/Map/view/MainPanel.js
   ====================================================================== */


/**
 * @class SaigaiTask.Map.view.MainPanel
 * 地図パネルや凡例パネルなどを配置するメインパネルです.
 * @param map
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.MainPanel = function(){
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.MainPanel.prototype = {

	map: null,

	/**
	 * 各パネルを配置するためのメインパネル
	 * @type {Ext.panel.Panel}
	 */
	panel: null,

	/**
	 * 凡例パネル
	 * @type {Ext.tree.Panel}
	 */
	legend: null,

	/**
	 * 地図パネルを複数配置するためのコンテナパネル
	 * @type {Ext.Panel}
	 */
	mapPanelContainer: null,

	/**
	 * 地図パネル
	 * @type {SaigaiTask.Map.view.MapPanel}
	 */
	mapPanel: null,

	/**
	 * ヘッダーツールバー
	 * @type {SaigaiTask.Map.view.HeaderToolbar}
	 */
	headerToolbar: null,

	/**
	 * OpenLayers.Map を地図パネルに描画します.
	 * @param {SaigaiTask.Map} map
	 */
	initialize: function(map) {
		var me = this;
		me.map = map;
		map.components.mainpanel = me;

		var panelItems = [];

		var items = [];
		// 地図パネル
		var mapPanel = me.mapPanel = new SaigaiTask.Map.view.MapPanel(map);
		// ヘッダーのツルーバーを追加
		var headerToolbar = me.headerToolbar = new SaigaiTask.Map.view.HeaderToolbar(map);
		mapPanel.panel.addDocked(headerToolbar.tbar);
		// フッターのツールバーを追加
		var geocodingToolbar = new SaigaiTask.Map.view.GeocodingToolbar(map);
		geocodingToolbar.tbar.dock = "bottom";
		// 2画面表示ボタン
		var submap = null;
		geocodingToolbar.tbar.add(["->", Ext.create("Ext.Button", {
			text: lang.__("2 window display "),
			tooltip: lang.__("It displays map window bisection."),
			icon: map.icon.getURL("submapIconURL"),
			align: "left",
			handler: function() {
				var mapSyncControl = map.controls["syncControl"];
				// 2画面表示
				if(mapSyncControl.group.length<2) {
					submap = me.createSubmap();
				}
				else {
					me.removeSubmap(submap);
				}
			}
		})]);
		//mapPanel.panel.addDocked(geocodingToolbar.tbar);
		items.push(mapPanel.panel);
		// 地図パネルコンテナ
		var mapPanelContainer = me.mapPanelContainer = Ext.create("Ext.Panel", {
			region: "center",
			layout: {
				type: "hbox",
				align: "stretch"
			},
			defaults: {
				flex: 1
			},
			items: items
		});
		// 2画面表示でジオコーディングツールバーが途切れないように、コンテナの方に追加する
		mapPanelContainer.addDocked(geocodingToolbar.tbar);
		panelItems.push(mapPanelContainer);

		// 凡例パネル
		var legend = me.legend = new SaigaiTask.Map.view.LegendPanel(map);
		legend.tree.region = "west";
		legend.tree.margin = "0 0 0 0";
		legend.tree.draggable = false;
		panelItems.push(legend.tree);
		legend.collapsed = true;

		// 下側パネル
/*
		var bottomPanel = null;
		var bottomPanelDomId = map.div+'-bottom-panel';
		var bottomPanelDom = document.getElementById(bottomPanelDomId);
		if(bottomPanelDom!=null) {
			console.log(bottomPanelDom);
			bottomPanel = Ext.create('Ext.panel.Panel', {
				region: 'south',
				margin: '5 0 0 0',
				resizable: true,
				contentEl: bottomPanelDomId
			});
			panelItems.push(bottomPanel);
		}
*/

		// 各パネルを配置するメインパネル
		var mapContainerHeight = $(mapPanel.panelDivElem.dom).parent().height();
		var main = me.panel = Ext.create("Ext.panel.Panel", {
			layout: 'border',
			height: mapContainerHeight,
			items: panelItems,
			renderTo: mapPanel.panelDivElem,
			listeners: {
				"beforeadd": function(container, component, index, eOpts) {
					if(me.legend.tree.id==component.id) {
						map.events.triggerEvent(map.EventType.beforeaddlegend, {
							legend: component
						});
					}
					return true;
				}
			}
		});

		// パネルサイズを最大まで広げる
		map.resize = function(){
			var size = me.getExpandSize(main.getEl().dom);
			main.setWidth(size.width);
			main.setHeight(size.height);
		};
		$(window).resize(map.resize);
		$(window).scroll(map.resize);
		map.resize();

		// イベント発火
		map.events.triggerEvent("initmainpanel", {
			mainpanel: me
		});
	},

	/**
	 * コンポーネントを配置と逆のリサイザーのみ有効化します.
	 * TODO: 凡例パネルを描画後に呼び出すようにする？
	 * @param {Ext.Component} component
	 */
	activateResizer: function(component) {
		var me = this;
		var map = me.map;
		var activateRegions = {
			"north": "south",
			"east": "west",
			"west": "east",
			"south": "north"
		};
		var activateRegion = activateRegions[component.region];
		if(typeof activateRegion!="undefined") {
			var div = $(component.getEl().dom);
			var handles = $(".x-resizable-handle", div);
			// 一旦すべてのリサイズハンドルを無効化
			handles.removeClass("x-resizable-handle").addClass("x-unresizable-handle");
			// 有効化
			handles.filter(".x-resizable-handle-"+activateRegion).addClass("x-resizable-handle").removeClass("x-unresizable-handle");
		}
	},

	/**
	 * 地図の大きさをウィンドウサイズに合わせて広げる.
	 * @param target DOMオブジェクト
	 * @return {width: int, height: int}
	 */
	getExpandSize: function(target){

		// スクロール位置
		var sLeft = jQuery(window).scrollLeft();
		var sTop = jQuery(window).scrollTop();

		// ウィンドウの大きさ
		var winWidth = $(window).width();
		var winHeight = $(window).height();

		// ウィンドウの右下の位置
		var winRight = sLeft + winWidth;
		var winBottom = sTop + winHeight;

		// 地図の位置
		var elem = jQuery(target);
		var elemLeft = elem.offset().left;
		var elemTop = elem.offset().top;

		// 地図の大きさ
		var anchorX = winRight;
		var anchorY = winBottom;
		var margin = 5;
		var width = anchorX - elemLeft - margin;
		var height = anchorY - elemTop - margin;

		return {width: width, height: height};
	},

	/**
	 * 凡例パネルを再描画する.
	 */
	redrawLegendPanel: function(){
		var me = this;
		var oldLegend = me.legend.tree;
		me.legend = new SaigaiTask.Map.view.LegendPanel(me.map);
		var legend = me.legend.tree;
		legend.region = oldLegend.region;
		legend.margin = oldLegend.margin;
		legend.draggable = oldLegend.draggable;
		var panel = me.panel;
		panel.remove(oldLegend);
		panel.add(legend);
		panel.doLayout();
		me.map.events.triggerEvent("afterredrawlegendpanel");
	},

	/**
	 * 2画面表示用のサブマップを作成してパネルに追加する.
	 */
	createSubmap: function() {
		var me = this;
		var map = me.map;
		var mapSyncControl = map.controls["syncControl"];
		var mapPanelContainer = me.mapPanelContainer;

		// OpenLayers.Mapのdivを生成する
		var newDiv = new Ext.Element(document.createElement('div'));
		newDiv.appendTo(Ext.getBody());

		// 地図を生成
		var submap = window.submap = new SaigaiTask.Map(newDiv.id, {contextPath: map.contextPath, api: map.api, icon: map.icon});
		submap.mapId = map.mapId;

		// eコミ情報をロード
		var ecommap = map.ecommaps[0].clone(submap);
		submap.registEcommapInfo(ecommap);

		// ズームバーをズームだけにする
		submap.controls["panZoom"].destroy();
		var zoom = new OpenLayers.Control.Zoom();
		submap.addControl(zoom, "zoom");

		// LayerSwitcherの追加
		submap.addControl(new OpenLayers.Control.LayerSwitcher(), "layerSwitcher");

		// TODO: ベースレイヤのデフォルト設定
		var submapPanel = new SaigaiTask.Map.view.MapPanel(submap);
		submap.components.submapPanel = submapPanel;

		// ヘッダーのツルーバーを追加
		var headerToolbar = new SaigaiTask.Map.view.HeaderToolbar(submap);
		headerToolbar.tbar.add(["->", Ext.create("Ext.Button", {
			tooltip: lang.__("Scale synchronization"),
			enableToggle: true,
			pressed: true,
			icon: map.icon.getURL("syncIconURL"),
			handler: function(button) {
				if(button.pressed) {
					mapSyncControl.activate();
					submapSyncControl.activate();
				}
				else {
					mapSyncControl.deactivate();
					submapSyncControl.deactivate();
				}
			}
		}), Ext.create("Ext.Button", {
			tooltip: lang.__("Close"),
			icon: map.icon.getURL("deleteIconURL"),
			handler: function() {
				me.removeSubmap(submap);
			}
		})]);
		submapPanel.panel.addDocked(headerToolbar.tbar);

		// 地図の同期設定
		var submapSyncControl = submap.controls["syncControl"];
		mapSyncControl.mergeGroup(submapSyncControl);
		mapSyncControl.activate();
		submapSyncControl.activate();

		// 登録情報レイヤのレイヤリフレッシュの同期
		var syncLayerRefresh = function(src, dst) {
			if(src==null) return;
			src.events.on({
				"refreshParams": function() {
					(function(layer) {
						if(layer!=null) {
							if(typeof layer._refreshParams=="function") {
								return layer._refreshParams({
									nocache: true
								});
							}
						}
					})(dst);
				}
			});
		};
		if(map.ecommaps[0].contentsLayerInfo!=null) {
			var    layer =    map.ecommaps[0].contentsLayerInfo.getLayer();
			var sublayer = submap.ecommaps[0].contentsLayerInfo.getLayer();
			syncLayerRefresh(   layer, sublayer);
			syncLayerRefresh(sublayer,    layer);
		}

		// 地図パネルを追加
		mapPanelContainer.add(submapPanel.panel);

		return submap;
	},

	/**
	 * サブマップとパネルを削除する.
	 * @param {SaigaiTask.Map} submap
	 */
	removeSubmap: function(submap) {
		var me = this;

		// パネルを削除
		var mapPanelContainer = me.mapPanelContainer;
		var submapPanel = submap.components.submapPanel;
		mapPanelContainer.remove(submapPanel.panel);

		// 同期グループから削除
		var mapSyncControl = me.map.controls["syncControl"];
		var submapSyncControl = submap.controls["syncControl"];
		mapSyncControl.removeGroup(submapSyncControl);
	}

};
/* ======================================================================
    SaigaiTask/Map/control/PopupManager.js
   ====================================================================== */

/**
 * ポップアップを管理するクラスです.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.PopupManager = new OpenLayers.Class({

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * ポップアップの配列.
	 * z-Index順で格納します.
	 * @type {Array<OpenLayers.Popup>}
	 */
	popups: null,

	initialize: function(stmap, options) {
		var me = this;
		me.stmap = stmap;
		stmap.popupManager = me;
		me.popups = [];
	},

	/**
	 * ポップアップを追加します.
	 * @param {OpenLayers.Popup} popup
	 */
	add: function(popup) {
		var me = this;
		me.popups.push(popup);
		// ポップアップクリック時に最前面へ移動する
		$(popup.groupDiv).children().click(function() {
			me.toFrontend(popup);
		});
	},

	/**
	 * ポップアップをピン留めします.
	 */
	pin: function(popup) {
		popup.pinned = true;
	},

	/**
	 * ポップアップのピン留めを外します.
	 */
	unpin: function(popup) {
		popup.pinned = false;
	},

	/**
	 * ポップアップを閉じます.
	 */
	close: function(popup) {
		var me = this;
		var olmap = me.stmap.map;
		var deleteIdx = $.inArray(popup, me.popups);
		if(-1<deleteIdx) {
			// z-Indexを1つ下げる
			for(var idx=deleteIdx+1; idx<me.popups.length; idx++) {
				if(deleteIdx!=null) {
					var target = me.popups[idx];
					me.setZIndex(target, me.getZIndex(target)-1);
				}
			}
			// 削除
			me.popups.splice(deleteIdx, 1);
		}
		olmap.removePopup(popup);
	},

	/**
	 * ポップアップをすべて閉じます.
	 * @param force ピン留めも閉じる
	 */
	closeAll: function(force) {
		var me = this;
		var olmap = me.stmap.map;
		var closePinned = (force==true);
		var newPopups = [];
		while(0<me.popups.length) {
			var popup = me.popups.shift();
			var close = true;
			// ピン留めしてなかったら閉じる
			if(force!=true) {
				close = (popup.pinned!=true);
			}
			if(close) {
				me.close(popup);
			}
			else {
				newPopups.push(popup);
			}
		}
		me.popups = newPopups;
	},

	setZIndex: function(popup, zIndex) {
		return $(popup.div).css("z-Index", zIndex);
	},

	/**
	 * @return {Number}
	 */
	getZIndex: function(popup) {
		return Number($(popup.div).css("z-Index"));
	},

	/**
	 * ポップアップを最前面に移動する.
	 */
	toFrontend: function(popup) {
		var me = this;
		var targetIdx = $.inArray(popup, me.popups);
		// 最前面じゃなかったら
		if(-1<targetIdx && targetIdx<me.popups.length-1) {
			// z-Indexを1つ下げる
			for(var idx=targetIdx+1; idx<me.popups.length; idx++) {
				var sequencePopup = me.popups[idx];
				me.setZIndex(sequencePopup, me.getZIndex(sequencePopup)-1);
			}
			// 最前面に移動する
			me.setZIndex(popup, me.getZIndex(sequencePopup)+1);
			me.popups.splice(targetIdx, 1);
			me.popups.push(popup);
		}
	},

	/**
	 * ポップアップを最背面に移動する.
	 */
	toBackend: function(popup) {
		var me = this;
		var targetIdx = $.inArray(popup, me.popups);
		// 最背面じゃなかったら
		if(targetIdx!=0) {
			// z-Indexを1つあげる
			for(var idx=targetIdx-1; 0<=idx; idx--) {
				var sequencePopup = me.popups[idx];
				me.setZIndex(sequencePopup, me.getZIndex(sequencePopup)+1);
			}
			// 最背面に移動する
			me.setZIndex(popup, me.getZIndex(sequencePopup)-1);
			me.popups.splice(targetIdx, 1);
			me.popups.unshift(popup);
		}
	}
});
/* ======================================================================
    SaigaiTask/Map/view/GeocodingToolbar.js
   ====================================================================== */

/**
 *
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.GeocodingToolbar = function() {
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.GeocodingToolbar.prototype = {
	tbar: null,
	map: null,
	addressField: null,
	resultAddressField: null,
	resultAddressFieldTip: null,

	/**
	 * コンストラクタ
	 */
	initialize: function(map) {
		var me = this;
		me.map = map;
		var olmap = map.map;
		var footerTbarItems = [];
		// 地図を移動のインタフェースを追加
		var addressField = me.addressField = Ext.create("Ext.form.field.Text", {
			//emptyText: "移動したい地名を入力", // フォーカス時に消えてくれないことがあるため使用しない
			enableKeyEvents: true,
			listeners: {
				afterrender: function(field, event) {
					// エンターキーで送信しないようにする
					var el = field.getEl();
					$(el.dom).keydown(function(event) {
						if(event.keyCode==13) {
							event.preventDefault();
							return false;
						}
					});
				},
				specialkey: function(field, e, eOpts) {
					if(e.getKey()==e.ENTER) {
						me.fireJumpAddressButton();
					}
				}
			}
		});
		var jumpAddressButton = Ext.create("Ext.button.Button", {
			text : lang.__('Move map'),
			tooltip: lang.__("Move to the location of entered address or of self defense force code"),
			margin : "0 5 0 5",
			listeners: {
				click: function() {
					me.fireJumpAddressButton();
				}
			}
		});
		footerTbarItems.push(addressField);
		footerTbarItems.push(jumpAddressButton);
		// 中心位置の住所を取得インタフェースを追加
		var resultAddressField = me.resultAddressField = Ext.create("Ext.form.Label", {
			text: lang.__("Due to display crumbled on IE, messages are displayed beforehand."),
			hidden: true // ダミーのtext が見えないように隠す
		});
		var rgeocodeButton = Ext.create("Ext.button.Button", {
			text : lang.__('Get address of center position'),
			tooltip: lang.__("The address of map center is displayed."),
			margin : "0 5 0 5",
			listeners: {
				click: function() {
					// 地図の中心位置
					var center = olmap.getCenter();
					center = center.transform(olmap.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));

					me.map.geocode(center)
					.done(function(results) {
						var result = results[0];
						me.updateAddress(result);
					})
					.fail(function(results, status) {
						alert(lang.__("Failed to get address.")+status);
					});
				}
			}
		});
		footerTbarItems.push("-");
		footerTbarItems.push(rgeocodeButton);
		footerTbarItems.push(resultAddressField);
		var footerTbar = Ext.create("Ext.toolbar.Toolbar", {
			dock: "bottom",
			items: footerTbarItems
		});
		me.tbar = footerTbar;
	},

	/**
	 * 逆ジオコード結果の住所を更新します.
	 * @param result Googleジオコーダの1件分の検索結果
	 */
	updateAddress: function(result) {
		var me = this;
		// 住所を取得
		var addr = null;
		if(result instanceof String) {
			addr = result;
		}
		if(result instanceof Object) {
			addr = me.map.getFormattedAddress(result);
		}

		// ラベル更新
		me.updateResultAddress(addr);
	},

	/**
	 * 住所検索結果フィールドのラベルを更新する
	 * @param {String} addr ラベルに設定する文字列
	 */
	updateResultAddress: function(addr) {
		var me = this;
		// ラベル更新
		me.resultAddressField.setText(addr);
		// 最初はダミーのtextが入っていて、非表示になっていることがあるので、表示させる
		if(me.resultAddressField.isHidden()) {
			me.resultAddressField.show();
		}
		if(me.resultAddressFieldTip==null) {
			me.resultAddressFieldTip = Ext.create('Ext.tip.ToolTip', {
				target: me.resultAddressField.getEl()
			});
		}
		me.resultAddressFieldTip.update(addr);
	},

	/**
	 * 「地図を移動」ボタンを実行します.
	 */
	fireJumpAddressButton: function() {
		var me = this;
		var map = me.map;
		var olmap = map.map;
		var addressField = me.addressField;
		var address = addressField.getValue();

		// MGRSコードによる移動
		var isMGRSFormat = /^\d\d?[a-zA-Z][a-zA-Z][a-zA-Z](\d*)$/;
		var result = isMGRSFormat.exec(address.replace(/\s+/g, "")); // スペースを除去して判定

		if(result==null) {
			isMGRSFormat = /^(\d*)$/;
			result = isMGRSFormat.exec(address.replace(/\s+/g, ""));

			if(result != null) {
				var left = map.ecommaps[0].initExtent.left;
				var bottom = map.ecommaps[0].initExtent.bottom;
				var right = map.ecommaps[0].initExtent.right;
				var top = map.ecommaps[0].initExtent.top;
				var initExtent = new OpenLayers.Bounds(left,bottom,right,top);
				//var center = initExtent.getCenterLonLat();
				// 現在表示している地図の中心
				var center = map.getCenter();
				var wkt = "POINT(" + center.lon + " " + center.lat + ")";

				var url = SaigaiTask.contextPath + "/page/map/getGrid/";
				jQuery.ajax(url, {
					type: "get",
					dataType: "json",
					async: false,
					data: {
						wkt: wkt
					},
					success: function(data) {
						result[0] = new Array();
						result[0].push(data.wkt.slice(0, data.wkt.indexOf(" "))+result[0]+result[1]);

						//UTMグリッドで使われるアルファベット
						var UTMalphabets = new Array();
						for(var i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
							// IとOは1と0と間違えやすいため欠番
							if(String.fromCodePoint(i) != "I" && String.fromCodePoint(i) != "O")
								UTMalphabets.push(String.fromCodePoint(i));
						}
						var alphabet1 = result[0][0].substr(3, 1);
						var alphabet2 = result[0][0].substr(4, 1);
						// ホーム範囲の中心点とその隣接するブロックの合計9ブロックが候補
						for(var i = 0; i < UTMalphabets.length;i++) {
							if(alphabet1 == UTMalphabets[i]) {
								result[0].push(result[0][0].replace(alphabet1, UTMalphabets[i-1]));
								result[0].push(result[0][0].replace(alphabet1, UTMalphabets[i+1]));
							}
							if(alphabet2 == UTMalphabets[i]) {
								result[0].push(result[0][0].replace(alphabet2, UTMalphabets[i-1]));
								result[0].push(result[0][0].replace(alphabet2, UTMalphabets[i+1]));
							}

						}
						for(var i = 0; i < UTMalphabets.length;i++) {
							if(alphabet1 == UTMalphabets[i]) {
								result[0].push(result[0][3].replace(alphabet1, UTMalphabets[i-1]));
								result[0].push(result[0][3].replace(alphabet1, UTMalphabets[i+1]));
								result[0].push(result[0][4].replace(alphabet1, UTMalphabets[i-1]));
								result[0].push(result[0][4].replace(alphabet1, UTMalphabets[i+1]));
							}
						}
						var nearest = 0;
						var no;
						// ホーム範囲の中心点から各候補地の距離を計測する。その中から最も近い点を採用する。
						for(i = 0; i < result[0].length; i++) {
							// MGRSコードから経緯度へ変換
							var mgrs = result[0][i];
							var json = map.api.mgrs2lonlat(mgrs);
							if(!!json.lon && !!json.lat) {
								function radians(deg) {
									return deg * Math.PI / 180;
								}
								var lat1 = json.lat;
								var lng1 = json.lon;
								var lat2 = center.lat;
								var lng2 = center.lon;
								var distance = 6378.14 * Math.acos(Math.cos(radians(lat1))*
										Math.cos(radians(lat2))*
										Math.cos(radians(lng2)-radians(lng1))+
										Math.sin(radians(lat1))*
										Math.sin(radians(lat2)));

								if(distance - nearest < 0 || i == 0) {
									nearest = distance;
									no = i;
								}
								else {
									continue;
								}
							}
						}
						result[0] = result[0][no];
					},
					error: function(data) {
						throw lang.__("An error occurred during the conversion MGRS code into coordinates.");
					}
				});
			}
		}
		if(result!=null) {
			do {
				// 最大桁数を超えていないか
				var numericalLocation = result[1];
				var maxDigits = 5;
				if(maxDigits*2 < numericalLocation.length) {
					alert(lang.__("The number of digits is too large.\n maximum number of digits of MGRS code is {0}.", maxDigits));
					break;
				}
				// 桁がそろっているか
				if(numericalLocation.length%2!=0) {
					alert(lang.__("MGRS code is invalid. Please align the number of digits."));
					break;
				}

				// MGRSコードから経緯度へ変換
				var mgrs = result[0];
				var json = map.api.mgrs2lonlat(mgrs);
				if(!!json.lon && !!json.lat) {
					// 単位がメートルなら
					var digits = json["mgrs_digits"];
					var zoom = map.map.getZoom();
					var mgrsControl = map.controls.mgrsControl;
					if(!!mgrsControl) zoom = mgrsControl.getZoomForPrecision(digits);
					// 移動
					//console.log("MGRS("+json.mgrs+") to Degrees("+json.lon+", "+json.lat+") zoom="+zoom);
					map.setCenter(new OpenLayers.LonLat(json.lon, json.lat), zoom);
					// ラベル更新
					me.updateResultAddress(lang.__("MGRS code: ")+json.mgrs);
				}
			} while(0);
			return;
		}

		//ランドマークデータを検索して、あればそれを使う
		var defResult = map.api.landmarkSearch(address);
		var landmarkFlag = false;//defferdを使っているので、done関数の外で結果の有無をチェック
		defResult.done(function(landmarkArr){
			if(landmarkArr.length>0){
				for(var cnt in landmarkArr){
					var landmark = landmarkArr[cnt].landmark;
					var lon = landmarkArr[cnt].lon;
					var lat = landmarkArr[cnt].lat;
					// 移動
					//var zoom = map.map.getZoom();
					map.setCenter(new OpenLayers.LonLat(lon, lat), 16);//zoomはとりあえず16で固定
					// ラベル更新
					me.updateResultAddress(lang.__("Landmark:")+landmark);
					landmarkFlag = true;
					//TODO とりあえず先頭の1件のみを返す。複数の検索結果をリスト表示したい場合は、ここの処理を変更する。
					break;
				}
			}
		});
		//alert("landmarkFlag:"+landmarkFlag);
		if(landmarkFlag){return;}

		// 住所からジオコーディングして移動する
		map.moveAddress(address)
		.done(function(result) {
			me.updateAddress(result);
		});
	}
};
/* ======================================================================
    SaigaiTask/Map/control/MgrsControl.js
   ====================================================================== */

/**
 * UTMグリッドレイヤを管理するクラスです.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.MgrsControl = new OpenLayers.Class(OpenLayers.Control, {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * MGRSグリッドのレイヤ情報
	 * @type {SaigaiTask.Map.Layer.LayerInfo}
	 */
	layerInfo: null,

	/**
	 * MGRSグリッドのレイヤ
	 * @type {OpenLayers.Layer}
	 */
	layer: null,

	/**
	 * MGRSコードの桁数の自動決定モード
	 * @type {Boolean}
	 */
	autoPrecision: true,

	/**
	 * 桁数からズームレベルの相互変換のときに、
	 * 納まるグリッド数のパラメータ
	 * @type {Number}
	 */
	// 地図表示領域に１マスが収まらなくなったら次のケタ
	//AUTO_PRECISION_GRID_NUM: 1.0,
	// 地図表示領域に１マスの６割が収まらなくなったら次のケタ
	AUTO_PRECISION_GRID_NUM: 0.6,

	initialize: function(stmap) {
		var me = this;
		me.stmap = stmap;

		// レイヤ情報
		var layerInfo = me.layerInfo = new SaigaiTask.Map.Layer.LayerInfo({
			layerId: "mgrs",
			type: SaigaiTask.Map.Layer.Type.EXTERNAL_MAP_WMS, // 印刷用
			name: lang.__("UTM grid"),
			wmsURL: window.location.protocol+"//"+window.location.host+SaigaiTask.contextPath+"/page/map/mgrs/?",
			wmsFormat: "image/png",
			visibility: false, // 初期表示
			params: {
				precision: 0
			}
		});
		layerInfo.children = [];
		for(var p=0; p<=5; p++) {
			layerInfo.children.push(new SaigaiTask.Map.Layer.LayerInfo({
				layerId: layerInfo.layerId+"_"+p,
				featuretypeId: "mgrs"+p,
				mgrsPrecision: p,
				visibility: false,
				params: {
					LAYERS: "mgrs"+p
				}
			}));
		}

		// UTMグリッドレイヤの初期化
		var layer = me.layer = new SaigaiTask.Map.Layer.WMSLayer(layerInfo);

		// 一番上に表示させるため、ロード後に追加
		stmap.events.on({
			"loadendecommap": function(ecommap) {
				// 地図未追加なら追加する
				if(!layer.map) {
					stmap.addLayer(layer);
					layer.setVisibility(layerInfo.visibility);
				}

			},
			// 凡例初期化
			"legendinitialize": function(args) {
				// 凡例パネルのツールバーに追加
				var legend = args.legend;
				// ボタン
				var btn = Ext.create("Ext.Button", {
					text: lang.__('UTM grid'),
					tooltip: lang.__("UTM grid is shown or hided."),
					icon: stmap.icon.getURL("mgrsIconURL"),
					enableToggle: true,
					handler: function() {
						layerInfo.visibility = !layerInfo.visibility;
						// 表示の場合
						if(layerInfo.visibility) {
							// MGRS桁数の自動決定
							if(me.autoPrecision) {
								var autoPrecision = me.getPrecisionForZoom(stmap.map.getZoom());
								me.setPrecision(autoPrecision);
							}
						}
						layer.refreshParams();
					}
				});

				legend.addTbarItems([btn]);
			}
		});

		stmap.map.events.on({
			"zoomend": function() {
				// MGRS桁数の自動決定
				if(me.autoPrecision) {
					var autoPrecision = me.getPrecisionForZoom(stmap.map.getZoom());
					var current = layerInfo.params.precision;
					if(current!=autoPrecision) {
						me.setPrecision(autoPrecision);
						layer.refreshParams();
					}
				}
			}
		});
	},

	setPrecision: function(precision) {
		var me = this;
		var layerInfo = me.layerInfo;
		layerInfo.params.precision = precision;
		// LAYERS パラメータも指定する
		for(var idx in layerInfo.children) {
			var child = layerInfo.children[idx];
			child.visibility = child.mgrsPrecision<=precision;
		}
	},

	/**
	 * MGRSコードの桁数からズームレベルを取得する
	 * @param {Number} precision MGRSコード桁数
	 */
	getZoomForPrecision: function(precision) {
		var me = this;
		var stmap = me.stmap;
		var olmap = stmap.map;
		var zoom = olmap.getZoom();
		if($.isNumeric(precision) && olmap.getUnits()=="m") {
			// 位置は格子の交差点なので、2倍の大きさが表示範囲に入るように計算
			for(var zoom=olmap.getMinZoom(); zoom<olmap.getNumZoomLevels(); zoom++) {
				if(!me.isViewportAvailable(zoom, precision)) {
					// 1つ前のズームレベルにする
					if(0<zoom) { zoom--;}
					break;
				}
			}
			if(olmap.getNumZoomLevels() <= zoom) zoom=olmap.getNumZoomLevels()-1;
		}
		return zoom;
	},

	/**
	 * ズームレベルに合うMGRSコードの桁数を取得する
	 * @param {Number} zoom ズームレベル
	 */
	getPrecisionForZoom: function(zoom) {
		var precision = 0;
		var me = this;
		var stmap = me.stmap;
		var olmap = stmap.map;

		var precisions = [5, 4, 3, 2, 1, 0];
		for(var idx in precisions) {
			var p = precisions[idx];
			if(!me.isViewportAvailable(zoom, p)) {
				if(0<idx) { idx--; }
				precision = precisions[idx];
				break;
			}
		}


		return precision;
	},

	/**
	 * ズームレベルに対して、適切なMGRSグリッドかどうかを判定します.
	 * (逆も可)
	 * @param {Number} zoom ズームレベル
	 * @param {Number} precision MGRSコード桁数
	 */
	isViewportAvailable: function(zoom, precision) {
		var me = this;
		var stmap = me.stmap;
		var olmap = stmap.map;

		// 桁数に応じて、MGRSコードの格子の大きさを取得
		var maxMeter = null;
		switch(precision) {
		case 5: maxMeter=1; break;      //    1m
		case 4: maxMeter=10; break;     //   10m
		case 3: maxMeter=100; break;    //  100m
		case 2: maxMeter=1000; break;   //   1km
		case 1: maxMeter=10000; break;  //  10km
		case 0: maxMeter=100000; break; // 100km
		}
		if(maxMeter==null) return false;

		// 表示領域の小さいほうのピクセル数を取得(マージンを両端で 30px とっておく)
		var pixel = Math.min($(olmap.getViewport()).width(), $(olmap.getViewport()).height()) - 30*2;
		// 表示領域の最大メートル
		var viewportMeter = olmap.getResolutionForZoom(zoom) * pixel;
		// 最大メートルを超えたらやめる
		return maxMeter*me.AUTO_PRECISION_GRID_NUM <= viewportMeter;
	}
});
/* ======================================================================
    OpenLayers/Format/KMLStyle.js
   ====================================================================== */

/* Copyright (c) 2009 National Research Institute for Earth Science and
 * Disaster Prevention (NIED).
 * This code is licensed under the GPL version 3 license, available at the root
 * application directory.
 */

/**
 * - 180420 eコミマップ trunk@3463 を反映
 */
/** <span class="ja">KMLのスタイルに対応したKMLFormat</span><span class="en">KML format that supports KML style</span> */
OpenLayers.Format.KMLStyle = OpenLayers.Class(OpenLayers.Format.KML,
{
	/** <span class="ja">基準とするフォントサイズ</span><span class="en">Standard fontsize</span> */
	FONTSIZE : 14,
	
	/** 画像取得前にstyleに設定する仮のサイズ */
	ICONSIZE : 48,
	
	/** スタイル無しの時の基本スタイル */
	defaultStyle : {
		pointRadius: 5,
		strokeColor: "#ff0000",
		strokeWidth : 2,
		fillColor: "#ff0000",
		fillOpacity : 0.5
	},
	
	/** <span class="ja">親のOpenLayers.Format.KMLを初期化</span><span class="en">Initialize parent's OpenLayers.Format.KML</span> */
	initialize : function(options) {
		OpenLayers.Format.KML.prototype.initialize.apply(this, [options]);
	},
	
	/**<span class="ja">FeatureをKMLに変換</span><span class="en">Convert Feature to KML</span> */
	write: function(features)
	{
		this.internalProjection.readyToUse = true;
		this.externalProjection.readyToUse = true;
		
		if (!(features instanceof Array)) {
			features = [features];
		}
		var kml = this.createElementNS(this.kmlns, "kml");
		var folder = this.createFolderXML();
		for(var i=0, len=features.length; i<len; ++i) {
			folder.appendChild(this.createPlacemarkXML(features[i]));
		}
		kml.appendChild(folder);
		return OpenLayers.Format.XML.prototype.write.apply(this, [kml]);
	},
	
	/** <span class="ja">KML読み込み.</span><span class="en">Read KML</span>
	 * <span class="ja">Firefoxで4096バイト以上の文字列を読み込むときに normalize() をするように修正</span><span class="en">When a string with over 4096 bytes is read on Firefox, fix to use normalize() </span> */
	parseData: function(data, options) {
		if(typeof data == "string") {
			xmldoc = OpenLayers.Format.XML.prototype.read.apply(this, [data]);
		}
		//for Firefox 4096 bytes limit
		if (xmldoc.normalize) xmldoc.normalize();
		
		//IE11 retry
		if (!xmldoc.firstChild.tagName != "kml") {
			xmldoc = new DOMParser().parseFromString(data, 'text/xml');
		}
		
		var folderNode = xmldoc.firstChild.firstChild;
		while (folderNode && folderNode.nodeType == Node.TEXT_NODE) { folderNode = folderNode.nextSibling; }
		this.foldersDesc = OpenLayers.Util.getXmlNodeValue(this.getElementsByTagNameNS(folderNode, "*", "description")[0]);
		
		// Loop throught the following node types in this order and
		// process the nodes found 
		var types = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"];
		for(var i=0, len=types.length; i<len; ++i) {
			var type = types[i];
			var nodes = this.getElementsByTagNameNS(xmldoc, "*", type);
			// skip to next type if no nodes are found
			if(nodes.length == 0) { 
				continue;
			}
			switch (type.toLowerCase()) {
				// Fetch external links 
				case "link":
				case "networklink":
					this.parseLinks(nodes, options);
					break;
				// parse style information
				case "style":
					if (this.extractStyles) {
						this.parseStyles(nodes, options);
					}
					break;
				case "stylemap":
					if (this.extractStyles) {
						this.parseStyleMaps(nodes, options);
					}
					break;
				// parse features
				case "placemark":
					this.parseFeatures(nodes, options);
					break;
			}
		}
		
		//画像サイズを取得して幅高さを再計算する
		this.adjustImageSize(this.features);
		
		return this.features;
	},
	
	adjustImageSize : function(features)
	{
		var imageFeatuers = {};
		
		for (var i=0; i<features.length; i++) {
			var style = features[i].style;
			var url = style.externalGraphic;
			if (url) {
				//テキストは除外
				if (url)
				if (!imageFeatuers[url]) imageFeatuers[url] = [];
				imageFeatuers[url].push(features[i]);
			}
		}
		for (var url in imageFeatuers) {
			this._adjustImageSize(url, imageFeatuers[url]);
		}
	},
	_adjustImageSize : function(url, features)
	{
		var img = new Image();
		img.onload = function(){
			//メモ描画の古いデータはテキストが1x1の画像なのでサイズは変更しない
			if (img.width <= 1 || img.height <= 1) return;
			for (var i=0; i<features.length; i++) {
				var style = features[i].style;
				//スケール情報がgraphicScaleに保存されているので拡大
				if (style.graphicScale > 0) {
					var w = img.width*style.graphicScale;
					var h = img.height*style.graphicScale;
					//Offsetは仮サイズで指定されているので調整
					if (style.graphicXOffset) style.graphicXOffset = Math.round(parseFloat(style.graphicXOffset) * w/style.graphicWidth);
					if (style.graphicYOffset) style.graphicYOffset = Math.round(parseFloat(style.graphicYOffset) * h/style.graphicHeight);
					style.graphicWidth = w;
					style.graphicHeight = h;
				} else {
					if (img.width > img.height) {
						var h = style.graphicWidth * img.height/img.width;
						if (style.graphicYOffset) style.graphicYOffset = Math.round(parseFloat(style.graphicYOffset) * h/style.graphicHeight);
						style.graphicHeight = h;
					} else if (img.width < img.height) {
						var w = style.graphicHeight * img.width/img.height;
						if (style.graphicXOffset) style.graphicXOffset = Math.round(parseFloat(style.graphicXOffset) * w/style.graphicWidth);
						style.graphicWidth = w;
					}
				}
			}
			if (features[0].layer) features[0].layer.redraw();
		};
		img.src = url;
		img.onload();
	},
	
	getStyle: function(styleUrl, options) {
		var styleBaseUrl = OpenLayers.Util.removeTail(styleUrl);

		var newOptions = OpenLayers.Util.extend({}, options);
		newOptions.depth++;
		newOptions.styleBaseUrl = styleBaseUrl;

		// Fetch remote Style URLs (if not fetched before) 
		if (!this.styles[styleUrl] 
				&& !OpenLayers.String.startsWith(styleUrl, "#") 
				&& newOptions.depth <= this.maxDepth
				&& !this.fetched[styleBaseUrl] ) {

			var data = this.fetchLink(styleBaseUrl);
			if (data) {
				this.parseData(data, newOptions);
			}

		}
		
		//スタイルが無い場合はデフォルトスタイルを返す
		if (!this.styles[styleUrl]) return this.defaultStyle;
		
		// return requested style
		var style = OpenLayers.Util.extend({}, this.styles[styleUrl]);
		
		return style;
	},
	
	parseStyle : function(node) {
		var style = {};
		
		var types = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", "LabelStyle"];
		var type, nodeList, geometry, parser, styleTypeNode;
		for(var i=0, len=types.length; i<len; ++i) {
			type = types[i];
			styleTypeNode = this.getElementsByTagNameNS(node, "*", type)[0];
			if(!styleTypeNode) { 
				continue;
			}
			// only deal with first geometry of this type
			switch (type.toLowerCase()) {
				case "linestyle":
					var color = this.parseProperty(styleTypeNode, "*", "color");
					if (color) {
						var matches = (color.toString()).match(this.regExes.kmlColor);
						if (matches) {
							// transparency
							var alpha = matches[1];
							style["strokeOpacity"] = parseInt(alpha, 16) / 255;
							style["strokeColor"] = "#"+matches[4]+matches[3]+matches[2];
						}
					}
					
					var width = this.parseProperty(styleTypeNode, "*", "width");
					if (width < 1) width = 0;
					style["strokeWidth"] = width;
				case "polystyle":
					var color = this.parseProperty(styleTypeNode, "*", "color");
					if (color) {
						var matches = (color.toString()).match( this.regExes.kmlColor);
						if (matches) {
							// transparency
							var alpha = matches[1];
							style["fillOpacity"] = parseInt(alpha, 16) / 255;
							style["fillColor"] = "#"+matches[4]+matches[3]+matches[2];
						}
					}
					 // Check is fill is disabled
					var fill = this.parseProperty(styleTypeNode, "*", "fill");
					if (fill == "0") {
						style["fillColor"] = "none";
					}
					
					break;
					
				case "iconstyle":
					var iconNode = this.getElementsByTagNameNS(styleTypeNode, "*", "Icon")[0];
					if (iconNode) {
						var href = this.parseProperty(iconNode, "*", "href");
						if (href) {
							href = href.replace(/%3F/i, "?");
							
							// set scale
							var scale = parseFloat(this.parseProperty(styleTypeNode, "*", "scale") || 1);
							if (scale <= 0) scale = 1;
							
							var width = this.ICONSIZE * scale;
							var height = this.ICONSIZE * scale;
							
							if (OpenLayers.String.startsWith(href, "http://maps.google.com/mapfiles/kml")) {
								//google icons
								width = 64;
								height = 64;
								scale = scale / 2;
							} else {
								//画像読み込み後に設定されるまでの仮の画像サイズ Offset設定用
								var width = this.ICONSIZE * scale;
								var height = this.ICONSIZE * scale;
								//後から画像サイズを取得するのでここでスケールを設定
								style.graphicScale = scale;
							}
							
							// support for internal icons 
							//	  (/root://icons/palette-x.png)
							// x and y tell the position on the palette:
							// - in pixels
							// - starting from the left bottom
							// We translate that to a position in the list 
							// and request the appropriate icon from the 
							// google maps website
							var matches = href.match(this.regExes.kmlIconPalette);
							if (matches)  {
								var palette = matches[1];
								var file_extension = matches[2];
								var x = this.parseProperty(iconNode, "*", "x");
								var y = this.parseProperty(iconNode, "*", "y");
								var posX = x ? x/32 : 0;
								var posY = y ? (7 - y/32) : 7;
								var pos = posY * 8 + posX;
								href = "http://maps.google.com/mapfiles/kml/pal" 
									 + palette + "/icon" + pos + file_extension;
							}
							style["graphicOpacity"] = 1; // fully opaque
							style["externalGraphic"] = href;
							
							// hotSpots define the offset for an Icon
							var hotSpotNode = this.getElementsByTagNameNS(styleTypeNode, "*", "hotSpot")[0];
							if (hotSpotNode) {
								var x = parseFloat(hotSpotNode.getAttribute("x"));
								var y = parseFloat(hotSpotNode.getAttribute("y"));
								
								var xUnits = hotSpotNode.getAttribute("xunits");
								if (xUnits == "pixels") {
									style["graphicXOffset"] = -x * scale;
								}
								else if (xUnits == "insetPixels") {
									style["graphicXOffset"] = -width + (x * scale);
								}
								else if (xUnits == "fraction") {
									style["graphicXOffset"] = -width * x;
								}
								
								var yUnits = hotSpotNode.getAttribute("yunits");
								if (yUnits == "pixels") {
									style["graphicYOffset"] = -height + (y * scale);
								}
								else if (yUnits == "insetPixels") {
									style["graphicYOffset"] = -(y * scale);
								}
								else if (yUnits == "fraction") {
									style["graphicYOffset"] =  -height * (1 - y);
								}
							}
							
							style["graphicWidth"] = width;
							style["graphicHeight"] = height;
						}
					}
					break;
					
				case "balloonstyle":
					var balloonStyle = OpenLayers.Util.getXmlNodeValue(styleTypeNode);
					if (balloonStyle) {
						style["balloonStyle"] = balloonStyle.replace(this.regExes.straightBracket, "${$1}");
					}
					break;
					
				case "labelstyle":
					var color = this.parseProperty(styleTypeNode, "*", "color");
					if (color) {
						var matches = (color.toString()).match(this.regExes.kmlColor);
						if (matches) {
							var opacity = parseInt(matches[1], 16) / 255;
							style.fontOpacity = opacity; //Support OpenLayers2.9 later
							//<span class="ja">透明なら色を設定しない → ラベルを表示しない</span><span class="en">If it is transparent, color is not set  --> do not display label</span>
							if (opacity > 0) style.fontColor = "#"+matches[4]+matches[3]+matches[2];
						}
					}
					var scale = parseFloat(this.parseProperty(styleTypeNode, "*", "scale") || 1);
					if (scale <= 0) scale = 1;
					style.fontSize = this.FONTSIZE*scale;

					// 官民修正：テキストメモ表示の対応
					OpenLayers.Format.KMLStyleUtil.parseTextMemo(this, node, style);

					break;
				default:
			}
		}
		
		// Some polygons have no line color, so we use the fillColor for that
		if (!style["strokeColor"] && style["fillColor"]) {
			style["strokeColor"] = style["fillColor"];
		}
		
		var id = node.getAttribute("id");
		if (id && style) {
			style.id = id;
		}
		
		return style;
	},
	
	/** <span class="ja">featureのスタイル情報も含めたKMLのPlacemarkのXMLノード生成</span><span class="en">Create XML node of KML's Placemark which includes feature's style information</span> */
	createPlacemarkXML: function(feature)
	{
		// Placemark name
		var placemarkName = this.createElementNS(this.kmlns, "name");
		var name = feature.attributes.name || "";
		placemarkName.appendChild(this.createTextNode(name));
		
		// Placemark description
		var placemarkDesc = this.createElementNS(this.kmlns, "description");
		var desc = feature.attributes.description || "";// || this.placemarksDesc;
		placemarkDesc.appendChild(this.createTextNode(desc));
		
		// Placemark
		var placemarkNode = this.createElementNS(this.kmlns, "Placemark");
		if(feature.fid != null) {
			placemarkNode.setAttribute("id", feature.fid);
		}
		placemarkNode.appendChild(placemarkName);
		placemarkNode.appendChild(placemarkDesc);
		
		if (feature.style) {
			var styleNode = this.createStyleNode(feature.style);
			placemarkNode.appendChild(styleNode);
		}
		// Geometry node (Point, LineString, etc. nodes)
		var geometryNode = this.buildGeometryNode(feature.geometry);
		placemarkNode.appendChild(geometryNode);
		
		// TBD - deal with remaining (non name/description) attributes.
		return placemarkNode;
	},
	
	/** <span class="ja">RGB表記＋不透明度をKMLの色表記(AABBGGRR)に変換</span><span class="en">Convert RGB format and transparency to KML's color format (AABBGGRR)</span> */
	createKmlColorNode: function(color, opacity)
	{
		if (opacity === undefined || opacity === null) {
			var alpha = "ff";
		} else {
			var alpha = Math.round(parseFloat(opacity) * 255).toString(16);
			if (alpha.length==1) alpha = "0"+alpha;
		}
		
		// TBD: handle '#ccc', 'red'
		// only match '#rrggbb'
		var value;
		if (!color || color.length < 4) {
			value = alpha + '000000';
		} else if (color.length < 7) {
			//#FFF
			var r = color.slice(1, 2);
			var g = color.slice(2, 3);
			var b = color.slice(3, 4);
			value = alpha + b + b + g + g + r + r;
		} else {
			//#FFFFFF
			var r = color.slice(1, 3);
			var g = color.slice(3, 5);
			var b = color.slice(5, 7);
			value = alpha + b + g + r;
		}
		
		var colorNode = this.createElementNS(this.kmlns, "color");
		colorNode.appendChild(this.createTextNode(value));
		return colorNode;
	},
	
	createStyleNode: function(style)
	{
		// TBD: search if the already exists.
		if (true) {
			var styleNode = this.createElementNS(this.kmlns, "Style");
			var id = OpenLayers.Util.createUniqueID("style_");
			styleNode.setAttribute("id", id);
			
			// LineStyle
			if (style.strokeColor || style.strokeOpacity) {
				var lineNode = this.createElementNS(this.kmlns, "LineStyle");
				var colorNode = this.createKmlColorNode(style.strokeColor, style.strokeOpacity);
				lineNode.appendChild(colorNode);
				
				if (style.strokeWidth) {
					var width = this.createElementNS(this.kmlns, "width");
					width.appendChild(this.createTextNode(style.strokeWidth));
					lineNode.appendChild(width);
				}
				styleNode.appendChild(lineNode);
			}
			
			// PolyStyle (IE: style.fillColor = 'none')
			if (style.fillColor || style.fillOpacity) {
				var polyNode = this.createElementNS(this.kmlns, "PolyStyle");
				var colorNode = this.createKmlColorNode(style.fillColor, style.fillOpacity);
				polyNode.appendChild(colorNode);
				styleNode.appendChild(polyNode);
			}
			if (polyNode && style.strokeWidth == "0") {
				var outline = this.createElementNS(this.kmlns, "outline");
				outline.appendChild(this.createTextNode("0"));
				polyNode.appendChild(outline);
				styleNode.appendChild(polyNode);
			}
			
			// IconStyle
			if (style.externalGraphic && style.graphic !== false) {
				var iconstyleNode = this.createElementNS(this.kmlns, "IconStyle");
				var iconNode = this.createElementNS(this.kmlns, "Icon");
				
				var href = this.createElementNS(this.kmlns, "href");
				var urlObj = OpenLayers.Util.createUrlObject(
					style.externalGraphic.replace("?", "%3F"),
					{ignorePort80: true}
				);
				url = urlObj.protocol+'//'+urlObj.host+urlObj.port+urlObj.pathname;
				href.appendChild(this.createTextNode(url));
				iconNode.appendChild(href);
				//scaleは実画像のサイズとの比率 メモ描画では feature.style.graphicScale に格納している
				var scale = this.createElementNS(this.kmlns, "scale");
				scale.appendChild(this.createTextNode( style.graphicScale>0 ? style.graphicScale : 1 ));
				iconstyleNode.appendChild(scale);
				
				iconstyleNode.appendChild(iconNode);
				
				if (style.graphicXOffset || style.graphicYOffset) {
					var hotSpotNode = this.createElementNS(this.kmlns, "hotSpot");
					if (style.graphicXOffset) {
						hotSpotNode.setAttribute("x", -style.graphicXOffset/style.graphicWidth);
						hotSpotNode.setAttribute("xunits", "fraction");
					}
					if (style.graphicYOffset) {
						hotSpotNode.setAttribute("y", 1+style.graphicYOffset/(style.graphicHeight));
						hotSpotNode.setAttribute("yunits", "fraction");
					}
					iconstyleNode.appendChild(hotSpotNode);
				}
				
				/*
				//<span class="ja">ポイントのスケールはメモでは不要</span><span class="en">Memo is not required for point's scale</span>
				//<span class="ja">汎用的にするなら実画サイズの幅高さから計算する必要有り</span><span class="en">For general purpose, the calculation of width and height for the real size is required</span>
				var scaleNode = this.createElementNS(this.kmlns, "scale");
				
				// in KML 2.2, w and h <Icon> attributes are deprecated
				// this means that we can't modify the width/height ratio of the image
				
				var scale = style.graphicWidth || style.graphicHeight || style.pointRadius * 2;
				scaleNode.appendChild(this.createTextNode(scale/32));
				iconstyleNode.appendChild(scaleNode);
				*/
				// graphicOpacity, since opacity seems to be only supported using a color node in KML,
				// which will eventually change the color of the image, we choose not to support it
				
				// rotation (heading), not supported yet
				
				// graphicName, cannot be supported since nothing similar exists in KML
				
				styleNode.appendChild(iconstyleNode);
			}
			
			// <span class="ja">LabelStyle 色と大きさのみ</span><span class="en">LabelStyle   Only color and size</span>
			if (style.fontColor != undefined) {
				var colorNode = this.createKmlColorNode(style.fontColor, style.fontOpacity);
				var labelStyle = this.createElementNS(this.kmlns, "LabelStyle");
				labelStyle.appendChild(colorNode);
				styleNode.appendChild(labelStyle);
				try {
				if (style.fontSize) {
					var fontSize = parseFloat(style.fontSize);
					var fontScaleNode = this.createElementNS(this.kmlns, "scale");
					fontScaleNode.appendChild(this.createTextNode(fontSize/this.FONTSIZE));
					labelStyle.appendChild(fontScaleNode);
				}
				} catch (e) {}
			}
			return styleNode;
		}
	},	
	
	CLASS_NAME: "OpenLayers.Format.KMLStyle"
});
/* ======================================================================
    SaigaiTask/Map/util/CommonUtil.js
   ====================================================================== */

/**
 * @class SaigaiTask.Map.util.CommonUtil
 * @static
 * @requires SaigaiTask/Map/util.js
 */
SaigaiTask.Map.util.CommonUtil = {
	/**
	 * オブジェクトのプロパティ数を取得します.
	 * @param {Object} obj
	 * @return {Number} プロパティ数
	 */
	length: function(obj) {
		var count = 0;
		if(obj!=null) {
			for(var key in obj) {
				if(key!=null) {
					count++;
				}
			}
		}
		return count;
	},

	/**
	 * ロードされていないJavascriptライブラリを自動で読み込みます.
	 * @param {String} contextPath コンテキストパス
	 */
	loadLibrary: function(contextPath) {
		var server = location.href.substring(0, location.href.indexOf(contextPath)) + contextPath;

		var libs = [];
		if(typeof FalUtil=='undefined') {
			libs.push(server+'/assets2/js/falutil.js');
		}
//		if(typeof jsts=='undefined') {
//			if(typeof javascript=='undefined') {
//				libs.push('/jsts/lib/javascript.util.js');
//			}
//			libs.push('/jsts/lib/jsts.js');
//		}
		if(typeof Ext=='undefined') {
			libs.push(server+"/extjs/ext-all.js");
		}

		for(var idx in libs) {
			var lib = libs[idx];
			var jsElement = document.createElement("script");
			jsElement.type = "text/javascript";
			jsElement.src = lib;
			document.getElementsByTagName("head")[0].appendChild(jsElement);
			console.log('load javascript: '+lib);
		}
	},

	/**
	 * XMLHttpRequest を取得する
	 */
	getXHR: function() {
		//Win ie用
		if(window.ActiveXObject){
			try {
				//MSXML2以降用
				return new ActiveXObject("Msxml2.XMLHTTP");
			} catch (e) {
				try {
					//旧MSXML用
					return new ActiveXObject("Microsoft.XMLHTTP");
				} catch (e2) {
					return null;
				};
			};
		} else if(window.XMLHttpRequest){
			//Win ie以外のXMLHttpRequestオブジェクト実装ブラウザ用
			return new XMLHttpRequest();
		} else {
			return null;
		}
	},

	/** <span class="ja">xml内で利用できない文字をエスケープ</span><span class="en">Escape the characters which cannot be used in XML</span> */
	escapeXml : function(str)
	{
		return str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
	},

	//=====================================================================
	// GET リクエストパラメータ
	//=====================================================================
	getQueryString: function(){ return window.location.search.substring(1); },
	getParameterMap: function(query){
		var map = new Array();
		var params = query.split("&");
		for(var idx in params){
			var param = params[idx];
			var pos = param.indexOf("=");
			if(0<pos){
				var key = param.substring(0,pos);
				var val = param.substring(pos+1);
				map[key]=val;
			}
		}
		return map;
	},
	getParameter: function(name){
		var query = SaigaiTask.Map.util.CommonUtil.getQueryString();
		var paramMap = SaigaiTask.Map.util.CommonUtil.getParameterMap(query);
		return paramMap[name];
	}
};
/* ======================================================================
    OpenLayers/Control/CenterCursor.js
   ====================================================================== */

/* Copyright (c) 2009 National Research Institute for Earth Science and
 * Disaster Prevention (NIED).
 * This code is licensed under the GPL version 3 license, available at the root
 * application directory.
 */
/**
 * @class
 *
 * requires OpenLayers/Control.js
 */
OpenLayers.Control.CenterCursor = OpenLayers.Class(OpenLayers.Control,
{

	/** @type DOMElement */
	element: null,
	elementMap: null,

	size : 23,
	opacity : 0.8,

	/**
	 * @constructor
	 */
	initialize: function()
	{
		OpenLayers.Control.prototype.initialize.apply(this, arguments);
	},

	/**
	 * @type DOMElement
	 */
	draw: function()
	{
		OpenLayers.Control.prototype.draw.apply(this, arguments);

		var cursor = this.createCursor();
		this.div.appendChild(cursor);
		this.element = cursor;
		this.element.style.display = 'none';

		this.moveCenter();
		this.map.events.register("movestart", this, this.moveStart);
		this.map.events.register("resize", this, this.moveCenter);
		this.map.events.register("moveend", this, this.moveEnd);
		return this.div;
	},

	createCursor : function()
	{
		var color = 'red';
		var bgColor = 'white';
		var cursor = document.createElement("div");
		cursor.className = "CenterCursor";
		var s = cursor.style;
		s.width = s.height = "2px";
		s.position = "absolute";
		s.opacity = this.opacity;

		var half = Math.floor(this.size/2.0);
		cursor.appendChild(this.createLine(0,     half-1, half-3,3, bgColor));
		cursor.appendChild(this.createLine(half+4,half-1, half-3,3, bgColor));
		cursor.appendChild(this.createLine(half-1,0,      3,half-3, bgColor));
		cursor.appendChild(this.createLine(half-1,half+4, 3,half-3, bgColor));
		cursor.appendChild(this.createLine(1,     half,      half-4,1, color));
		cursor.appendChild(this.createLine(half+4,half, half-4,1, color));
		cursor.appendChild(this.createLine(half,1,      1,half-4, color));
		cursor.appendChild(this.createLine(half,half+4, 1,half-4, color));
		return cursor;
	},

	createLine : function(left, top, w, h, color)
	{
		var line = document.createElement("div");
		var s = line.style;
		s.position = "absolute";
		s.overflow = "hidden";
		s.top = top+"px";
		s.left = left+"px";
		s.width = w+"px";
		s.height = h+"px";
		s.backgroundColor = color;
		return line;
	},

	moveStart: function()
	{
		this.element.style.display = '';
		this.elementMap.style.display = 'none';
	},

	moveEnd: function()
	{
		this.element.style.display = 'none';
		this.elementMap.style.display = '';
		this.moveCenter();
	},

	moveCenter: function()
	{
		var s = this.map.getSize();
		this.element.style.left = ((s.w-this.size) / 2) + "px";
		this.element.style.top = ((s.h-this.size) / 2) + "px";
		//<span class="ja">地図上に描画</span><span class="en">Draw on the top of map</span>
		var div = this.map.layerContainerDiv;
		if (!this.elementMap) {
			this.elementMap = this.createCursor();
			this.elementMap.style.zIndex = 750;
			div.appendChild(this.elementMap);
		} else {
			this.elementMap.style.left = ((s.w-this.size) / 2 - div.offsetLeft) + "px";
			this.elementMap.style.top = ((s.h-this.size) / 2 - div.offsetTop) + "px";
		}
	},

	/** @final @type String */
	CLASS_NAME: "OpenLayers.Control.CenterCursor"
});
/* ======================================================================
    SaigaiTask/Map/Layer/OSMLayer.js
   ====================================================================== */

/**
 * OpenStreetMapベースレイヤ
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 */
SaigaiTask.Map.Layer.OSMLayer = new OpenLayers.Class(OpenLayers.Layer.OSM, {
	/**
	 * OSMレイヤ情報
	 */
	layerInfo: null,

	/**
	 *
	 * @param layerInfo referenceLayerInfo
	 */
	initialize: function(layerInfo) {
		// 引数を処理
		var me = this;
		me.layerInfo = layerInfo;

		var url = layerInfo.wmsURL;
		if(!url.match(".*\\$\{z\}\/\\$\{x\}\/\\$\{y\}\.png$")){
			if(!url.match(".*/$")) url += "/";
			url += "${z}/${x}/${y}.png";
		}
		var options = {
			visibility: layerInfo.visibility,
			buffer: 0,
			alpha: true,
			opacity: 1.0,
			isBaseLayer: true
		};

		// WMSレイヤの初期化
		OpenLayers.Layer.OSM.prototype.initialize.apply(this, [layerInfo.name, url, options]);
	}
});

SaigaiTask.Map.Layer.OSMLayer.type = SaigaiTask.Map.Layer.Type.OSM;
/* ======================================================================
    SaigaiTask/Map/view/ContextMenu.js
   ====================================================================== */

/**
 * 地図のコンテキストメニューです.
 * @require SaigaiTask/Map/view.js
 * @returns {SaigaiTask.Map.view.ContextMenu}
 */
SaigaiTask.Map.view.ContextMenu = function() {
	this.initialize.apply(this, arguments);
};

SaigaiTask.Map.view.ContextMenu.prototype = {

	stmap: null,

	/**
	 * クリックしたときのマウスの座標
	 * @type {OpenLayers.LonLat}
	 */
	lonlat: null,

	initialize: function(stmap, options) {
		var me = this;
		me.stmap = stmap;

		document.getElementById(stmap.div).oncontextmenu = function(e){
			// IE8 対応
			e = e?e:window.event;

			// 登録メニューは使用しない
			if(options!="object") options = {};
			jQuery.extend(options, {
				addContentsMenu: false
			});

			// コンテキストメニューを開いたときのマウスの座標
			var evt = new OpenLayers.Events(e, document.getElementById(stmap.div));
			var xy = evt.getMousePosition(e);
			me.lonlat = stmap.map.getLonLatFromPixel(new OpenLayers.Pixel(xy.x, xy.y));

			// IE8 対応
			var x = e.pageX ? e.pageX : e.clientX;
			var y = e.pageY ? e.pageY : e.clientY;
			return me.showMenu(x, y, options);
		};

		// イベントハンドラ
		me.stmap.events.on({
			// 地図上クリックしたらメニューを閉じる
			"beforemapclick": function() {
				if(!!me.menu && me.menu.isVisible()) {
					me.menu.close();
				}
			}
		})
	},

	/**
	 * メニューを表示します.
	 * @param {Number} x メニューを表示するX座標
	 * @param {Number} y メニューを表示するY座標
	 * @param {SaigaiTask.Map.model.ShowMenuOptions} オプション
	 * @return {Boolean} イベントバブリングするかどうか
	 */
	showMenu: function(x, y, showMenuOptions) {

		if(typeof Ext=='undefined') return;

		var me = this;
		var stmap = me.stmap;

		// メニューのアイテム
		var items = [];
		var lonlat = me.lonlat;

		// オプションの設定
		var options = new SaigaiTask.Map.model.ShowMenuOptions();
		SaigaiTask.Map.copy(options, showMenuOptions);

		// 登録メニューを追加
		if(options.addContentsMenu) {
			var addContentsMenuLayerInfos = [];
			if(typeof options.addContentsMenuLayerInfos!="undefined") {
				addContentsMenuLayerInfos = options.addContentsMenuLayerInfos;
			}
			else {
				for(var ecommapsKey in stmap.ecommaps) {
					var ecommap = stmap.ecommaps[ecommapsKey];
					var contentsLayers = ecommap.contentsLayers;
					for(var contentsLayersKey in contentsLayers) {
						var contentsLayer = contentsLayers[contentsLayersKey];
						addContentsMenuLayerInfos.push(contentsLayer);
					}
				}
			}
			items.push(me.createAddContentsMenuItem(lonlat, addContentsMenuLayerInfos));
		}

		// 削除メニューを追加
		if(options.deleteLayerMenu) {
			var layerInfo = options.layerInfo; // レイヤ情報
			var record = options.record; // 凡例パネルのレコード
			items.push(me.createDeletemenuItem(layerInfo, record));
		}

		//透明度変更メニューを追加
		if(options.transparencyLayerMenu) {
			var layerInfo = options.layerInfo; // レイヤ情報
			var record = options.record; // 凡例パネルのレコード
			items.push(me.createTransparencyMenuItem(layerInfo, record));
		}

		//この場所について
		if(lonlat!=null) {
			items.push(me.createAddPlaceMenuItem(lonlat));
		}

		// メニューを表示する
		if(0<items.length) {
			var menu = me.menu = Ext.create('Ext.menu.Menu', {
				renderTo: Ext.getBody(),
				items: items
			});

			// 指定された位置が無効であれば画面右上に表示する
			if(typeof x=='undefined') x = y = 0;
			menu.setPosition(x, y);

			// メニューを表示
			menu.show();
			return false;
		}

		return true;
	},

	/**
	 * 新規登録メニュー情報を作成します.
	 * 1つしかない場合はサブメニューを作らない
	 * @param {Array<Object>} layerInfos 登録情報レイヤ情報配列
	 */
	createAddContentsMenuItem: function(lonlat, layerInfos) {
		var me = this;
		var stmap = me.stmap;

		// レイヤ選択メニューを作成
		var items = [];
		/** 再帰で子の登録情報を追加する */
		var createItems = function(layerInfo) {
			if(layerInfo.type==SaigaiTask.Map.Layer.Type.LOCAL) {
				// 追加可能なレイヤならば、メニューに表示する
				if(layerInfo.addable==true) {
					items.push({
						text: layerInfo.name,
						layerInfo: layerInfo,
						icon: layerInfo.ecommap.ecommapURL+'/legend?WIDTH=44&HEIGHT=32&cid='+layerInfo.ecommap.mapInfo.communityId+'&mid='+layerInfo.ownerMapId+'&layer='+layerInfo.layerId+'&SCALE=1000'
					});
				}
			}
			else {
				for(var idx in layerInfo.children) {
					var childLayerInfo = layerInfo.children[idx];
					createItems(childLayerInfo);
				}
			}
		};
		for(var idx in layerInfos) {
			var layerInfo = layerInfos[idx];
			createItems(layerInfo);
		}
		// 新規登録メニュー情報
		var menuItem = {
			text: lang.__('Register'),
			icon: stmap.icon.getURL("addIconURL")
		};

		// メニュー選択時の処理
		var onClick = function(layerInfo) {
			// 登録フォームのウィンドウを表示する
			new SaigaiTask.Map.view.ContentsFormWindow({
				stmap: stmap,
				layerInfo: layerInfo,
				lonlat: lonlat
			});
		};

		// 新規登録可能なレイヤがない場合
		if(items.length==0) {
			return null;
		}
		// 1つしかない場合はサブメニューを作成しない
		else if(items.length==1) {
			jQuery.extend(menuItem, {
				listeners: {
					click: function(menu, item, e, eOpts) {
						var layerInfo = items[0].layerInfo;
						onClick(layerInfo);
					}
				}
			});
		}
		// 新規登録可能なレイヤが複数ある場合
		else {
			jQuery.extend(menuItem, {
				hideOnClick: false,
				menu: {
					items: items,
					listeners: {
						click: function(menu, item, e, eOpts) {
							var layerInfo = item.layerInfo;
							onClick(layerInfo);
						}
					}
				}
			});
		}

		return menuItem;
	},

	/**
	 * 削除メニュー情報を作成します.
	 * @type {SaigaiTask.Map.Layer.LayerInfo} layerInfo
	 * @type {Ext.data.Model} record LegendPanel の TreePanel のレコード
	 */
	createDeletemenuItem: function(layerInfo, record) {
		var me = this;
		var stmap = me.stmap;

		// 削除メニュー情報
		var menuItem = {
			text: lang.__('Delete'),
			icon: stmap.icon.getURL("deleteIconURL"),
			listeners: {
				click: function(menu, item, e, eOpts) {
					// 凡例パネルから削除
					var parentNode = record.parentNode;
					record.remove();
					// 地図からレイヤを削除
					{
						// レイヤ情報ツリーを配列として取得
						var layerInfos = [layerInfo];
						if(!!layerInfo.children && layerInfo.children.length > 0) {
							layerInfos = layerInfos.concat(layerInfo.children);
						}

						var records = [];
						for(var idx in layerInfos) {
							// set LayerInfo opacity
							var linfo = layerInfos[idx];
							// set Layer opacity
							var l = linfo.getLayer();
							if(l!=null) {
								stmap.map.removeLayer(l);
							}
						}
						// 凡例パネルの親も削除する
						if(!!parentNode && parentNode.childNodes.length==0) {
							parentNode.remove()
						}
					}
					// セッションの外部地図の場合は、セッションから削除する
					if(layerInfo.isSessionExternalMapLayer()) {
						var records = [];
						var registDeleteRecordRecursive = function(records, layerInfo) {
							if(layerInfo.metadataid!=null) {
								records.push({
									/** メニューID */
									menuinfoid: SaigaiTask.Page.menuInfo.id,
									/** メタデータID */
									metadataid: layerInfo.metadataid,
									updateTime: Ext.Date.format(new Date(), "Y-m-d\\TH:i:s"),
									state: "remove"
								});
							}
							if(layerInfo.children!=null) {
								for(var idx in layerInfo.children) {
									var child = layerInfo.children[idx];
									registDeleteRecordRecursive(records, child);
								}
							}
						};
						registDeleteRecordRecursive(records, layerInfo);

						// サーバのセッションに保存
						if(0<records.length) {
							jQuery.ajax(SaigaiTask.contextPath+"/page/map/sessionMetadata", {
								async: true,
								type: "POST",
								dataType: "json",
								data: {
									records: JSON.stringify(records)
								},
								success: function(data, textStatus, jqXHR) {
									// do nothing
								},
								error: function(jqXHR, status, errorThrown) {
									// do nothing
									console.error(errorThrown);
								}
							});
						}
					}
				}
			}
		};

		return menuItem;
	},

	createAddPlaceMenuItem: function(lonlat) {
		var me = this;
		var stmap = me.stmap;

		// 新規登録メニュー情報
		var menuItem = {
			text: lang.__('About this place,'),
			icon: stmap.icon.getURL("markerIconURL")
		};
		//ランドマーク検索機能が有効か無効か
		var resultLandmark = stmap.api.landmarkValid();
		var landmarkValid = 0;
		var dialogH = 200;//false時の値
		resultLandmark.done(function(message){
			if(message.valid !== undefined){
				if(message.valid == 1){
					landmarkValid = 1;
					dialogH = 290;
				}
			}
		});

		var onClick = function() {
			var win = null;
			lonlat = lonlat.clone().transform(stmap.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));

			Ext.Ajax.request({
				url: stmap.api.url.pointInfoURL,
				params: 'lon='+lonlat["lon"]+'&lat='+lonlat["lat"]+'&_csrf='+SaigaiTask.ajaxcsrfToken,
				success: function(param) {
					var result = JSON.parse(param.responseText);
					var formPanel;

					//ランドマーク登録機能有効時
					if(landmarkValid == 1){
						formPanel = Ext.create('Ext.form.Panel',{
							xtype: 'form',
							autoScroll: true,
							items: [
								{
									xtype: 'fieldset',
									title: lang.__('About this place,'),
									margin: '5',
									// layout:fit なので、幅高さを指定しない
									//width: 275,
									//height: 125,
									defaults: {xtype: 'displayfield', margin: '3', labelWidth: 100, width: 260},
									items: result
								},

								{
									xtype: 'fieldset',
									title: lang.__('Register landmark'),
									margin: '5',
									// layout:fit なので、幅高さを指定しない
									//width: 275,
									//height: 90,
									//style: 'text-align:right;',//「ランドマーク登録」のタイトル文字も右寄せになってしまう
									//defaults: {xtype: 'displayfield', margin: '3', labelWidth: 100, width: 260},
									items: [
										{
											xtype : 'textfield',
											fieldLabel : lang.__('Landmark name'),
											name : 'landmark',
											width : 250
										},
										{
											xtype : 'button',
											text : lang.__('Registration'),
											width : 50,
											//style: 'text-align:right;',//効かない
											handler: function(){
												var landmarkVal = formPanel.getForm().findField('landmark').getValue();
												if(landmarkVal.length>0){
													//alert(landmarkVal+'を登録しました。\nlon='+lonlat["lon"]+', lat='+lonlat["lat"]);
													var result = stmap.api.landmarkRegist(landmarkVal, lonlat["lon"], lonlat["lat"]);
													result.done(function(message){
														if(message.error === undefined){
															alert(lang.__('{0} registered.', message.landmark));
														}else{
															//エラー時にはmessage.errorにメッセージが入っている
															alert(message.error);
														}
													});
													result.fail(function(message){
														alert(lang.__("Failed to register landmark."));
													});
													win.close();
												}else{
													alert(lang.__("Enter the name of landmark to be registered"));
												}
											}
										}
									]
								}
							]
						});

					//ランドマーク登録機能有効時
					}else{
						formPanel = Ext.create('Ext.form.Panel',{
							xtype: 'form',
							autoScroll: true,
							items: [
								{
									xtype: 'fieldset',
									title: lang.__('About this place,'),
									margin: '5',
									// layout:fit なので、幅高さを指定しない
									//width: 275,
									//height: 125,
									defaults: {xtype: 'displayfield', margin: '3', labelWidth: 100, width: 260},
									items: result
								}
							]
						});
					}

					if(!!me.window) me.window.close();
					win = me.window = Ext.create('Ext.window.Window', {
						title: lang.__('About this place,'),
						//width: 300, height: 290,
						width: 300, height: dialogH,
						maxWidth: document.body.clientWidth,
						maxHeight: document.body.clientHeight,
						layout: 'fit',
						items: formPanel,
						buttons: [{
							text: lang.__('Close'),
							handler: function(){ win.close(); }
						}]
					});

					// ウィンドウ表示
					win.show();
				},
				callback: function() {
				}
			});
		};

		jQuery.extend(menuItem, {
			listeners: {
				click: function(menu, item, e, eOpts) {
					onClick();
				}
			}
		});

		return menuItem;
	},

	/**
	 * 透明度変更メニュー情報を作成します.
	 * @type {Map.Layer.LayerInfo} layerInfo
	 */
	createTransparencyMenuItem: function(layerInfo, record){
		var me = this;
		var stmap = me.stmap;

		// 透明度変更メニュー情報
		var menuItem = {
			text: lang.__('Transmittance change'),
			icon: stmap.icon.getURL("transparencyURL"),
			listeners:{
				click: function(){
					var form = Ext.create('Ext.form.Panel',{
						xtype: 'form',
						autoScroll: true,
						items: [{
							xtype: 'combo',
							name: 'transparency',
							fieldLabel: lang.__('Transmittance'),
							store:{
								fields:['name','value'],
								data:[
								      {"name":lang.__("0%(nontransparent)"), "value":"1.0"},
								      {"name":"10%", "value":"0.9"},
								      {"name":"20%", "value":"0.8"},
								      {"name":"30%", "value":"0.7"},
								      {"name":"40%", "value":"0.6"},
								      {"name":"50%", "value":"0.5"},
								      {"name":"60%", "value":"0.4"},
								      {"name":"70%", "value":"0.3"},
								      {"name":"80%", "value":"0.2"},
								      {"name":"90%", "value":"0.1"}
								      ]
							},
							queryMode:'local',
							displayField:'name',
							valueField: 'value',
							//opcacityの値がきれいな数字ではないので四捨五入
							value: Math.round((1 - layerInfo.opacity) * 100)+'%'
						}],
						buttons:[{
							text: lang.__('Proceed'),
							handler: function() {
								// 透明度
								var opacity = form.getValues().transparency;

								// レイヤ情報ツリーを配列として取得
								var layerInfos = [layerInfo];
								if(!!layerInfo.children && layerInfo.children.length > 0) {
									layerInfos = layerInfos.concat(layerInfo.children);
								}

								var records = [];
								for(var idx in layerInfos) {
									// set LayerInfo opacity
									var linfo = layerInfos[idx];
									linfo.opacity = opacity;
									// set Layer opacity
									var l = linfo.getLayer();
									if(l!=null && l.opacity!=opacity) l.setOpacity(opacity);
									
									// create sessionMetadata record
									var record = {
											/** 更新リクエスト */
											state: "update",
											/** メニューID */
											menuinfoid: SaigaiTask.Page.menuInfo.id,
											/** 透明度 */
											layeropacity: opacity
									};
									
									// 外部地図の場合
									if(SaigaiTask.Map.Layer.Type.isExternalmapLayerType(linfo.type)) {
										if(!linfo.metadataid) continue;

										/** メタデータID */
										record.metadataid = linfo.metadataid;
										/** セッションに保存された外部地図レイヤかどうか */
										record.sessionExternalMapLayer = linfo.layerId.indexOf("extmap_session")==0;
									}
									// 主題図などの外部地図ではないeコミで持つレイヤの場合
									else {
										record.layerId = linfo.layerId;
									}
									records.push(record);
								}

								jQuery.ajax(SaigaiTask.contextPath+"/page/map/sessionMetadata", {
									headers: {"X-CSRF-Token":'${cookie.JSESSIONID.value}'},
									async: false,
									type: "post",
									data: {
										records: JSON.stringify(records)
									},
									success: function(data, textStatus, jqXHR) {
										//SaigaiTask.PageURL.move();
										
									},
									error: function(jqXHR, status, errorThrown) {
										// do nothing
										console.error(errorThrown);
									}
								});

				                // フォームデータの取得
				                console.log(form.getValues().transparency);
				                win.close();
				            },
						},{
							text: lang.__('Close'),
							handler: function(){ win.close(); }
						}
						]
					});
					if(!!me.window) me.window.close();
					win = me.window = Ext.create('Ext.window.Window', {
						title: lang.__('Transmittance change'),
						width: 300, height: 100,
						maxWidth: document.body.clientWidth,
						maxHeight: document.body.clientHeight,
						layout: 'fit',
						items: form
					});

					// ウィンドウ表示
					win.show();
				}
			}
		};

		return menuItem;
	}
};
/* ======================================================================
    SaigaiTask/Map/view/ContentsPopup.js
   ====================================================================== */

/**
 * 1件分の登録情報をポップアップ表示するクラスです.
 * @class SaigaiTask.Map.view.ContentsPopup
 * @requires SaigaiTask/Map/view/Popup.js
 */
SaigaiTask.Map.view.ContentsPopup = new OpenLayers.Class(SaigaiTask.Map.view.Popup, {

	stmap: null,

	/**
	 * 登録情報のレイヤ情報
	 * @type {SaigaiTask.Map.Layer.LayerInfo}
	 */
	layerInfo: null,

	initialize: function(stmap) {
		this.stmap = stmap;
	},

	/**
	 * 1件分の登録情報をポップアップします.
	 * 属性はグリッド形式で表示します.
	 * @param {Object}  options
	 * @param {Boolean} options.fromList リストへ戻るフラグ
	 * @param {Boolean} options.pinned ピン留めフラグ
	 */
	show: function(layerId, fid, result, center, bbox, options) {
		var me = this;
		var stmap = me.stmap;
		var items = new Array(); // Ext widget

		//地図初期表示時かどうか
		var pinned = false;
		if(typeof options != 'undefined'){
			pinned = options.pinned;
		}

		// ポップアップの位置が決まっていない場合は、登録情報から取得する
		if((typeof center=='undefined' || center==null) && result.geom[0] != null){
			var wkt = result.geom[0];
			try{
				var wktFormat = new OpenLayers.Format.WKT();
				var feature = wktFormat.read(wkt);
				var centroid = feature.geometry.getCentroid();
				center = new OpenLayers.LonLat(centroid.x, centroid.y);
				// センターに設定
				stmap.setCenter(center.clone());
			}catch(e) {
				alert(lang.__("Unable to get position info."));
				console.error(lang.__("Failed to get position info :")+layerId+"."+fid);
				console.error(e);
				return;
			}
		}

		// タイトル
		var layerInfo = me.layerInfo = stmap.getLayerInfo(layerId);
		var layer = layerInfo.getLayer();
		var title = null;
		if(layerInfo!=null) title = layerInfo.name;

		// 添付ファイルのレイアウトを指定する
		// 縦型: vbox   横型: hbox
		var layout = "vbox";

		// 画像と属性を横並びにするHBox
		var hbox = {
			xtype: 'container',
			layout: layout,
			width: 0,
			items: []
		};
		var hboxContainerObj = Ext.create('Ext.container.Container', hbox);

		// ファイル
		var files = result.files;
		if(files && 0<files.length) {
			if(hboxContainerObj.layout.type=="hbox") {
				// 画像のコンテナを生成
				var imgContainerWidth = 256; // ポップアップウィンドウの画像の幅はいくつにする？
				var extImgContainer = {
					xtype: 'container',
					width: imgContainerWidth,
					style: {
						'text-align': 'center',
						cursor: 'pointer'
					}
				};
				var extImgContainerObj = Ext.create('Ext.container.Container', extImgContainer);

				// HBoxに配置する
				hboxContainerObj.add(extImgContainerObj);
				hbox.width += extImgContainer.width;

				// 最大幅は画像コンテナの幅
				var maxw = imgContainerWidth;
				// 最大高さはhboxコンテナの高さ
				var maxh = maxw;

				var filesIdx = 0;
				while(filesIdx<files.length) {
					// 画像URLのサーバ名を動的に取得する
					var server = stmap.ecommaps[0].ecommapURL+'/..';
					// 画像URL
					var fileURL = files[filesIdx];
					if(fileURL.indexOf('http')==-1) fileURL = server + fileURL;
					var fileTitle = files[filesIdx+1];

					var extImgObj = stmap.createImg(fileURL, fileTitle, maxw, maxh);
					extImgContainerObj.add(extImgObj);

					filesIdx += 2;
				}
			}
		}

		// 属性
		var attrs = result.attrs;
		// レイヤ情報から編集フラグを取得する
		var editable = false;
		if(typeof layerInfo.editable!="undefined") {
			editable = layerInfo.editable;
		}
		var editablePopup = false;
		if(editable && editablePopup) {
			// ポップアップ内編集モードを表示
			// 編集フォームを追加
			var contentsFormPanel = new SaigaiTask.Map.view.ContentsFormPanel(stmap, layerId, null, fid, content);
			var width = 250;
			contentsFormPanel.formPanel.setWidth(width);
			hboxContainerObj.add(contentsFormPanel.formPanel);
			hbox.width += width;
		}
		else {
			// 属性グリッドを表示
			var grid = me.createAttrGrid(attrs, layerInfo);
			// HBoxに配置する
			hboxContainerObj.add(grid);
			hbox.width += grid.width;
		}

		// ファイル
		var files = result.files;
		if(files && 0<files.length) {
			if(hboxContainerObj.layout.type=="vbox") {
				// ファイルフォームパネル
				// 添付ファイルフォームを生成
				var contentsFileFormPanel = me.contentsFileFormPanel = new SaigaiTask.Map.view.ContentsFileFormPanel(stmap, result, {
					mid: stmap.mapId,
					layerId: layerId,
					fid: fid,
					editable: false
				});
				var imagesViewPanel = contentsFileFormPanel.formPanel;
				imagesViewPanel.setWidth(250);
				hboxContainerObj.add(imagesViewPanel);
			}
		}

		items.push(hboxContainerObj);


		// 一覧へ戻るボタン
		if(typeof options!='undefined' && options['fromList']){
			var button = Ext.create("Ext.Button", {
				text: lang.__("Return to list<!--2-->"),
				scale : 'small',
				handler: function() {
					if(stmap.popupManager!=null) {
						stmap.popupManager.close(me.popup);
					}
					stmap.clickSearch(center, bbox, me.popup.pinned);
					return false;
				}
			});
			items.push(button);
		}

		var map = stmap.map;
		if(stmap.popupManager!=null) {
			stmap.popupManager.closeAll();
		}

		var externalData = result.external;
		var toolbarData = {
			buttons: []
		};
		if(externalData){
			toolbarData = externalData.toolbar;
		}
		else {
			// 属性情報の設定からツールバーボタンを生成する
			for(var idx=0; idx<attrs.length; idx++) {
				var attr = attrs[idx];
				var attrId = attr.attrId;
				var value = attr.attrValue;
				var attrInfo = layerInfo.getAttrInfo(attrId);
				if(attrInfo==null || attrInfo.buttonData==null) continue;
				var buttonData = {
					url: value
				};
				SaigaiTask.Map.extend(buttonData, attrInfo.buttonData);
				toolbarData.buttons.push(buttonData);
			}
		}

		// 編集可のレイヤの場合
		if(editable) {
			if(typeof toolbarData.buttons=="undefined") {
				toolbarData.buttons = [];
			}
			var deleteButton = {
				text: lang.__("Delete"),
				icon: stmap.icon.getURL("deleteIconURL"),
				handler: function() {
					// 時間指定中なら削除禁止とする
					if(!!SaigaiTask.PageURL.getTime()) {
						alert(lang.__("Can't delete during time set."));
						return;
					}
					if(confirm(lang.__("Are you sure to delete?"))) {
						stmap.api.deleteContent(layerId, fid, function() {
							if(stmap.popupManager!=null) {
								stmap.popupManager.close(me.popup);
							}
							if(layer!=null) {
								layer.refreshParams({
									nocache: true
								});
							}
							stmap.events.triggerEvent(stmap.EventType.successcontentsdelete, {
								contentsPopup: me,
								layerInfo: layerInfo
							});
						});
					}
				}
			};
			if(editablePopup) {
				// 保存ボタンの追加
				toolbarData.buttons.push({
					text: lang.__("Save"),
					icon: stmap.icon.getURL("editIconURL"),
					handler: function() {
						contentsFormPanel.submit();
					}
				});
				// 削除ボタンの追加
				toolbarData.buttons.push(deleteButton);
			}
			else {
				// 編集ボタンの追加
				toolbarData.buttons.push({
					text: lang.__("Edit"),
					icon: stmap.icon.getURL("editIconURL"),
					handler: function() {
						if(stmap.popupManager!=null) {
							// 時間指定中なら編集禁止とする
							if(!!SaigaiTask.PageURL.getTime()) {
								alert(lang.__("Can't edit during time set."));
								return;
							}

							var wkt = result.geom[0];
							var wktFormat = new OpenLayers.Format.WKT();
							var feature = wktFormat.read(wkt);
							stmap.popupManager.close(me.popup);
							new SaigaiTask.Map.view.ContentsFormWindow({
								stmap: stmap,
								layerInfo: layerInfo,
								fid: fid,
								lonlat: center,
								feature: feature,
								content: result
							});
						}
					}
				});
				// 削除ボタンの追加
				toolbarData.buttons.push(deleteButton);
			}
		}

		// ExtPopupのオプション
		var option = {
			map: stmap,
			olmap: map,
			center: center,
			items: items,
			toolbarData: toolbarData,
			panelWidth: hbox.width,
			layerId: layerId,
			featureId: fid,
			title: title,
			pinned: pinned,
			metadataId: layerInfo.metadataid,
			searchButtonInfo: {
				url: stmap.api.url.contentsSearchURL,
				mid: stmap.mapId,
				contentsLayers: stmap.ecommaps[0].contentsLayers,
				featureInfo: result
			}
		};

		// 登録情報ポップアップ表示前イベント
		stmap.events.triggerEvent(stmap.EventType.beforeshowcontentpopup, {
			options: option
		});

		me.showExtPopup(option);

		// URL再現用のポップアップパラメータの付与
		me.popup.popupParam = layerId+"."+fid;
	},

	createDeleteButton: function() {

	},

	/**
	 * 登録情報の属性グリッドを生成します.
	 * @param attrs 属性情報配列
	 * @param layerInfo レイヤ情報
	 */
	createAttrGrid: function(attrs, layerInfo) {
		var grid = null;
		if(attrs){
			var data = (function(attrs){
				var data = new Array();
				for(var idx=0; idx<attrs.length; idx++) {
					var attr = attrs[idx];
					var attrId = attr.attrId;
					// 属性情報を取得
					var attrInfo = !!layerInfo ? layerInfo.getAttrInfo(attrId) : null;
					var name = attr.attrName;
					// レイヤ情報があれば、そちらの属性名称を優先して表示する
					if(attrInfo!=null) {
						name = attrInfo.name;
					}
					var value = attr.attrValue;
					// JSONArray 文字列かどうか
					var jsonDataExps = null;
					try {jsonDataExps=jQuery.parseJSON(attrInfo.dataExp)} catch(e){/* do nothing */}
					if(jsonDataExps!=null) {
						for(var jsonDataExpsIdx in jsonDataExps) {
							var jsonDataExp = jsonDataExps[jsonDataExpsIdx];
							if(typeof jsonDataExp[attr.attrValue]!="undefined") {
								value = jsonDataExp[attr.attrValue];
								break;
							}
						}
					}
					// レイヤ情報で非表示属性になっていれば表示しない
					if(!!layerInfo && !layerInfo.isVisibleAttr(attrId)) continue;
					data.push({
						attrId: attrId,
						name: name,
						value: value
					});
				}
				return data;
			})(attrs);
			// もし、表示属性がない場合は追加する
			if(!!layerInfo) {
				for(var idx in layerInfo.attrInfos) {
					var attrInfo = layerInfo.attrInfos[idx];
					var attrId = attrInfo.attrId;
					if(layerInfo.isVisibleAttr(attrId)) {
						var exist = false;
						for(var idx2 in data) {
							var attr = data[idx2];
							if(attr.attrId==attrId) {
								exist = true;
								break;
							}
						}
						if(!exist) {
							data.push({
								attrId: attrId,
								name: attrInfo.name,
								value: null //"(属性がありません)"
							});
						}
					}
				}
			}
			// disporder順でソート
			if(!!layerInfo) {
				data.sort(function(attr1, attr2) {
					return layerInfo.evalAttrSort(attr1.attrId, attr2.attrId);
				});
			}
			Ext.define('ContentsAttrModel', {
				extend: 'Ext.data.Model',
				fields: [{
					name: 'attrId',
					type: 'text'
				}, {
					name: 'name',
					type: 'text'
				}, {
					name: 'value',
					type:'text'
				}]
			});
			var store = Ext.create("Ext.data.Store", {
				model: 'ContentsAttrModel',
				data: data
			});
			grid = Ext.create("Ext.grid.Panel", {
				store: store,
				width: 250,
				cls: "attrgridpanel",
				columns: [{
					text: lang.__('Attribute ID'),
					dataIndex: 'attrId',
					flex: 1,
					sortable: false,
					hidden: true
				}, {
					text: lang.__('Attribute'),
					dataIndex: 'name',
					flex: 1,
					sortable: false
				}, {
					text: lang.__('Value'),
					dataIndex: 'value',
					flex: 2,
					sortable: false
				}],
				viewConfig: {
					getRowClass: function(record, rowIndex, rowParams, store) {
						var classes = [];
						var attrId = record.data.attrId;
						var attrInfo = !!layerInfo ? layerInfo.getAttrInfo(attrId) : null;
						if(attrInfo!=null && attrInfo.highlight==true) {
							return "highlight";
						}
						return null;
					}
				}
			});
		}
		return grid;
	}
});
/* ======================================================================
    OpenLayers/Control/ScaleBar.js
   ====================================================================== */

/* Copyright (c) 2009 National Research Institute for Earth Science and
 * Disaster Prevention (NIED).
 * This code is licensed under the GPL version 3 license, available at the root
 * application directory.
 */
/* Copyright (c) 2006-2008 MetaCarta, Inc., published under the Clear BSD
 * license.  See http://svn.openlayers.org/trunk/openlayers/license.txt for the
 * full text of the license. */

/**
 * requires OpenLayers/Control.js
 */

/**
 * Class: OpenLayers.Control.ScaleBar
 * A scale bar styled with CSS.
 * 
 * Inherits from:
 *	- <OpenLayers.Control>
 */
OpenLayers.Control.ScaleBar = OpenLayers.Class(OpenLayers.Control, {

	/**
	 * Property: element
	 * {Element}
	 */
	element: null,
	
	/**
	 * Property: scale
	 * {Float} Scale denominator (1 / X) - set on update
	 */    
	scale: 1,

	/**
	 * APIProperty: displaySystem
	 * {String} Display system for scale bar - metric or english supported.
	 *	   Default is metric.
	 */
	displaySystem: 'metric',

	/**
	 * APIProperty: minWidth
	 * {Integer} Minimum width of the scale bar in pixels.	Default is 100 px.
	 */
	minWidth: 100,

	/**
	 * APIProperty: maxWidth
	 * Maximum width of the scale bar in pixels.  Default is 200 px.
	 */
	maxWidth: 200,

	/**
	 * APIProperty: divisions
	 * {Integer} Number of major divisions for the scale bar.  Default is 2.
	 */
	divisions: 2,

	/**
	 * APIProperty: subdivisions
	 * {Integer} Number of subdivisions per major division.  Default is 2.
	 */
	subdivisions: 2,

	/**
	 * APIProperty: showMinorMeasures
	 * {Boolean} Show measures for subdivisions.  Default is false.
	 */
	showMinorMeasures: false,

	/**
	 * APIProperty: abbreviateLabel
	 * {Boolean} Show abbreviated measurement unit (ft, km).  Default is false.
	 */
	abbreviateLabel: true,

	/**
	 * APIProperty: singleLine
	 * {Boolean} Display scale bar length and unit after scale bar.  Default
	 *	   is false.
	 */
	singleLine: false,

	/**
	 * APIProperty: align
	 * {String} Determines how scale bar will be aligned within the element -
	 * left, center, or right supported
	 */
	align: 'left',
	
	/**
	 * APIProperty: div
	 * {Element} Optional DOM element to become the container for the scale
	 *	   bar.  If not provided, one will be created.
	 */
	div: null,
	
	/**
	 * Property: scaleText
	 * Text to prefix the scale denominator used as a title for the scale bar
	 *	   element.  Default is "scale 1:".
	 */
	scaleText: "scale 1/",
	
	/**
	 * Property: thousandsSeparator
	 * Thousands separator for formatted scale bar measures.  The title
	 *	   attribute for the scale bar always uses
	 *	   <OpenLayers.Number.thousandsSeparator> for number formatting.  To
	 *	   conserve space on measures displayed with markers, the default
	 *	   thousands separator for formatting is "" (no separator).
	 */
	thousandsSeparator: "",

	/**
	 * Property: measurementProperties
	 * {Object} Holds display units, abbreviations, and conversion to inches
	 * (since we're using dpi) per measurement sytem.
	 */
	measurementProperties: {
		english: {
			units: ['mile', 'feet', 'inche'],
			abbr: ['mi', 'ft', 'in'],
			inches: [63360, 12, 1]
		},
		metric: {
			units: ['kilometer', 'meter', 'centimeter'],
			abbr: ['km', 'm', 'cm'],
			inches: [39370.07874, 39.370079, 0.393701]
		}
	},

	/**
	 * Property: limitedStyle
	 * {Boolean} For browsers with limited CSS support, limitedStyle will be
	 *	   set to true.  In addition, this property can be set to true in the
	 *	   options sent to the constructor.  If true scale bar element offsets
	 *	   will be determined based on the <defaultStyles> object.
	 */
	limitedStyle: false,
	
	/**
	 * Property: customStyle
	 * {Object} For cases where <limitedStyle> is true, a customStyle property
	 *	   can be set on the options sent to the constructor.  The
	 *	   <defaultStyles> object will be extended with this custom style
	 *	   object.
	 */
	customStyles: null,

	/**
	 * Property: defaultStyles
	 * {Object} For cases where <limitedStyle> is true, default scale bar
	 *	   element offsets are taken from this object.	Values correspond to
	 *	   pixel dimensions given in the stylesheet.
	 */
	defaultStyles: {
	},
	
	/**
	 * Property: appliedStyles
	 * For cases where <limitedStyle> is true, scale bar element offsets will
	 *	   be determined based on <defaultStyles> extended with any
	 *	   <customStyles>.
	 */
	appliedStyles: null,

	/**
	 * Constructor: OpenLayers.Control.ScaleBar
	 * Create a new scale bar instance.
	 *
	 * Parameters: 
	 * options - {Object} Optional object whose properties will be set on this
	 *	   object.
	 */
	initialize: function(options) {
		OpenLayers.Control.prototype.initialize.apply(this, [options]);
		if(!document.styleSheets) {
			this.limitedStyle = true;
		}
		if(this.limitedStyle) {
			this.appliedStyles = OpenLayers.Util.extend({}, this.defaultStyles);
			OpenLayers.Util.extend(this.appliedStyles, this.customStyles);
		}
		// create scalebar DOM elements
		this.element = document.createElement('div');
		this.element.style.position = 'relative';
		this.element.className = this.displayClass + 'Wrapper';
		this.labelContainer = document.createElement('div');
		this.labelContainer.className = this.displayClass + 'Units';
		this.labelContainer.style.position = 'absolute';
		this.graphicsContainer = document.createElement('div');
		this.graphicsContainer.style.position = 'absolute';
		this.graphicsContainer.className = this.displayClass + 'Graphics';
		this.numbersContainer = document.createElement('div');
		this.numbersContainer.style.position = 'absolute';
		this.numbersContainer.className = this.displayClass + 'Numbers';
		this.element.appendChild(this.graphicsContainer);
		this.element.appendChild(this.labelContainer);
		this.element.appendChild(this.numbersContainer);
	},
	
	/**
	 * APIMethod: destroy
	 * Destroy the control.
	 */
	destroy: function() {
		this.map.events.unregister('moveend', this, this.onMoveend);
		this.div.innerHTML = "";
		OpenLayers.Control.prototype.destroy.apply(this);
	},

	/**
	 * Method: draw
	 */    
	draw: function() {
		OpenLayers.Control.prototype.draw.apply(this, arguments);
		// determine offsets for graphic elements
		this.dxMarkerMajor = (
			this.styleValue('MarkerMajor', 'borderLeftWidth') +
			this.styleValue('MarkerMajor', 'width') +
			this.styleValue('MarkerMajor', 'borderRightWidth')
		) / 2;
		this.dxMarkerMinor = (
			this.styleValue('MarkerMinor', 'borderLeftWidth') +
			this.styleValue('MarkerMinor', 'width') +
			this.styleValue('MarkerMinor', 'borderRightWidth')
		) / 2;
		this.dxBar = (
			this.styleValue('Bar', 'borderLeftWidth') +
			this.styleValue('Bar', 'borderRightWidth')
		) / 2;
		this.dxBarAlt = (
			this.styleValue('BarAlt', 'borderLeftWidth') +
			this.styleValue('BarAlt', 'borderRightWidth')
		) / 2;
		this.dxNumbersBox = this.styleValue('NumbersBox', 'width') / 2;
		// set scale bar element height
		var classNames = ['Bar', 'BarAlt', 'MarkerMajor', 'MarkerMinor'];
		if(this.singleLine) {
			classNames.push('LabelBoxSingleLine');
		} else {
			classNames.push('NumbersBox', 'LabelBox');
		}
		var vertDisp = 0;
		for(var classIndex = 0; classIndex < classNames.length; ++classIndex) {
			var cls = classNames[classIndex];
			vertDisp = Math.max(
				vertDisp,
				this.styleValue(cls, 'top') + this.styleValue(cls, 'height')
			);
		}
		this.element.style.height = vertDisp + 'px';
		this.xOffsetSingleLine = this.styleValue('LabelBoxSingleLine', 'width') +
								 this.styleValue('LabelBoxSingleLine', 'left');
		
		this.div.appendChild(this.element);
		this.map.events.register('moveend', this, this.onMoveend);
		this.update();
		return this.div;
	},
	
	/**
	 * Method: onMoveend
	 * Registered as a listener for "moveend".
	 */
	onMoveend: function() {
		this.update();
	},
   
	/**
	 * APIMethod: update
	 * Update the scale bar after modifying properties.
	 *
	 * Parameters:
	 * scale - {Float} Optional scale denominator.	If not specified, the
	 *	   map scale will be used.
	 */
	update: function(scale) {
		if(this.map.baseLayer == null || !this.map.getScale()) {
			return;
		}
		this.scale = (scale != undefined) ? scale : this.map.getScale();
		// update the element title and width
		this.element.title = this.scaleText + OpenLayers.Number.format(this.scale);
		this.element.style.width = this.maxWidth + 'px';
		
		var c = this.map.getCenter();
		if (this.map.displayProjection && this.map.getProjectionObject().getCode() != "EPSG:4326") {
			c.transform(this.map.getProjectionObject(), this.map.displayProjection);
		}
		var latRate = Math.cos(c.lat/180*Math.PI);
		// check each measurement unit in the display system
		var comp = this.getComp(latRate);
		// get the value (subdivision length) with the lowest cumulative score
		this.setSubProps(comp);
		if (!this.subProps) return;
		//if (!this.subProps) { console.log("ScaleBar no subProps"); return;}
		// clean out any old content from containers
		this.subProps.pixels /= latRate;
		
		this.labelContainer.innerHTML = "";
		this.graphicsContainer.innerHTML = "";
		this.numbersContainer.innerHTML = "";
		// create all divisions
		var numDiv = this.divisions * this.subdivisions;
		var alignmentOffset = {
			left: 0 + (this.singleLine ? 0 : this.dxNumbersBox),
			center: (this.maxWidth / 2) -
				(numDiv * this.subProps.pixels / 2) -
				(this.singleLine ? this.xOffsetSingleLine / 2 : 0),
			right: this.maxWidth -
				(numDiv *this.subProps.pixels) -
				(this.singleLine ? this.xOffsetSingleLine : this.dxNumbersBox)
		};
		var xPos, measure, divNum, cls, left;
		for(var di=0; di<this.divisions; ++di) {
			// set xPos and measure to start of division
			xPos = di * this.subdivisions * this.subProps.pixels +
				   alignmentOffset[this.align];
			// add major marker
			this.graphicsContainer.appendChild(this.createElement(
				"MarkerMajor", " ", xPos - this.dxMarkerMajor
			));
			// add major measure
			if(!this.singleLine) {
				measure = (di == 0) ? 0 :
					OpenLayers.Number.format(
						(di * this.subdivisions) * this.subProps.length,
						this.subProps.dec, this.thousandsSeparator
					);
				this.drawNumbersBox(measure, xPos);
			}
			// create all subdivisions
			for(var si=0; si<this.subdivisions; ++si) {
				if((si % 2) == 0) {
					cls = "Bar";
					left = xPos - this.dxBar;
				} else {
					cls = "BarAlt";
					left = xPos - this.dxBarAlt;
				}
				this.graphicsContainer.appendChild(this.createElement(
					cls, " ", left, this.subProps.pixels
				));
				// add minor marker if not the last subdivision
				if(si < this.subdivisions - 1) {
					// set xPos and measure to end of subdivision
					divNum = (di * this.subdivisions) + si + 1;
					xPos = divNum * this.subProps.pixels +
						   alignmentOffset[this.align];
					this.graphicsContainer.appendChild(this.createElement(
						"MarkerMinor", " ", xPos - this.dxMarkerMinor
					));
					if(this.showMinorMeasures && !this.singleLine) {
						// add corresponding measure
						measure = divNum * this.subProps.length;
						this.drawNumbersBox(measure, xPos);
					}
				}
			}
		}
		// set xPos and measure to end of divisions
		xPos = numDiv * this.subProps.pixels;
		xPos += alignmentOffset[this.align];
		// add the final major marker
		this.graphicsContainer.appendChild(this.createElement(
			"MarkerMajor", " ", xPos - this.dxMarkerMajor
		));
		// add final measure
		measure = OpenLayers.Number.format(
			numDiv * this.subProps.length,
			this.subProps.dec, this.thousandsSeparator
		) + " "+ this.subProps.abbr;
		if(!this.singleLine) {
			this.drawNumbersBox(measure, xPos);
		}
		// add content to the label element
		/*
		var labelBox = document.createElement('div');
		labelBox.style.position = 'absolute';
		var labelText;
		if(this.singleLine) {
			labelText = measure;
			labelBox.className = this.displayClass + 'LabelBoxSingleLine';
			labelBox.style.left = Math.round(
				xPos + this.styleValue('LabelBoxSingleLine', 'left')) + 'px';
		} else {
			labelText = '';
			labelBox.className = this.displayClass + 'LabelBox';
			labelBox.style.textAlign = 'center';
			labelBox.style.width = Math.round(numDiv * this.subProps.pixels) + 'px'
			labelBox.style.left = Math.round(alignmentOffset[this.align]) + 'px';
			labelBox.style.overflow = 'hidden';
		}
		if(this.abbreviateLabel) {
			labelText += ' ' + this.subProps.abbr;
		} else {
			labelText += ' ' + this.subProps.units;
		}
		var span = document.createElement("span");
		span.appendChild(document.createTextNode(labelText));
		labelBox.appendChild(span);
		this.labelContainer.appendChild(labelBox);
		*/
	},
	
	drawNumbersBox : function(measure, xPos) {
		this.numbersContainer.appendChild(this.createElement(
				"NumbersBoxBgUp", measure, xPos - this.dxNumbersBox -1
			));
		this.numbersContainer.appendChild(this.createElement(
				"NumbersBoxBgUp", measure, xPos - this.dxNumbersBox +1
			));
		this.numbersContainer.appendChild(this.createElement(
				"NumbersBoxBg", measure, xPos - this.dxNumbersBox -1
			));
		this.numbersContainer.appendChild(this.createElement(
				"NumbersBoxBg", measure, xPos - this.dxNumbersBox +1
			));
		this.numbersContainer.appendChild(this.createElement(
			"NumbersBox", measure, xPos - this.dxNumbersBox
		));
		
	},
	
	/**
	 * Method: createElement
	 * Create a scale bar element.	These are absolutely positioned with
	 *	   hidden overflow and left offset.
	 *
	 * Parameters:
	 * cls - {String} Class name suffix.
	 * text - {String} Text for child node.
	 * left - {Float} Left offset.
	 * width - {Float} Optional width.
	 * 
	 * Returns:
	 * {Element} A scale bar element.
	 */
	createElement: function(cls, text, left, width) {
		var element = document.createElement("div");
		element.className = this.displayClass + cls;
		OpenLayers.Util.extend(element.style, {
			position: "absolute",
			textAlign: "center",
			overflow: "hidden",
			left: Math.floor(left) + "px"
		});
		element.appendChild(document.createTextNode(text));
		if(width) {
			element.style.width = Math.round(width) + "px";
		}
		return element;
	},
	
	/**
	 * Method: getComp
	 * Get comparison matrix.
	 */
	getComp: function(rate) {
		var system = this.measurementProperties[this.displaySystem];
		var numUnits = system.units.length;
		var comp = new Array(numUnits);
		var numDiv = this.divisions * this.subdivisions;
		for(var unitIndex = 0; unitIndex < numUnits; ++unitIndex) {
			comp[unitIndex] = {};
			var ppdu = OpenLayers.DOTS_PER_INCH *
				system.inches[unitIndex] / this.scale;
			var minSDDisplayLength = ((this.minWidth*rate - this.dxNumbersBox) /
									   ppdu) / numDiv;
			var maxSDDisplayLength = ((this.maxWidth*rate - this.dxNumbersBox) /
									   ppdu) / numDiv;
			// add up scores for each marker (even if numbers aren't displayed)
			for(var vi=0; vi<numDiv; ++vi) {
				var minNumber = minSDDisplayLength * (vi + 1);
				var maxNumber = maxSDDisplayLength * (vi + 1);
				var num = this.getHandsomeNumber(minNumber, maxNumber);
				var compNum = {
					value: (num.value / (vi + 1)),
					score: 0, tie: 0, dec: 0, displayed: 0
				};
				// tally up scores for all values given this subdivision length
				for(var vi2=0; vi2<numDiv; ++vi2) {
					var position = num.value * (vi2 + 1) / (vi + 1);
					var num2 = this.getHandsomeNumber(position, position);
					var major = ((vi2 + 1) % this.subdivisions == 0);
					var last = ((vi2 + 1) == numDiv);
					if((this.singleLine && last) ||
					   (!this.singleLine && (major || this.showMinorMeasures))) {
						// count scores for displayed marker measurements
						compNum.score += num2.score;
						compNum.tie += num2.tie;
						compNum.dec = Math.max(compNum.dec, num2.dec);
						compNum.displayed += 1;
					} else {
						// count scores for non-displayed marker measurements
						compNum.score += num2.score / this.subdivisions;
						compNum.tie += num2.tie / this.subdivisions;
					}
				}
				// adjust scores so numbers closer to 1 are preferred for display
				compNum.score *= (unitIndex + 1) * compNum.tie / compNum.displayed;
				comp[unitIndex][vi] = compNum;
			}
		}
		return comp;
	},
	
	/**
	 * Method: setSubProps
	 * Set subdivision properties based on comparison matrix.
	 */
	setSubProps: function(comp) {
		var system = this.measurementProperties[this.displaySystem];
		var score = Number.POSITIVE_INFINITY;
		var tie = Number.POSITIVE_INFINITY;
		for(var unitIndex = 0; unitIndex < comp.length; ++unitIndex) {
			var ppdu = OpenLayers.DOTS_PER_INCH * system.inches[unitIndex] / this.scale;
			for(var vi in comp[unitIndex]) {
				var compNum = comp[unitIndex][vi];
				//if((compNum.score < score) ||
				//	 ((compNum.score == score) && (compNum.tie < tie))) {
				//	console.log(compNum.value);
				if (compNum.value >= 0.33 && (compNum.value < 330 || unitIndex == 0)) {
					this.subProps = {
						length: compNum.value,
						pixels: ppdu * compNum.value,
						units: system.units[unitIndex],
						abbr: system.abbr[unitIndex],
						dec: compNum.dec 
					};
					score = compNum.score;
					tie = compNum.tie;
					break;
				}
			}
		}
	},
	
	/**
	 * Method: styleValue
	 * Get an integer value associated with a particular selector and key.
	 *	   Given a stylesheet with .displayClassSomeSelector {border: 2px solid red},
	 *	   styleValue('SomeSelector', 'borderWidth') returns 2
	 *
	 * Returns:
	 * {Integer} A value associated with a style selector/key combo.
	 */
	styleValue: function(selector, key) {
		var value = 0;
		if(this.limitedStyle) {
			value = this.appliedStyles[selector][key];
		} else {
			selector = "." + this.displayClass + selector;
			rules: 
			for(var i = document.styleSheets.length - 1; i >= 0; --i) {
				var sheet = document.styleSheets[i];
				if(!sheet.disabled) {
					var allRules;
					try {
						if(typeof(sheet.cssRules) == 'undefined') {
							if(typeof(sheet.rules) == 'undefined') {
								// can't get rules, keep looking
								continue;
							} else {
								allRules = sheet.rules;
							}
						} else {
							allRules = sheet.cssRules;
						}
					} catch(err) {
						continue;
					}
					if (allRules && allRules.length) {
						for(var ruleIndex = 0; ruleIndex < allRules.length; ++ruleIndex) {
							var rule = allRules[ruleIndex];
							if(rule.selectorText && (rule.selectorText.toLowerCase() == selector.toLowerCase())) {
								if(rule.style[key] != '') {
									value = parseInt(rule.style[key]);
									break rules;
								}
							}
						}
					}
				}
			}
		}
		// if the key was not found, the equivalent value is zero
		return value ? value : 0;
	},

	/**
	 * Method: getHandsomeNumber
	 * Attempts to generate a nice looking positive number between two other
	 *	   positive numbers.
	 *
	 * Parameters:
	 * small - {Float} Lower positive bound.
	 * big - {Float} Upper positive bound.
	 * sigFigs - {Integer} Number of significant figures to consider.  Default
	 *	   is 10.
	 *
	 * Returns:
	 * {Object} Object representing a nice looking number.
	 */
	getHandsomeNumber: function(small, big, sigFigs) {
		sigFigs = (sigFigs == null) ? 10 : sigFigs;
		// if all else fails, return a small ugly number
		var num = {
			value: small,
			score: Number.POSITIVE_INFINITY,
			tie: Number.POSITIVE_INFINITY,
			dec: 3
		};
		// try the first three comely multiplicands (in order of comliness)
		var cmult, max, dec, tmult, multiplier, score, tie;
		for(var hexp = 0; hexp < 3; ++hexp) {
			cmult = Math.pow(2, (-1 * hexp));
			max = Math.floor(Math.log(big / cmult) / Math.LN10);
			for(var texp = max; texp > (max - sigFigs + 1); --texp) {
				dec = Math.max(hexp - texp, 0);
				tmult = cmult * Math.pow(10, texp);
				// check if there is an integer multiple of tmult
				// between small and big
				if((tmult * Math.floor(big / tmult)) >= small) {
					// check if small is an integer multiple of tmult
					if(small % tmult == 0) {
						multiplier = small / tmult;
					} else {
						// smallest integer multiple between small and big
						multiplier = Math.floor(small / tmult) + 1;
					}
					// test against the best (lower == better)
					score = multiplier + (2 * hexp);
					tie = (texp < 0) ? (Math.abs(texp) + 1) : texp;
					if((score < num.score) || ((score == num.score) &&
					   (tie < num.tie))) {
						num.value = parseFloat((tmult * multiplier).toFixed(dec));
						num.score = score;
						num.tie = tie;
						num.dec = dec;
					}
				}
			}
		}
		return num;
	},
	
	CLASS_NAME: "OpenLayers.Control.ScaleBar"
	
});
/* ======================================================================
    SaigaiTask/Map/control/DrawLayerHistoryControl.js
   ====================================================================== */

/**
 * DrawLayer の地物の履歴を管理するクラスです.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.DrawLayerHistoryControl = new OpenLayers.Class(OpenLayers.Control, {

	/**
	 * @type {SaigaiTask.Map.Layer.DrawLayer}
	 */
	drawLayer: null,

	/**
	 * 履歴情報のスタック
	 * @type {Array<Object>}
	 */
	stack: null,

	/**
	 * undo, redo したときの履歴位置を保持する
	 * 空のときは -1 で、最新のときは配列最後のインデックスを指す
	 * @type {Number}
	 */
	stackIndex: null,

	/**
	 * true にセットすると履歴の記録をしない
	 * @type {Boolean}
	 */
	ignoreSave: null,

	initialize: function(drawLayer) {
		var me = this;
		me.drawLayer = drawLayer;
		me.clear();
		me.ignoreSave = true;

		// 描画レイヤのイベントで履歴を保存する
		var layer = drawLayer.layer;
		layer.events.on({
			"featureadded": function(evt) {
				if(!me.ignoreSave) {
					me.save({
						type: evt.type,
						operation: "add",
						feature: evt.feature
					});
				}
			},
			"featureremoved": function(evt) {
				if(!me.ignoreSave) {
					me.save({
						type: evt.type,
						operation: "remove",
						feature: evt.feature
					});
				}
			},
			"featuremodified": function(evt) {
				if(!me.ignoreSave) {
					me.save({
						type: evt.type,
						operation: "modify",
						feature: evt.feature,
						beforeFeature: evt.beforeFeature,
						afterFeature: evt.afterFeature
					});
				}
			},
			// feature moved は dragFeatureControl のイベントをカスタマイズしてある
			"featuremoved": function(evt) {
				if(!me.ignoreSave) {
					me.save({
						type: evt.type,
						operation: "modify",
						feature: evt.feature,
						beforeFeature: evt.beforeFeature,
						afterFeature: evt.afterFeature
					});
				}
			}
		});
	},


	/**
	 * 履歴の記録を開始
	 */
	startHistory: function() {
		this.ignoreSave = false;
	},
	/**
	 * 履歴の記録を停止
	 */
	stopHistory: function() {
		this.ignoreSave = true;
	},
	/**
	 * 履歴の記録をクリア
	 */
	clear: function() {
		var me = this;
		me.stack = [];
		me.stackIndex = me.stack.length-1;
		console.debug("clear: -1");
		me.drawLayer.layer.events.triggerEvent("historychange", {
			historyControl: me,
			operation: "clear"
		});
	},
	/**
	 * 履歴を記録する
	 * @param {Object} info
	 * @param {String} info.type イベントタイプ
	 * @param {String} info.operation 操作種別(add/remove/modify) (required)
	 * @param {OpenLayers.Feature.Vector} info.feature 操作対象のフィーチャ (required)
	 * @param {OpenLayers.Feature.Vector} info.beforeFeature 操作前のフィーチャ(状態保存用) modify の場合
	 * @param {OpenLayers.Feature.Vector} info.afterFeature 操作後のフィーチャ(状態保存用) modify の場合
	 */
	save: function(info) {
		var me = this;

		// 元に戻している場合は、それ以降の履歴を消す
		if(me.stackIndex!=me.stack.length-1) {
			if(0<me.stackIndex) me.stack = me.stack.slice(0, me.stackIndex+1);
			else me.stack = [];
		}

		// 履歴の記録
		me.stack.push(info);
		me.stackIndex = me.stack.length-1;
		console.debug("save: "+me.stackIndex);
		me.drawLayer.layer.events.triggerEvent("historychange", {
			historyControl: me,
			operation: "save"
		});
	},

	/**
	 * 1つ元に戻す
	 */
	undo: function() {
		var me = this;
		if(0<=me.stackIndex) {
			var undoIndex = me.stackIndex;
			var info = me.stack[undoIndex];
			var layer = me.drawLayer.layer;

			// 履歴の記録を停止
			me.stopHistory();

			// undo
			switch(info.operation) {
			case "add":
				// 追加されたものを削除
				layer.removeFeatures([info.feature]);
				break;
			case "remove":
				// 削除されたものを追加
				layer.addFeatures([info.feature]);
				break;
			case "modify":
				// 編集されたものを戻す
				// 一旦削除
				layer.removeFeatures([info.feature]);
				// ジオメトリ変更
				info.feature.geometry = info.beforeFeature.geometry.clone();
				// Style変更
				info.feature.style = $.extend({}, info.beforeFeature.style);
				// attributes変更
				info.feature.attributes = $.extend({}, info.beforeFeature.attributes);
				// 再度追加
				layer.addFeatures([info.feature]);
				break;
			}

			// 履歴の記録を開始
			me.startHistory();

			me.stackIndex--;
			console.debug("undo: "+me.stackIndex+"/"+(me.stack.length-1));
			me.drawLayer.layer.events.triggerEvent("historychange", {
				historyControl: me,
				operation: "undo",
				feature: info.feature
			});
			return true;
		}
		return false;
	},

	/**
	 * 1つやり直す
	 */
	redo: function() {
		var me = this;
		if(me.stackIndex<me.stack.length-1) {
			var redoIndex = me.stackIndex+1;
			var info = me.stack[redoIndex];
			var layer = me.drawLayer.layer;

			// 履歴の記録を停止
			me.stopHistory();

			// redo
			switch(info.operation) {
			case "add":
				// 追加をやり直し
				layer.addFeatures([info.feature]);
				break;
			case "remove":
				// 削除をやり直し
				layer.removeFeatures([info.feature]);
				break;
			case "modify":
				// 編集をやりなおし
				// 一旦削除
				layer.removeFeatures([info.feature]);
				// ジオメトリ変更
				info.feature.geometry = info.afterFeature.geometry.clone();
				// Style変更
				info.feature.style = $.extend({}, info.afterFeature.style);
				// attributes変更
				info.feature.attributes = $.extend({}, info.afterFeature.attributes);
				// 再度追加
				layer.addFeatures([info.feature]);
				break;
			}

			// 履歴の記録を開始
			me.startHistory();

			me.stackIndex++;
			console.debug("redo: "+me.stackIndex+"/"+(me.stack.length-1));
			me.drawLayer.layer.events.triggerEvent("historychange", {
				historyControl: me,
				operation: "redo",
				feature: info.feature
			});
			return true;
		}
		return false;
	}
});
/* ======================================================================
    SaigaiTask/Map/view/SpatialSearchResult.js
   ====================================================================== */


/**
 * 登録情報の空間検索の検索結果のビューです.
 * @class SaigaiTask.Map.view.SpatialSearchResult
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.SpatialSearchResult = function(){
	this.initialize.apply(this, arguments);
};

SaigaiTask.Map.view.SpatialSearchResult.prototype = {

	/**
	 * 検索結果のグリッド
	 * @type {Ext.grid.Panel}
	 */
	grid: null,

	/**
	 * グリッドのイベント
	 * @type {Object.<String, Boolean>}
	 */
	gridEvents: {
		popup: true
	},

	/**
	 * 表示件数のコンボボックス
	 * @type {Ext.form.field.ComboBox}
	 */
	limitCombo: null,

	/**
	 * ページングツールバー
	 * @type {Ext.toolbar.Paging}
	 */
	pagingTbar: null,

	/**
	 * ページングツールバーのイベント
	 * @type {Object.<String, Boolean>}
	 */
	pagingTbarEvents: {
		movefirst: true,
		movelast: true,
		movenext: true,
		moveprevious: true
	},

	/**
	 * 登録情報の空間検索の検索結果のパネルを取得します.
	 * @return {Ext.grid.Panel} 検索結果がなければ null
	 */
	initialize: function() {

		// グリッドを定義する
		var store = Ext.create("Ext.data.Store", {
			fields: [],
			data: []
		});
		var columns = [];

		// グリッドのページングツールバーを定義する
		var pagingTbar = null;
		pagingTbar = Ext.create('Ext.PagingToolbar', {
			store : store,
			displayInfo : true,
			displayMsg : lang.__('{0} - {1} / {2}items'),
			emptyMsg : lang.__("No match info."),
			moveFirst: function() {
				pagingTbar.fireEvent('movefirst');
			},
			moveLast: function() {
				pagingTbar.fireEvent('movelast');
			},
			moveNext: function() {
				pagingTbar.fireEvent('movenext');
			},
			movePrevious: function() {
				pagingTbar.fireEvent('moveprevious');
			}
		});
		pagingTbar.addEvents(this.pagingTbarEvents);

		var grid = null;
		grid = Ext.create("Ext.grid.Panel", {
			autoScroll: true,
			// 横スクロールを表示するにはscrollオプションをtrueまたは"both"に設定する.
			// しかし、マウスホイールの移動量scrollDeltaが効かなくなる.
			scroll: "vertical",
			scrollDelta: 400,
			store: store,
			columns: columns,
 			// paging bar on the bottom
			bbar: pagingTbar
		});
		grid.addEvents(this.gridEvents);

		// 表示件数のコンボボックスをツールバーに定義する
		var limitCombo = Ext.create("Ext.form.field.ComboBox", {
			name : 'limit',
			width : 80,
			allowBlank : false,
			store : new Ext.data.SimpleStore({
				data : [[
					10, lang.__('10 items')
				], [
					20, lang.__('20 items')
				], [
					30, lang.__('30 items')
				], [
					40, lang.__('40 items')
				], [
					50, lang.__('50 items')
				]],
				fields : ['limit', 'text']
			}),
			value : 20,
			valueField : 'limit',
			displayField : 'text',
			editable : false,
			listeners : {
				select : function(combo, records, eOps) {
					var limit = combo.value;
					store.pageSize = limit;
					store.load();
				}
			}
		});

		var tbar = Ext.create("Ext.toolbar.Toolbar", {
			items: [{
				xtype : 'label',
				text : lang.__('Item:<!--2-->'),
				margin : "0 5 0 5"
			}, limitCombo]
		});
		grid.addDocked(tbar);

		this.grid = grid;
		this.limitCombo = limitCombo;
		this.pagingTbar = pagingTbar;

		return grid;
	},

	/**
	 * グリッドを空にします.
	 */
	empty: function() {
		var me = this;
		var pagingTbar = me.pagingTbar;
		var store = pagingTbar.store;

		// 空のデータをロードする
		store.loadData([]);

		// ページ情報を空にする
		store.totalCount = 0;
		store.currentPage = 1;

		// ページングツールバーの表示を更新
		pagingTbar.onLoad();
	},

	/**
	 * 検索結果を読み込みます.
	 * @param {SaigaiTask.Map.model.SearchResult} searchResult
	 */
	load: function(searchResult) {
		var me = this;

		// 検索結果があるかチェックする
		var counts = searchResult.counts;
		var features = searchResult.features;
		if(counts.total==0 || features.length==0) {
			me.empty();
			return null;
		}

		// データストアを定義する
		var attrNames = features[0].getAttributeNames();
		var fields = [];
		for(var attrNamesIdx in attrNames) {
			fields.push(attrNamesIdx);
		}
		var data = [];
		for(var featuresIdx in features) {
			var feature = features[featuresIdx];
			var d = feature.getAttributeValues();
			d.feature = feature;
			data.push(d);
		}

		var store = Ext.create("Ext.data.Store", {
			fields: fields,
			data: data,
			pageSize: counts.limit
		});
		store.totalCount = counts.total;
		store.currentPage = counts.offset/counts.limit+1;

		var columns = [];
		for(var attrNamesIdx in attrNames) {
			var attrName = attrNames[attrNamesIdx];
			columns.push({
				text: attrName,
				dataIndex: attrNamesIdx,
				flex: 1
			});
		}

		// 地図のポップアップアイコンカラムを追加
		var grid = this.grid;
		columns.push({
			xtype:'actioncolumn',
			width: 25,
			items:[{
				getClass: function(v, meta, rec) {
					return 'map-icon pointer';
				},
				handler : function(grid, rowIndex, colIndex) {
					var rec = grid.getStore().getAt(rowIndex);
					var feature = rec.raw.feature;
					me.doPopup(feature.layerId, feature.featureId);
				}
			}]
		});

		grid.reconfigure(store, columns);
		var pagingTbar = this.pagingTbar;
		pagingTbar.store = store;
		pagingTbar.onLoad();
	},

	/**
	 * 登録情報の空間検索の検索結果のウィンドウを表示します.
	 * @param {SaigaiTask.Map.model.SearchResult} searchResult
	 */
	show: function(searchResult) {
		var grid = this.get(searchResult);
		if(grid) {
			// ウィンドウを定義する
			var win = Ext.create("Ext.window.Window", {
				title: lang.__('Search result'),
				layout: 'fit',
				items: [grid]
			});

			win.show();
		}
	},

	/**
	 * ポップアップイベントを起動します.
	 * @param {String} layerId レイヤID
	 * @param {Number} featureId フィーチャID
	 */
	doPopup: function(layerId, featureId) {
		this.grid.fireEvent('popup', layerId, featureId);
	}
};
/* ======================================================================
    SaigaiTask/Map/Layer/Group.js
   ====================================================================== */

/**
 * レイヤグループ
 * @requires SaigaiTask/Map/Layer.js
 * @requires SaigaiTask/Map/Layer/Type.js
 */
SaigaiTask.Map.Layer.Group = new OpenLayers.Class({

	/**
	 * レイヤ情報
	 * @type {SaigaiTask.Map.Layer.LayerInfo}
	 */
	layerInfo: null,

	/**
	 *
	 * @param {SaigaiTask.Map.Layer.LayerInfo} layerInfo レイヤ情報
	 */
	initialize: function(layerInfo) {

		// 引数を処理
		var me = this;
		me.layerInfo = layerInfo;

		// レイヤはなし
		layerInfo.layer = null;
	}
});

SaigaiTask.Map.Layer.Group.type = SaigaiTask.Map.Layer.Type.GROUP;
/* ======================================================================
    OpenLayers/RendererPatch.js
   ====================================================================== */

/* Copyright (c) 2009 National Research Institute for Earth Science and
 * Disaster Prevention (NIED).
 * This code is licensed under the GPL version 3 license, available at the root
 * application directory.
 */
////////////////////////////////////////////////////////////////
//	Rendrerer Polygon Label
////////////////////////////////////////////////////////////////
OpenLayers.Renderer.prototype.drawFeature = function(feature, style)
{
	try {
	if (style == null) {
		style = feature.style;
		if (style == null) style = {};
	}
	if (feature.geometry) {
		var res = this.getResolution();
		//メモ描画読み込み時にテキストはstyle.memoが設定される
		if (style.memo && style.label) {
			//<span class="ja">メモ描画の場合のみ先に背景描画</span><span class="en">Only for memo drawing, draw the background before the memo</span>
			
			var point;
			var rate = 1;
			//descriptionをoptionにオブジェクトとして格納
			//if (!feature.attributes.option) {
				try {
					feature.attributes.option = dojo.fromJson(feature.attributes.description);
				} catch (e) {
					feature.attributes.option = {};
				}
			//}
			var option = feature.attributes.option;
			//表示解像度に合せて枠と文字サイズ変更
			if (option.reso) {
				rate = option.reso/res;
			}
			var offsetX = 0;
			var offsetY = 0;
			//TODO アンカーの指定に合せてオフセット
			if (option.anchor) {
				
			}
			var rendered = false;
			var padding = (parseInt(feature.style.strokeWidth)/2+2)*res*rate;
			point = feature.geometry.getCentroid();
			if (style.fillColor) {
				//<span class="ja">枠のbgRectは削除用にfeatureのメンバに格納しておく</span><span class="en">Store feature's member for deletion</span>
				var x = point.x;
				var y = point.y;
				var w = style.graphicWidth*res*rate +padding*2;
				var h = style.graphicHeight*res*rate;
				if (feature.bgRect) {
					var points = feature.bgRect.components[0].components;
					points[0].x = x; points[0].y = y;
					points[1].x = x+w; points[1].y = y;
					points[2].x = x+w; points[2].y = y-h;
					points[3].x = x; points[3].y = y-h;
					points[4].x = x; points[4].y = y;
				}
				else {
					feature.bgRect = new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing(
						[new OpenLayers.Geometry.Point(x, y),
						new OpenLayers.Geometry.Point(x+w, y),
						new OpenLayers.Geometry.Point(x+w, y-h),
						new OpenLayers.Geometry.Point(x, y-h),
						new OpenLayers.Geometry.Point(x, y)])]);
				}
				rendered = this.drawGeometry(feature.bgRect, style, feature.id);
			} else {
				//<span class="ja">背景削除</span><span class="en">Delete the background</span>
				if (feature.bgRect) {
					this.eraseGeometry(feature.bgRect);
					feature.bgRect = null;
				}
			}
			
			if (rendered !== false) {
				//<span class="ja">テキスト改行対応</span><span class="en">Support text breakline</span>
				//<span class="ja">描画時に行毎の文字列を設定するので待避</span><span class="en">Backup because string is set for each line while drawing</span>
				var labelBak = style.label;
				//<span class="ja">"\n"の文字は強制改行</span><span class="en">Use "\n" as breakline enforcement</span>
				var lines = style.label.split("\\n");
				
				var orgFontSize = style.fontSize;
				style.fontSize = (parseFloat(style.fontSize) || 14) * rate; //pxがついている場合があるのでparseFloatで除去
				style.label = lines[0];
				//文字位置調整 IE対応 
				// 官民修正：Edgeの場合に文字が上にずれるのでIE用の文字調整が効くようにした
				if (/Edge/.test(navigator.userAgent) || (dojo.isIE >= 9 && document.documentMode >= 9)) point.move(0, -style.fontSize*res*1.08);
				else if (dojo.isChrome >= 50) point.move(0, -style.fontSize*res*0.3);
				
				point.move(padding, 0);
				this.drawText(feature.id, style, point);
				//<span class="ja">２行目以降は独自ID</span><span class="en">From the 2nd line, ID is independent</span>
				for (var i=1; i<lines.length; i++) {
					style.label = lines[i];
					point.move(0, -style.fontSize*res * 1.05 ); //105%
					this.drawText(feature.id+"_"+i, style, point);
				}
				//<span class="ja">待避した文字列に戻す</span><span class="en">Restore the backup string</span>
				style.label = labelBak;
				//フォントサイズ戻す
				style.fontSize = orgFontSize;
			} else {
				this.removeText(feature.id);
				//<span class="ja">背景削除</span><span class="en">Delete background</span>
				if (feature.bgRect) {
					this.eraseGeometry(feature.bgRect);
					feature.bgRect = null;
				}
				//<span class="ja">テキスト改行対応</span><span class="en">Support text breakline</span>
				if (feature.style && feature.style.label) {
					var label = feature.style.label;
					var lineCount = 1;
					var start = -1;
					while ((start = label.indexOf("\\n", start+1)) != -1) { lineCount++; }
					for (var j=1; j<lineCount; j++) { this.removeText(feature.id+"_"+j); }
				}
			}
			return rendered;
			
		} else {
			//文字以外の出力
			var bounds = feature.geometry.getBounds();
			if(bounds) {
				var worldBounds;
				if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
					worldBounds = this.map.getMaxExtent();
				}
				//画像の場合は幅高さ分広げる
				if (style.graphicWidth) {
					bounds.left -= style.graphicWidth*res/2;
					bounds.right += style.graphicWidth*res/2;
				}
				if (style.graphicHeight) {
					bounds.bottom -= style.graphicHeight*res/2;
					bounds.top += style.graphicHeight*res/2;
				}
				
				if (!bounds.intersectsBounds(this.extent, {worldBounds: worldBounds})) {
					style = {display: "none"};
				} else {
					this.calculateFeatureDx(bounds, worldBounds);
				}
				var rendered = this.drawGeometry(feature.geometry, style, feature.id);
				if(style.display != "none" && style.label && rendered !== false) {
					var location = feature.geometry.getCentroid(); 
					if(style.labelXOffset || style.labelYOffset) {
						var xOffset = isNaN(style.labelXOffset) ? 0 : style.labelXOffset;
						var yOffset = isNaN(style.labelYOffset) ? 0 : style.labelYOffset;
						var res = this.getResolution();
						location.move(xOffset*res, yOffset*res);
					}
					this.drawText(feature.id, style, location);
				} else {
					this.removeText(feature.id);
				}
				return rendered;
			}
		}
	}
	
	} catch (e) { console.error(e); }
};
OpenLayers.Renderer.SVG.prototype.drawFeature = OpenLayers.Renderer.prototype.drawFeature;
OpenLayers.Renderer.VML.prototype.drawFeature = OpenLayers.Renderer.prototype.drawFeature;

OpenLayers.Renderer.prototype.eraseFeatures = function(features)
{
	if(!(features instanceof Array)) {
		features = [features];
	}
	var len=features.length;
	for(var i=0; i<len; ++i) {
		var feature = features[i];
		this.eraseGeometry(feature.geometry);
		this.removeText(feature.id);
		//Modified Start
		//<span class="ja">背景削除</span><span class="en">Delete background</span>
		if (feature.bgRect) {
			this.eraseGeometry(feature.bgRect);
			feature.bgRect = null;
		}
		//<span class="ja">テキスト改行対応</span><span class="en">Support text breakline</span>
		if (feature.style && feature.style.label) {
			var label = feature.style.label;
			var lineCount = 1;
			var start = -1;
			while ((start = label.indexOf("\\n", start+1)) != -1) { lineCount++; }
			for (var j=1; j<lineCount; j++) { this.removeText(feature.id+"_"+j); }
		}
		//Modified End
	}
};
OpenLayers.Renderer.SVG.prototype.eraseFeatures = OpenLayers.Renderer.prototype.eraseFeatures;
OpenLayers.Renderer.VML.prototype.eraseFeatures = OpenLayers.Renderer.prototype.eraseFeatures;
/* ======================================================================
    SaigaiTask/Map/view/ContentsFormPanel.js
   ====================================================================== */

/**
 * @require SaigaiTask/Map/view.js
 * @returns {SaigaiTask.Map.view.CotnentsFormPanel}
 */
SaigaiTask.Map.view.ContentsFormPanel = function() {
	this.initialize.apply(this, arguments);
};

SaigaiTask.Map.view.ContentsFormPanel.prototype = {

	/**
	 * 地図
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * サブミット時に付加するパラメータ
	 * @type {Object}
	 */
	params: null,

	/**
	 * 属性情報JSON
	 * @type {Object}
	 */
	json: null,

	/**
	 * レイヤ情報
	 */
	layerInfo: null,

	/**
	 * 描画フィーチャ
	 */
	feature: null,

	/**
	 * 属性フォームパネル
	 * @type {Ext.Form.Panel}
	 */
	formPanel: null,

	/** 更新フラグ(登録時はfalse) */
	update: false,

	/**
	 * 登録情報ファイルフォームパネル
	 * @type {SaigaiTask.Map.view.ContentsFileFormPanel}
	 */
	contentsFileFormPanel: null,

	/**
	 * 登録情報登録ウィンドウを表示します.
	 * @param layerId レイヤID
	 * @param feature 描画フィーチャ(ジオメトリ)
	 * @param fid 描画フィーチャ
	 * @param content 登録情報
	 */
	initialize: function(stmap, layerId, feature, fid, content) {

		var me = this;
		me.stmap = stmap;
		me.feature = feature;

		// 属性情報を取得します.
		var json = me.json = stmap.api.getAttrInfos(layerId);
		var attrInfos = json.attrInfos;

		// 登録情報から属性値リストを作成
		var attrValues = {};
		if(content!=null) {
			var attrs = content.attrs;
			for(var idx in attrs) {
				var attr = attrs[idx];
				attrValues[attr.attrId] = attr.attrValue;
			}
		}

		// フォームのアイテム
		var items = [];

		// サブミット時に付けるパラメータ
		var params = me.params = {};

		// レイヤ情報
		var layerInfo = me.layerInfo = stmap.getLayerInfo(layerId);
		params.layer = layerInfo.layerId;

		// 地図情報
		var mid = layerInfo.ecommap.mapInfo.mapId;
		params.mid = mid;

		var update = false; // true: 更新, false: 登録
		// 更新時の場合はフィーチャIDを指定
		if(typeof fid!="undefined" && fid!=null) {
			params.fid = fid;
			update = true;
		}
		me.update = update;

		if(SaigaiTask.PageURL.params.drawGeometry != true){
			// 属性フォームを生成
			if(attrInfos) {
				var attrItems = [];
				var attrIds = params.attrIds = [];
				var attrInfoMap = {};
				for(var key in attrInfos) {
					var attrInfo = attrInfos[key];
					var attrId = attrInfo.attrId;
					attrInfoMap[attrId] = attrInfo;

					// assert
					if(!attrId) continue;

					var layerAttrInfo = layerInfo.getAttrInfo(attrId);

					var visible = layerInfo.isVisibleAttr(attrId);
					var editable = layerInfo.isEditableAttr(attrId);
					var highlight = layerAttrInfo!=null ? layerAttrInfo.highlight : false;
					if(update==false) {
//						// 登録処理の場合は必須項目は閲覧・編集権限に関係なく入力させる
//						if(attrInfo.nullable==false) {
//						visible = editable = true;
//						}
						// 登録処理の場合はすべて入力可。
						editable = true;
						// 登録処理の場合は強調表示しない
						highlight = false;
					}
					// TODO: 閲覧不可の場合は折り畳みの状態で出す？

					if(visible) {
						// 属性値を取得
						if(typeof attrValues!="undefined" && attrValues!=null) {
							var attrValue = attrValues[attrId];
							if(typeof attrValue!="undefined") {
								attrInfo.value = attrValue;
							}
						}

						// 属性名に別名があれば設定する
						if(layerAttrInfo!=null && !!layerAttrInfo.name) attrInfo.name = layerAttrInfo.name;
						// 住所ボタンフラグがあれば設定する
						if(layerAttrInfo!=null && !!layerAttrInfo.addAddressButton) attrInfo.addAddressButton = true;
						// 属性アイテムを追加
						var item = me.createFormItem(attrInfo, editable, highlight);
						attrItems.push(item);

						// 登録・更新対象の属性IDを保存（編集可のみ）
						if(editable) {
							attrIds.push(attrId);
						}
					}
				}
				// disporder順でソート
				attrItems.sort(function(attrItem1, attrItem2) {
					var attrId1 = attrItem1.name;
					var attrId2 = attrItem2.name;
					return layerInfo.evalAttrSort(attrId1, attrId2);
				});
//				// 登録処理の場合は必須を上に持ってくる
//				if(update==false) {
//				attrItems.sort(function(attrItem1, attrItem2) {
//				var attrId1 = attrItem1.name;
//				var attrId2 = attrItem2.name;
//				var attrInfo1 = attrInfoMap[attrId1];
//				var attrInfo2 = attrInfoMap[attrId2];
//				if(attrInfo1.nullable==attrInfo2.nullable) return 0;
//				else if(attrInfo1.nullable==false) return -1;
//				else return 1;
//				});
//				}
				if(0<attrItems.length) {
					// 属性入力フィールドセットを追加
					items.push({
						xtype: 'fieldset',
						title: lang.__('Attribute'),
						layout: 'anchor',
						defaults: {
							anchor: '100%'
						},
						collapsible: true,
						items: attrItems
					});
				}
			}

			// 添付ファイルフォームを生成
			var contentsFileFormPanel = me.contentsFileFormPanel = new SaigaiTask.Map.view.ContentsFileFormPanel(stmap, content, {
				mid: mid,
				layerId: layerId,
				fid: fid,
				editable: true
			});

			// 添付ファイルフォームを追加
			items.push({
				xtype: 'fieldset',
				title: lang.__('Attachment<!--2-->'),
				layout: 'anchor',
				defaults: {
					anchor: '100%'
				},
				collapsible: true,
				items: contentsFileFormPanel.getFieldSetItems()
			});
		}

		// フォームを定義
		Ext.define('Fal.form.Panel', {
			extend: 'Ext.form.Panel',
			/** 必須のフィールドに赤色のアスタリスクを付けるフラグ */
			markupRequired: false,
			initComponent: function() {
				// 必須のフィールドに赤色のアスタリスクを付ける
				this.on('beforeadd', function(me, field){
					var fields = [];
					if(field.xtype=='fieldset'){
						fields = field.items.items;
					}
					else {
						fields.push(field);
					}

					for(var key in fields) {
						var f = fields[key];
						if (!f.allowBlank&&me.markupRequired) {
							f.labelSeparator += '<span style="color: rgb(255, 0, 0); padding-left: 2px;">*</span>';
						}
					}
				});
				this.callParent(arguments);
			}
		});

		// フォームを生成
		var formPanel = this.formPanel = Ext.create('Fal.form.Panel', {
			autoScroll: true,
			title: attrInfos.layerName,
			border: false,
			fieldDefaults: {
				labelWidth: 100,
				anchor: '100%'
			},
			url: update ? stmap.api.url.contentsUpdateURL : stmap.api.url.contentsCreateURL, //stmap.saigaitaskServer+'/contents/create/',
			markupRequired: true,
			defaultType: 'textfield',
			bodyPadding: 5,
			items: items
		});
	},

	/**
	 * 属性情報から入力フォームを生成します.
	 * @param attrInfo 属性情報
	 * @param editable 編集フラグ
	 * @param highlight 強調表示フラグ
	 * @returns {Object} 入力フォームアイテム情報
	 */
	createFormItem: function(attrInfo, editable, highlight) {
		var me = this;

		// 属性の基本情報の設定
		var value = null;
		if(typeof attrInfo.value!="undefined") {
			value = attrInfo.value;
		}
		var item = {
			fieldLabel: attrInfo.name,
			name: attrInfo.attrId,
			value: value,
			allowBlank: attrInfo.nullable
		};
		// ハイライト
		if(typeof highlight=="undefined") {
			highlight = false;
		}
		if(highlight) {
			jQuery.extend(item, {
				border: 2,
				style: {
					borderColor: 'red',
					borderStyle: 'solid'
				}
			});
		}
		// 編集不可は表示のみ
		if(editable==false) {
			item.xtype = 'displayfield';
			return item;
		}
		// 属性の型の設定
		switch(attrInfo.dataTypeId) {
		// 文字
		case 'text':
			var fieldClass = attrInfo.length<=20 ? "Ext.form.field.Text" : "Ext.form.field.TextArea";

			// フィールドコンテナを定義
			item.xtype = 'fieldcontainer';
			item.combineErrors = true;
			item.msgTarget = 'side';
			item.layout = {
				type: "hbox",
				align: "stretch"
			};
			item.defaults = {
				hideLabel: true
			};
			item.items = [];

			// フィールドを追加
			var textField = Ext.create(fieldClass, {
				name: item.name,
				value: item.value,
				allowBlank: item.allowBlank,
				flex: 1
			});
			item.items.push(textField);

			// 住所ボタンを追加
			if(attrInfo.addAddressButton) {
				var addressButton = Ext.create("Ext.button.Button", {
					xtype: "button",
					width: 40,
					text: lang.__("Address"),
					handler: (function(textField) {
						return function() {
							me.formPanel.fireEvent("clickaddressbtn", {
								addressBtn: this,
								textField: textField
							});
						};
					})(textField)
				});
				item.items.push(addressButton);
			}
			break;
		// 数値（整数）
		case 'integer':
			item.xtype = 'numberfield';
			item.allowDecimals = false;
			break;
		// 数値
		case 'float':
			item.xtype = 'numberfield';
			break;
		// 日付のみ
		case 'date':
			item.xtype = 'datefield';
			item.format = 'Y/m/d';
			//item.emptyText = 'yyyy/mm/dd';
			item.selectOnFocus = true;
			//item.editable = false;
			break;
		// 時間のみ
		case 'time':
			item.xtype = 'timefield';
			item.format = item.submitFormat = 'H:i:s';
			item.selectOnFocus = true;
			//item.editable = false;
			item.increment = 10;
			break;
		// 日時
		case 'datetime':
			item.xtype = 'fieldcontainer';
			item.combineErrors = true;
			item.msgTarget = 'side';
			item.layout = 'fit';
			item.defaults = {
				flex: 1,
				hideLabel: true
			};
			item.items = [];
			var dateValue = null;
			var timeValue = null;
			if(attrInfo.value!=null) {
				var datetime = attrInfo.value.split(" ");
				for(var idx in datetime) {
					var val = datetime[idx];
					// 日付チェック
					if(val.match(/^\d{4}\/\d{2}\/\d{2}$/)) {
						dateValue = val;
					}
					// 時刻チェック
					if(val.match(/^\d{2}:\d{2}:\d{2}$/)) {
						timeValue = val;
					}
				}
			}
			// 日付
			var dateAttrInfo = Ext.clone(attrInfo);
			dateAttrInfo.dataTypeId = "date";
			dateAttrInfo.value = dateValue;
			var dateItem = this.createFormItem(dateAttrInfo, editable, false);
			dateItem.border = 0; // ハイライトのキャンセル
			item.items.push(dateItem);
			// 時間
			var timeAttrInfo = Ext.clone(attrInfo);
			timeAttrInfo.dataTypeId = "time";
			timeAttrInfo.value = timeValue;
			var timeItem = this.createFormItem(timeAttrInfo, editable, false);
			timeItem.border = 0; // ハイライトのキャンセル
			item.items.push(timeItem);
			break;
		case 'select':
			item.xtype = 'combo';
			var data = [];
			// JSONArray 文字列かどうか
			var jsonDataExps = null;
			try {jsonDataExps=jQuery.parseJSON(attrInfo.dataExp)} catch(e){/* do nothing */}
			if(jsonDataExps!=null) {
				for(var jsonDataExpsIdx in jsonDataExps) {
					var jsonDataExp = jsonDataExps[jsonDataExpsIdx];
					for(var key in jsonDataExp) {
						var val = jsonDataExp[key];
						data.push([key, val]);
					}
				}
			}
			else {
				// カンマ区切り
				var dataExps = attrInfo.dataExp.split(',');
				for(var dataExpsKey in dataExps) {
					var dataExp = dataExps[dataExpsKey];
					data.push([dataExp, dataExp]);
				}
			}
			if(item.allowBlank) {
				data.push(['', '　']);
			}
			else {
				// TODO: "null"が入ってしまうことがあるようなので修正する
				// 空欄不可かつ値がなかったらリストの最初を選択しておく
				if(typeof item.value=="undefined" || item.value==null || item.value=="") {
					if(0<data.length) {
						item.value = data[0][0];
					}
				}
			}
			item.store = new Ext.data.SimpleStore({
				fields: ['value', 'display'],
				data: data,
				autoLoad: false
			});
			item.displayField = 'display';
			item.valueField = 'value';
			item.editable = false; // 自由入力不可
			item.selectOnFocus = true;
			break;
		case 'checkbox':
			if(item.value == true) item.value = "○";
			item.xtype = 'checkbox';
			item.inputValue = attrInfo.dataExp;
			item.checked = item.value==item.inputValue;
			break;
		default:
			item.xtype = 'textfield';
		}
		return item;
	},

	/**
	 * 登録・更新をリクエストします.
	 * @param {Object} optionParams 指定パラメータ
	 */
	submit: function(optionParams) {
		var me = this;
		var stmap = me.stmap;
		var params = me.params;
		var formPanel = me.formPanel;
		var form = formPanel.form;
		var layerInfo = me.layerInfo;

		// マスク
		var loadMask = new Ext.LoadMask(formPanel, {msg: lang.__("Now saving..<!--2-->")});
		loadMask.show();

		// WKTを取得する
		if(me.feature!=null) {
			params.wkt = stmap.getWKT(me.feature);
		}

		// 属性値を追加
		var formValues = form.getValues();
		for(var name in formValues) {
			// 配列のパラメータはスペースで文字列を連結する
			var formValue = formValues[name];
			if(Ext.isArray(formValue)) {
				formValues[name] = formValue.join(" ");
			}
			params[name] = formValues[name];
		}

		// ファイルのパラメータを追加
		params.fileList = JSON.stringify(me.contentsFileFormPanel.getJSONArray());

		// 登録/更新時に現在時刻を設定する
		var attrInfos = layerInfo.attrInfos;
		for(var idx in attrInfos) {
			var attrInfo = attrInfos[idx];
			var attrId = attrInfo.attrId;
			if( // 登録時にアップデート
				(me.update==false && attrInfo.updateInserted)
				// 更新時にアップデート
				|| (me.update && attrInfo.updateModified) ) {
				var val = null;
				switch(attrInfo.dataTypeId) {
				case 'date':
				case 'time':
				case 'datetime':
				case 'text':
					val = Ext.Date.format(new Date(), "Y/m/d H:i:s");
					break;
				case 'integer':
				case 'float':
				case 'select':
				case 'checkbox':
				default:
					// do nothing
				}
				if(val!=null) {
					params[attrId] = val;
					params.attrIds.push(attrId);
				}
			}
		}

		// 引数に指定パラメータを指定した場合はそのパラメータをマージする
		OpenLayers.Util.extend(params, optionParams);

		// 登録情報の登録処理を送信する
		params._csrf = SaigaiTask.ajaxcsrfToken;
		Ext.Ajax.request({
			url: form.url,
			params: params,
			success: function(response, options) {
				var result = JSON.parse(response.responseText);
				if(result.success) {
					stmap.events.triggerEvent(stmap.EventType.successcontentssubmit, {
						contentsFormPanel: me
					});
					var layer = layerInfo.getLayer();
					if(layer!=null) {
						if(typeof layer.refreshParams=="function") {
							return layer.refreshParams({
								nocache: true
							});
						}
					}
					stmap.redrawContentsLayer(0);
				}
				else {
					alert("ERROR:"+result.msg);
				}

				if(SaigaiTask.PageURL.params.oninsertFeature.match("redirecturl:")){
					var oninsertFeature = SaigaiTask.PageURL.params.oninsertFeature
					var url = oninsertFeature.slice(oninsertFeature.indexOf(":")+1);
					if(confirm(lang.__("Move to {0}", url))){
						location.href=url;
					}
				}else if(SaigaiTask.PageURL.params.oninsertFeature.match("close")){
					// windowcloseの前にalertを挟まないと登録失敗する
					// 原因追及の必要あり
					//alert("windowを閉じます");
					window.open('about:blank','_self').close()
				}
			},
			failure: function() {
				alert(lang.__("Registration not completed."));
			},
			callback: function() {
				loadMask.hide();
			}
		});
	}

};
/* ======================================================================
    OpenLayers/Format/KMLStyleUtil.js
   ====================================================================== */

/* Copyright (c) 2009 National Research Institute for Earth Science and
 * Disaster Prevention (NIED).
 * This code is licensed under the GPL version 3 license, available at the root
 * application directory.
 */
OpenLayers.Format.KMLStyleUtil = {
	parseTextMemo: function(kmlFormat, node, style) {
		var self = this;
		
		// labelがあるかチェック
		var label = null;
		var list = node.parentNode.children;
		if(typeof list=="undefined") list = node.parentNode.childNodes;
		for(var idx in list) {
			if(list[idx].nodeName=="name") {
				//label = list[idx].innerHTML;
				label = list[idx].textContent;
				break;
			}
		}

		// ラベルがあればメモ描画モード
		if(label!=null) {
			style.label=label;

			// @see eMapBase.js #addMemoKMLFeatures : function(data, created)
			
			// メモ描画フラグ
			style.memo = true; //メモFeatureフラグ設定
			style.cursor = "pointer";

			style.fontWeight = "bold";
			style.labelAlign = "lt";

			//<span class="ja">メモ描画のテキストの場合</span><span class="en">In case of text of memo drawing</span>
			if (style.label) {
				var fontSize = parseInt(style.fontSize);
				if (!fontSize) try { style.fontSize.replace(/px$/,""); } catch (e) {};
				if (!fontSize) kmlFormat.FONTSIZE;
				var size = self.getLabelSize(style.label.replace(/\\n/g, "<br/>"), fontSize, style.fontWeight);
				style.graphicWidth = size.w;
				style.graphicHeight = size.h;
			}
		}
	},
	/**
	 * @see eMapBase.js #getLabelSize
	 */
	getLabelSize : function(label, fontSize, fontWeight)
	{
		var size = {w:100, h:fontSize};
		try { //<span class="ja">幅高さ取得</span><span class="en">Get width and height</span>
			var span = document.createElement("span");
			span.style.position = "absolute";
			span.style.lineHeight = "105%";
			span.style.padding = "0.15em";
			span.style.margin = 0;
			span.style.fontSize = fontSize+"px";
			span.style.fontWeight = fontWeight;
			span.innerHTML = label;

			// 官民修正：document.bodyだとCSSが違うため、Map表示領域でサイズを測るようにする
			var dest = document.body;
			var elems = document.getElementsByClassName("olMap");
			if(0<elems.length) dest = elems[0];

			dest.appendChild(span);
			size.w = span.offsetWidth;
			size.h = span.offsetHeight;
			dest.removeChild(span);

		} catch (e) {}
		return size;
	}
};

/* ======================================================================
    SaigaiTask/Map/view/RakugakiWindow.js
   ====================================================================== */

/**
 * メモ編集ウィンドウ
 * @require SaigaiTask/Map/view.js
 * @returns {SaigaiTask.Map.view.ContentsFormWindow}
 */
SaigaiTask.Map.view.RakugakiWindow = function() {
	this.initialize.apply(this, arguments);
};

SaigaiTask.Map.view.RakugakiWindow.prototype = {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * @type {SaigaiTask.Map.control.RakugakiControl}
	 */
	rakugakiControl: null,

	/**
	 * @type {Ext.window.Window}
	 */
	window: null,

	/**
	 * @type {SaigaiTask.Map.view.DrawToolbar}
	 */
	drawToolbar: null,

	/**
	 * メモ編集ウィンドウを表示します.
	 * @param option.stmap 地図オブジェクト
	 * @param option.layerInfo レイヤ情報
	 * @param option.lonlat 経緯度(地図の投影法で)
	 * @param option.fid フィーチャID(更新時の場合指定)
	 * @param option.feature フィーチャ(EPSG:4326)(更新時の場合指定)
	 * @param option.content 登録情報(更新時の場合指定)
	 * @param option.drawGeometryOnly ジオメトリ描画モード（描画のみで登録処理しない）
	 */
	initialize: function(option) {
		var me = this;
		me.stmap = option.stmap;
		me.rakugakiControl = option.rakugakiControl;

		me.initDrawToolbar();
	},
	
	/**
	 * 描画用ツールバーを初期化する
	 */
	initDrawToolbar: function() {
		var me = this;
		var stmap = me.stmap;

		// 描画ツールバーを２段目に表示する
		var headerToolbar = null;
		if(!!me.headerToolbar) {
			headerToolbar = me.headerToolbar;
		}
		else {
			// メモ描画用ツールバーを新規作成
			// ヘッダツルーバー下に非表示状態で追加する
			headerToolbar = me.headerToolbar = {};
			var headerTbar = Ext.create("Ext.toolbar.Toolbar", {
				docked: "top",
				align: "right"
				//items: headerTbarItems
			});
			headerToolbar.tbar = headerTbar;
			headerTbar.hide();

			// メインパネルにツールバー追加
			var headerToolbar = me.headerToolbar;
			map.components.mainpanel.mapPanel.panel.addDocked(headerToolbar.tbar);
		}

		// 描画ツールバーを初期化
		var drawToolbar = me.drawToolbar = new SaigaiTask.Map.view.DrawToolbar(map, {
			init: false,
			//geomType: "MULTILINESTRING",
			//drawPoint: true,
			//drawPolygon: true,
			//drawLine: true,
			drawFreeLine: true,
			drawText: true,
			// 線の色
			strokeColor: true,
			// 線の太さ
			strokeWidth: true,
			fillColor: true,
			fontColor: true,
			fontSize: true,
			modifyFeature: false,
			dragFeature: false,
			selectFeature: false,
			selectDragFeature: true,
			selectRangeFeature: true,
			removeSelectedFeature: true,
			removeFeature: true,
			// 操作を元に戻す
			undo: true,
			// 操作をやり直す
			redo: true,
			maxDrawNum: Number.MAX_VALUE
		});

		// snap無効
		drawToolbar.drawLayer.snapControl.snap.deactivate();

		// 描画ツールバーを地図画面のヘッダーに追加
		//drawToolbar.tbar.hide();
		//headerToolbar.tbar.add(drawToolbar.tbar);
	},

	initEditWindow: function() {
		var me = this;
		var stmap = me.stmap;
		var drawToolbar = me.drawToolbar;

		// Toolbar
		var dockedItems = [];
		{
			var toolbarLayouts = [
				["drawFreeLine", "strokeColor", "strokeWidth"],
				["drawText", "fontColor", "fontSize", "fillColor"],
				["selectDragFeature", "selectRangeFeature", "removeSelectedFeature", "removeFeature", "undo", "redo"]
			];
			
			for(var toolbarLayoutsIdx in toolbarLayouts) {
				var toolbarItems = [];
				var drawToolbarTypes = toolbarLayouts[toolbarLayoutsIdx];
				for(var key in drawToolbarTypes) {
					var drawToolbarType = drawToolbarTypes[key];
					
					if(drawToolbarType=="-") {
						toolbarItems.push("-");
						continue;
					}
					
					// find
					var tbarItems = drawToolbar.tbarItems;
					for(var idx in tbarItems) {
						var item = tbarItems[idx];
						// 区切り文字の場合
						if(item=="-") continue;
						else {
							if(item.drawToolbarType==drawToolbarType) {
								toolbarItems.push(item);
								break;
							}
						}
					}
				}

				dockedItems.push({
					xtype: "toolbar",
					dock: "top",
					items: toolbarItems
				});
			}
		}

		// フォームのウィンドウを生成
		var win = null;
		win = me.window = Ext.create('Ext.window.Window', {
			title: lang.__("Memo")+lang.__("Edit"),
			width: 420, //height: 600,
			maxWidth: document.body.clientWidth,
			maxHeight: document.body.clientHeight,
			collapsible: true,
			//tbar: tbar,
			dockedItems: dockedItems,
			layout: 'fit',
			//items: drawGeometryOnly ? null : formPanel,
			closeAction: 'hide',
			buttons: [{
				text: lang.__('Registration'),
				textAlign: "left",
				icon: stmap.icon.getURL("editIconURL"),
				handler: function(){
					me.rakugakiControl.save();
				}
			}, {
				text: lang.__('Cancel'),
				handler: function(){
					//me.rakugakiControl.cancel();
					win.close();
				}
			}],
			listeners: {
				hide: function() {
					me.rakugakiControl.cancel();
				}
			}
		});
	},

	showEditWindow: function() {
		var me = this;
		var stmap = me.stmap;

		var win = me.window;
		if(!win) {
			me.initEditWindow();
			win = me.window;
		}
		
		// ウィンドウ表示
		win.show();
		// 右上に表示
		//win.alignTo(document, "tr", [-win.getWidth(), 0]);
		// トップ中央に表示
		win.alignTo(document, "t", [-win.getWidth()/2, 0]);
		// 初期状態は選択ボタンにする
		me.drawToolbar.buttons.selectDragFeatureButton.toggle(true);
		me.drawToolbar.drawLayer.setSelectDragFeatureControlActivation(true);
	}
}
/* ======================================================================
    SaigaiTask/Map/view/RefContentsPopup.js
   ====================================================================== */

/**
 * 主題図のフィーチャポップアップ
 * @class SaigaiTask.Map.view.RefContentsPopup
 * @requires SaigaiTask/Map/view/ContentsPopup.js
 */
SaigaiTask.Map.view.RefContentsPopup = new OpenLayers.Class(SaigaiTask.Map.view.ContentsPopup, {

	stmap: null,

	debug: false,

	/**
	 * @type {OpenLayers.Format.GML}
	 */
	gmlFormat: null,

	// 引数
	center: null,
	bbox: null,

	/** 検索ステータス */
	requests: null,

	listPopup: null,

	initialize: function(stmap) {
		this.stmap = stmap;
		this.gmlFormat = new OpenLayers.Format.GML();
	},

	debugBbox: function(bbox) {
		var me = this;
		var stmap = me.stmap;
		var olmap = stmap.map;
		if(me.debug) {
			console.log("BBOX");
			var layer = new OpenLayers.Layer.Vector();
			var bboxGeom = new OpenLayers.Bounds(bbox[0], bbox[1], bbox[2], bbox[3]).toGeometry();
			bboxGeom = bboxGeom.transform(new OpenLayers.Projection("EPSG:4326"), olmap.getProjectionObject());
			layer.addFeatures([new OpenLayers.Feature.Vector(bboxGeom)])
			stmap.map.addLayer(layer);
			layer.redraw();
		}
	},

	uniqueID: function(){
		 var randam = Math.floor(Math.random()*1000)
		 var date = new Date();
		 var time = date.getTime();
		 return randam + time.toString();
	},

	/**
	 * 地図に表示されている主題図レイヤを順番に検索する.
	 */
	getReferenceFeatureInfo : function(center, bbox, div, fromContents, pinned)
	{
		var me = this;
		me.center = center;
		me.bbox = bbox;
		if(typeof pinned=="undefined" || pinned==null) pinned=false;
		try {
			var popupDiv = div;
			if (!div) {
				popupDiv = document.createElement("div");
				popupDiv.className = "popup_div";
				popupDiv.id = "ref-popup-"+me.uniqueID();
			}

			// 検索対象のレイヤ情報を取得する
			var requests = me.requests = [];
			var ecommap = me.stmap.ecommaps[0];
			var referenceLayerInfos = ecommap.getReferenceLayerInfos().concat(ecommap.getExternalMapLayerInfos());
			for (var idx in referenceLayerInfos) {
				var referenceLayerInfo = referenceLayerInfos[idx];
				// 検索可能かチェックし、検索対象に追加
				if(referenceLayerInfo.alwaysNotSearch==false && referenceLayerInfo.searchable) {
					requests.push({
						layerInfo: referenceLayerInfo,
						center: center,
						bbox: bbox,
						popupDiv: popupDiv,
						fromContents: fromContents,
						popupOption: {
							map: me.stmap,
							olmap: me.stmap.map,
							center: center,
							div: popupDiv,
							items: [],
							toolbarData: {
								buttons: []
							},
							title: referenceLayerInfo.name,
							pinned: pinned
						}
					});
				}
			}

			// リストポップアップを表示
			me.showReferenceListPopup(requests, pinned);

			//<span class="ja">WMS毎に検索</span><span class="en">Search on each WMS</span>
			for(var idx in requests) {
				me.getReferenceFeatureInfoScope(requests[idx]);
			}

		} catch (e) { console.error(e); }
	},

	showReferenceListPopup: function(requests, pinned) {

		var me = this;
		var stmap = me.stmap;
		me.listPopup = {};

		// Ex.data.Store にそのままデータ登録すると、rawが保存されない
		// そのため、Modelを定義し、Modelインスタンスのrawに値を保存後
		// ModelインスタンスをStoreに追加する手順とする。
		Ext.define('SaigaiTask.Map.view.RefContentsPopup.Result', {
			extend: 'Ext.data.Model',
			fields: [{
				name: lang.__('Layer name'), type: 'String'
			}]
		});
		var store = Ext.create("Ext.data.ArrayStore",{
			model: 'SaigaiTask.Map.view.RefContentsPopup.Result'
		});
		// データの初回追加時にポップアップを表示
		store.addListener('add', function(view, record, item, index, e, eOpts) {
			if(grid.store.getTotalCount()==0) {
				if(me.popup==null) {
					// すべてのポップアップを閉じる
					if(stmap.popupManager!=null) {
						stmap.popupManager.closeAll();
					}
					me.showExtPopup({
						title: lang.__("External map feature list"),
						map: me.stmap,
						olmap: me.stmap.map,
						center: requests[0].center,
						panelWidth: grid.width,
						pinned: pinned,
						items: [grid]
					});
				}
			}
		});

		var grid = me.listPopup.grid = Ext.create('Ext.grid.Panel',{
			store: store,
			stateful: true,
			collapsible: false,
			multiSelect: false,
			header: false,
			width: 250,
//			closable: true,
			frame: false,
			stateId: 'stateGrid',
			columns: [{
				text: lang.__("Layer name"),
				dataIndex: lang.__("Layer name"),
				flex: 1
			}],
			viewConfig: {
				stripeRows: true,
				enableTextSelection: true
			}
		});
		// グリッド内のクリックイベントを定義
		grid.addListener('itemclick', function(view, record, item, index, e, eOpts) {
			// すべてのポップアップを閉じる
			if(stmap.popupManager!=null) {
				stmap.popupManager.closeAll();
			}

			// このポップアップを閉じる
			if(stmap.popupManager!=null) {
				stmap.popupManager.close(me.popup);
			}

			// ポップアップのツールバーに戻るボタンを追加
			var request = record.raw.request;
			var button = Ext.create("Ext.Button", {
				text: lang.__("Return to list<!--2-->"),
				scale : 'small',
				handler: function() {
					var pinned = me.popup.pinned;
					if(stmap.popupManager!=null) {
						stmap.popupManager.close(me.popup);
						me.popup = null;
					}
					me.getReferenceFeatureInfo(me.center, me.bbox, null, null, pinned);
					return false;
				}
			});
			request.popupOption.toolbarData.buttons.push(button);

			// ピン留めフラグ
			request.popupOption.pinned = me.popup.pinned;

			// レスポンスの種類に応じてポップアップを表示
			if(request.type=="gml") {
				// フィーチャ単位のポップアップ
				me.showRefGmlFeaturePopup(request, record.raw.feature);
				// レイヤ単位のポップアップ
				//me.showRefGmlPopup(request);
			}
			else if(request.type=="html") {
				me.showRefHtmlPopup(request);
			}
			else {
				alert("RefContentsPopup unknown request type: "+request.type);
			}
		});
	},

	/**
	 * レイヤ情報単位で検索する
	 * はじめにGMLでリクエスト、結果なしの場合は続けて HTMLでリクエスト
	 */
	getReferenceFeatureInfoScope : function(request)
	{
		var me = this;
		var self = this;
		var stmap = self.stmap;
		var ecommap = stmap.ecommaps[0];
		var layerIds = "";
		var featureIds = "";
		var layerInfo = request.layerInfo;
		// 認証が必要な場合に備えて取得
		var metadataIds = "";
		if(!layerInfo==false) {
			var visibleLayerIds = [];
			var visibleFeatureIds = [];
			var visibleMetadataIds = [];
			for(var idx in layerInfo.children) {
				var child = layerInfo.children[idx];
				if(child.visibility) {
					visibleLayerIds.push(child.layerId);
					visibleFeatureIds.push(child.featuretypeId);
					visibleMetadataIds.push(child.metadataid);
				}
			}
			layerIds = visibleLayerIds.join(",");
			featureIds = visibleFeatureIds.join(",");
			metadataIds = visibleMetadataIds.join(",");
		}
		if (layerIds && layerIds.length > 0) {
			//Reverse LayerId
			var url = layerInfo.wmsFeatureURL!=null ? layerInfo.wmsFeatureURL: layerInfo.wmsURL;
			url += this.getWmsGetFeatureInfoURL(layerInfo.layerId, featureIds, request.bbox, 4326, stmap.clickBuffer, stmap.clickBuffer, 5);
			request.type = "gml";
			request.xhr = jQuery.ajax({
				url: map.api.url.wfsProxyURL + encodeURIComponent(url) + "&metadataid=" + metadataIds,
				type: "GET",
				async: true,
				cache: false,
				headers: {
					"X-CSRF-Token": SaigaiTask.csrfToken
				},
				dataType: "text",
				success: function(data) {
					console.log(data);
					if (typeof data == "error") {
						console.warn("error!",args);
					} else {
						try {
						if (data.length > 0) {
							//for Firefox 4096 bytes limit
							if (data.normalize) data.normalize();
							/* <span class="ja">INFO_FORMAT=application/vnd.ogc.gml の場合はGMLをテーブルに変換</span><span class="en">In case of INFO_FORMAT=application/vnd.ogc.gml, convert to GML table </span> */
							var features = request.response = [];
							try {
								features = request.response = self.gmlFormat.read(data);
							} catch(e) {console.error(e);}
							//<span class="ja">featuresが空ならHTMLで再取得</span><span class="en">If features are blank, get HTML again</span>
							if (features.length == 0 || !features[0].fid) {
								//<span class="ja">フォーマット変更</span><span class="en">Update format</span>
								url = url.replace(/&INFO_FORMAT=.+?&/, "&INFO_FORMAT=text/html&");
								console.log(url);
								//self.getWmsGetFeatureInfoURL(groupId, self.getVisibleReferenceFeatureId(groupId), bbox, 4326, self.clickBuffer, self.clickBuffer, 5, 'text/html');
								request.type = "html";
								request.xhr = jQuery.ajax({
									url: map.api.url.wfsProxyURL + encodeURIComponent(url) + "&metadataid=" + metadataIds,
									type: "GET",
									async: true,
									cache: false,
									dataType: "text",
									success: function(data) {
										if (data) {
											//<span class="ja">文字列置換 GeoServerの形式に対応</span><span class="en">Support format of string replacement GeoServer</span>
											try {
											//<span class="ja">fidが表の一行目にあるので削除</span><span class="en">Because fid appears on the first line, delete it</span>
											data = data.replace(/(<tr[^>]*?>)[^<]*<t[d|h]>[^<]*<\/t[d|h]>/g, "$1");
											//<span class="ja">レイヤ名変換</span><span class="en">Convert layer name</span>
											layerIds = layerIds.split(',');
											for (var i=layerIds.length-1; i>=0; i--) {
												var layerInfo = ecommap.layerInfoStore[layerIds[i]];
												console.log(layerIds[i]);
												console.log(layerInfo);
												if (layerInfo && layerInfo.featuretypeId)
													data = data.replace(">"+layerInfo.featuretypeId.split(":")[1]+"<", ">"+SaigaiTask.Map.util.CommonUtil.escapeXml(layerInfo.name)+"<");
											}
											} catch (e) { console.error(e); }
											request.response = data;
											// この検索リクエストしかないのなら直接HTMLポップアップを表示する
											if(me.requests.length==1) {
												self.showRefHtmlPopup(request);
											}
											else {
												if(data=="<html></html>") {
													// 結果が空なら表示させない。
												}
												else {
													var raw = {};
													var raw = {
														request: request
													};
													raw[lang.__("Layer name")] = request.layerInfo.name;
													var result = SaigaiTask.Map.view.RefContentsPopup.Result.create(raw);
													result.raw = raw;
													me.listPopup.grid.store.add(result);
												}
											}
										}
									}
								});
							} else {
								// この検索リクエストしかないのかつ、地物１件なら直接GMLポップアップを表示する
								if(me.requests.length==1 && features.length==1) {
									self.showRefGmlPopup(request);
								}
								else {
									for(var idx in features) {
										var feature = features[idx];
										// Modelインスタンスを作成後、rawを保存
										var raw = {
											request: request,
											feature: feature // ポップアップ対象としてこのインデックス位置のfeatureを指定
										};
										raw[lang.__("Layer name")] = request.layerInfo.name;
										// フィーチャのfid="c10.1" からレイヤIDを取得して、レイヤ名を取得する
										try{
											if(feature.fid!=null) {
												var fidElems = feature.fid.split(".");
												if(fidElems.length==2) {
													var featureLayerId = fidElems[0];
													var featureLayerName = null;
													for(var idx in layerInfo.children) {
														var child = layerInfo.children[idx];
														if(child.featuretypeId!=null) {
															// namespace が付いていたら外して比較する
															// gServer の場合、child.featuretypeId=hazardmap:レイヤIDとなるが、
															// featureLayerIdはhazardmap:が付かない
															var childFeatureTypeId = child.featuretypeId;
															if(featureLayerId.indexOf(':')==-1 && childFeatureTypeId.indexOf(':')!=-1) {
																var elems = child.featuretypeId.split(':');
																childFeatureTypeId = elems[elems.length-1];
															}
															if(childFeatureTypeId==featureLayerId) {
																raw[lang.__("Layer name")] += "/"+child.name;
																break;
															}
														}
													}
												}
											}
										} catch(e) {
											// do nothing
										}
										var result = SaigaiTask.Map.view.RefContentsPopup.Result.create(raw);
										result.raw = raw;
										me.listPopup.grid.store.add(result);
									}
								}
							}
						}
						} catch (e) { console.error(e); }
					}
				}
			});
		}
	},
	/** <span class="ja">WMSのgetFeatureInfoリクエスト用のURLを返す</span><span class="en">Return URL for WMS's getFeatureInfo request</span>
	 * @param format <span class="ja">FORMATパラメータ 指定がなければGML形式(INFO_FORMAT=application/vnd.ogc.gml)</span><span class="en">FORMAT parameter    If not specified, GML format (INFO_FORMAT=application/vnd.ogc.gml)</span>
	 * @param bbox <span class="ja">検索範囲</span><span class="en">Search range</span>
	 * @param epsg <span class="ja">bboxのEPSGの数値</span><span class="en">Numeric value of bbox's EPSG</span> */
	getWmsGetFeatureInfoURL : function(groupId, layers, bbox, epsg, x, y, count, format)
	{
		var me = this;
		var stmap = me.stmap;
		var olmap = stmap.map;

		// 20px 20px の画像の、左上原点の(X,Y)=(10,10) つまり 画像の中心位置にある地物をもとめる
		// bbox は画像と同じサイズだと、点と線が検索にかかりにくいため
		// bbox は buffer*3 の大きさにする。
		var lonLength = bbox[2]-bbox[0];
		var latLength = bbox[3]-bbox[1];
		var bufferedBbox = [bbox[0]-lonLength, bbox[1]-latLength, bbox[2]+lonLength, bbox[3]+latLength];

		me.debugBbox(bufferedBbox);

		// 時間パラメータの付与
		var time = SaigaiTask.PageURL.getTime();
		if(!!time) {
			var iso8601Time = time.toISOString();
			// eコミマップ対応で、タイムゾーン分プラスする（getTimezonOffset が 負数-540 となるので実際には除算で足す）
			if(SaigaiTask.PageURL.CONFIG_SHIFT_TIMEZONE_OFFSET) {
				iso8601Time = new Date(time - time.getTimezoneOffset()*60*1000).toISOString();
			}
			time = iso8601Time;
		}
		else {
			time = null;
		}

		if (!format) format = "application/vnd.ogc.gml";
		var url = /*this.wfsProxyURL+"/"+groupId+"/redirect/wms_feature/?*/ "WIDTH="+x*2+"&HEIGHT="+y*2+"&LAYERS="+layers
		+"&STYLES=&SRS=epsg:"+epsg+"&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetFeatureInfo&EXCEPTIONS=application%2Fvnd.ogc.se_xml&BBOX="
		+(bufferedBbox.join(","))+"&X="+x+"&Y="+y+"&INFO_FORMAT="+format+"&QUERY_LAYERS="+layers+"&FEATURE_COUNT="+count+"&buffer=2";

		if(!!time) url += "&TIME="+time;

		return url;
	},
	/** <span class="ja">主題図ポップアップ</span><span class="en">Thematic map popup</span> */
	showRefGmlPopup : function(request)
	{
		var me = this;
		var features = request.response;
		try {

		if (features.length == 0) {
			features = null;
//			if (request.fromContents) {
//				var div = document.createElement("div");
//				div.innerHTML = lang.__('No thematic map info');
//				var linkDiv = this.getContentsLinkDiv(center, bbox);
//				this.showPopupWindow(center, div, linkDiv?linkDiv:document.createElement("br"), {});
//			}
			return;
		}

		if(features.length==1) {
			me.showRefGmlFeaturePopup(request, features[0]);
		}
		else {
			me.showRefGmlTablePopup(request, features);
		}

		features = null;

		} catch (e) {console.error(e);}
	},

	showRefGmlFeaturePopup : function(request, feature) {
		var me = this;
		var layerInfo = request.layerInfo;

		var ecommapURL = me.stmap.ecommaps[0].ecommapURL;

		// featureTypeName
		var featureType = feature.gml.featureType;
		var featureTypeName = featureType;
		for(var idx in layerInfo.children) {
			var child = layerInfo.children[idx];
			if(featureType==child.featuretypeId) {
				featureTypeName = child.name;
				break;
			}
		}

		// タイトル
		var title = null;
		title = featureTypeName+" ["+layerInfo.name+"]";

		// 添付ファイルのレイアウトを指定する
		// 縦型: vbox   横型: hbox
		var layout = "vbox";

		// 画像と属性を横並びにするHBox
		var hbox = {
			xtype: 'container',
			layout: layout,
			width: 0,
			items: []
		};
		var hboxContainerObj = Ext.create('Ext.container.Container', hbox);

		// 属性
		var attrs = [];
		for(var attrId in feature.attributes) {
			var attrValue = feature.attributes[attrId];
			var attr = {
				attrId: attrId,
				attrName: attrId,
				attrValue: attrValue
			}
			attrs.push(attr);
		}
		// 属性グリッドを表示
		var attrLayerInfo = null;
		// eコミからのGetFeatureInfoの場合
		if(feature.gml.featureNS=="http://map.ecom-plat.jp/map") {
			// レイヤの名称が同じ登録情報レイヤがあれば、属性グリッドはそのレイヤに従う
			var ecommap = me.stmap.ecommaps[0];
			for(var idx in ecommap.contentsLayerInfos) {
				var contentsLayerInfo = ecommap.contentsLayerInfos[idx];
				if(contentsLayerInfo.name==featureTypeName) {
					// 属性情報を初期化
					layerInfo.attrInfos = [];
					for(var attrIdx in contentsLayerInfo.attrInfos) {
						// 属性情報をコピーする
						var attrInfo = new SaigaiTask.Map.Layer.AttrInfo(contentsLayerInfo.attrInfos[attrIdx]);
						// 属性IDは属性名になっているため修正しておく
						attrInfo.attrId = attrInfo.name;
						layerInfo.attrInfos.push(attrInfo);
					}
					// 属性グリッドの引数に渡す
					attrLayerInfo = layerInfo;
				}
			}
		}
		var grid = me.createAttrGrid(attrs, attrLayerInfo);
		//request.popupOption.items.push(grid);
		// HBoxに配置する
		hboxContainerObj.add(grid);
		hbox.width += grid.width;

		// ファイル
		// eコミからのGetFeatureInfoの場合
		if(feature.gml.featureNS=="http://map.ecom-plat.jp/map") {
			if(hboxContainerObj.layout.type=="vbox") {
				// ファイルフォームパネル
				// 添付ファイルフォームを生成
				var contentsFileFormPanel = me.contentsFileFormPanel = new SaigaiTask.Map.view.ContentsFileFormPanel(me.stmap, null, {
					//mid: stmap.mapId,
					//layerId: layerId,
					//fid: fid,
					editable: false
				});
				
				// 画像データを登録
				for(var attrId in feature.attributes) {
					var attr = feature.attributes[attrId];
					//リンクと画像
					var match = attr.match(/^(https?:\/\/[^ ]+)$/i);
					if (match && match.length > 0) {
						var fileTitle = "";
						var fileURL = match[1];

						// サムネイル画像
						var url = fileURL;
						var ext = FalUtil.getFileExt(url);
						var thumbnail = url;
						// 画像以外のファイルの場合はアイコン表示
						if (! ext.match(/jpg|gif|png|jpeg|file/)) {
							thumbnail = ecommapURL+"/map/fileicons/"+ext+".png";
						}

						contentsFileFormPanel.store.add({
							title: fileTitle,
							url: fileURL,
							thumbnail: thumbnail
						});
					}
				}
				
				var imagesViewPanel = contentsFileFormPanel.formPanel;
				imagesViewPanel.setWidth(250);
				hboxContainerObj.add(imagesViewPanel);
			}
		}

		request.popupOption.items.push(hboxContainerObj);
		request.popupOption.panelWidth = hbox.width;

		// div 表示しない
		delete request.popupOption.div;

		me.showExtPopup(request.popupOption);
	},

	/**
	 * （複数地物対応）テーブル一覧ポップアップ
	 * あるレイヤで検索されたすべての地物をテーブル表示する際に使用する
	 */
	showRefGmlTablePopup : function(request, features) {
		var me = this;
			var headers = {};
			var featureDiv;
			var preTypeName = "";
			var table, tbody, tr, td;
			var resultDiv = document.createElement("div");
			resultDiv.className = 'popup_ref';
			///resultDiv.appendChild(document.createElement("br"));//<span class="ja">改行</span><span class="en">Break line</span>
			var noattr = true;

			//<span class="ja">ヘッダ取得</span><span class="en">Get header</span>
			for (var i=0; i<features.length; i++) {
				var feature = features[i];
				//<span class="ja">.以降削除</span><span class="en">Delete from the .</span>
				var typeName = feature.fid.replace(/\..+$/,"");
				var header;
				//<span class="ja">ヘッダ とりあえず項目が多いヘッダを利用 FIXME 属性IDでマージする</span><span class="en">Header   Tentively, use the header which contains many items   FIXME Merge at attribute ID</span>
				if (preTypeName != typeName) {
					header = [];
					preTypeName = typeName;
				}
				var attrLength = 0;
				for (var attrid in feature.attributes) attrLength++;
				if (header.length < attrLength) {
					var idx = 0;
					for (var attrid in feature.attributes) {
						if (attrid != "style") header[idx++] = attrid;  //<span class="ja">idがstyleの属性は非表示</span><span class="en">id hides the style attribute</span>
					}
					headers[typeName] = header;
				}
			}

			preTypeName = "";
			var layerName = null;
			for (var i=0; i<features.length; i++) {
				var typeName = features[i].fid.replace(/\..+$/,"");
				var h = headers[typeName];
				if (!h) h = [];
				if (preTypeName != typeName) {
					//<span class="ja">レイヤ名称</span><span class="en">Layer name</span>
					//<span class="ja">レイヤ名称変換</span><span class="en">Convert layer name</span>
					layerName = typeName;
					var groupLayerInfo = request.layerInfo;
					if(!groupLayerInfo==false) {
						for(var idx in groupLayerInfo.children) {
							var layerInfo = groupLayerInfo.children[idx];
							if (layerInfo && (layerInfo.featuretypeId.replace(/^.*?\:/, "") == typeName)) layerName = layerInfo.name;
						}
					}
					featureDiv = document.createElement("div")
					featureDiv.className = "featureTypeName";
					featureDiv.innerHTML = layerName+" " + lang.__("({0} items )", features.length);
					//console.log(groupId+":"+typeName);
					resultDiv.appendChild(featureDiv);
					preTypeName = typeName;
					table = document.createElement("table");
					table.className = "featureInfo";
					tbody = document.createElement("tbody");

					//<span class="ja">ヘッダ</span><span class="en">Header</span>
					tr = document.createElement("tr");
//					//<span class="ja">検索範囲追加アイコン列</span><span class="en">Icon array to insert search range</span>
//					if (this.callbacks['add_search_range']) {
//						tr.appendChild(document.createElement("th"));
//					}
					noattr = true;
					for (var j=0; j<h.length; j++) {
						td = document.createElement("th");
						td.innerHTML = h[j];
						td.style.minWidth = (Math.min(100,h[j].length*16))+"px";
						tr.appendChild(td);
						noattr = false;
					}
					if (!noattr) {
						tbody.appendChild(tr);
					}
				}
				tr = this._createRefPopupTr(layerName, features[i], h, noattr);
				tbody.appendChild(tr);
				table.appendChild(tbody);
				resultDiv.appendChild(table);
			}

//			var linkDiv;
//			if (fromContents) linkDiv = this.getContentsLinkDiv(center, bbox);
//			if (!linkDiv) linkDiv = document.createElement("br");

			var options = {minWidth:250, maxWidth: me.stmap.map.getSize().w*0.6, panIntoView:true, turned:true};
			var popupDiv = request.popupDiv;
			if (popupDiv) {
				//<span class="ja">追加</span><span class="en">Insert</span>
				popupDiv.appendChild(resultDiv);
				//this.showPopupWindow(center, popupDiv, linkDiv, options);
				//alert(popupDiv.innerHTML);
				if(document.getElementById(popupDiv.id)==null) {
					me.showExtPopup(request.popupOption);
				}
				else {
					var panelId = $("#"+popupDiv.id).parents(".x-panel")[0].id;
					var panel = Ext.getCmp(panelId);
					// 再描画
					panel.update($("<div>").append(popupDiv).html());
				}
//			} else {
//				this.showPopupWindow(center, resultDiv, linkDiv, options);
			}
	},

	/** <span class="ja">主題図ポップアップの行のTRを生成<br/> マーカー表示と検索範囲に追加のリンクとイベントを生成</span><span class="en">Create TR of line of thematic map popup <br/>Create event and links inserted to marker display and search range</span> */
	_createRefPopupTr : function(layerName, feature, header, noattr)
	{
		var tr = document.createElement("tr");
		var td;
//		//<span class="ja">検索範囲に追加アイコン</span><span class="en">Icon to insert search range</span>
//		var addSearchRangeCallback = this.callbacks['add_search_range'];
//		if (addSearchRangeCallback && feature.geometry) {
//			td = document.createElement("td");
//			var div = document.createElement("div");
//			div.className = "addSearchRangeIcon";
//			div.title = lang.__('Add Search Scope');
//			div.onclick = function(){
//				for (var i=0; i<addSearchRangeCallback.length; i++)
//					addSearchRangeCallback[i](null, null, feature.geometry.toString(), layerName);
//			};
//			td.appendChild(div);
//			tr.appendChild(td);
//		}

		for (var j=0; j<header.length; j++) {
			td = document.createElement("td");
			var attr = feature.attributes[header[j]];
			if (attr) {
				//リンクと画像
				var match = attr.match(/^(https?:\/\/[^ ]+)$/i);
				if (match && match.length > 0) {
					if (match[1].match(/\.(png|jpg|jpeg|gif)$/i)) {
						td.innerHTML = '<a href="'+match[1]+'" target="?blank"><img src="'+match[1]+'" class="popup_attr_image"/></a>';
					} else {
						td.innerHTML = this.replaceHref(SaigaiTask.Map.util.CommonUtil.escapeXml(attr)).replace(/\n+/gm,"<br/>");
					}
				} else {
					td.innerHTML = attr;
				}

				td.style.minWidth = (Math.min(100,attr.length*8))+"px";
			}
			tr.appendChild(td);
		}
		if (noattr) {
			td = document.createElement("td");
			td.innerHTML = lang.__('No Attribute');
			tr.appendChild(td);
		}
//		if (feature.geometry) {
//			var self = this;
//			tr.onclick = function(){
//				try {
//					//選択済み
//					var selected = this.className == "selected";
//					self.clearPopupMarkers();
//					//行の背景色を選択色にする
//					var tbody = this.parentNode;
//					for (var i=0; i<tbody.children.length; i++) {
//						tbody.children[i].className = "";
//					}
//					//選択済みでなkれば選択状態にする
//					if (!selected) {
//						var lonlats = [];
//						var points = feature.geometry.getVertices();
//						var step = Math.round(Math.max(1, points.length/30));//<span class="ja">点数制限</span><span class="en">Limit number of points</span>
//						for (var i=points.length-1; i>=0; i-=step) {
//							lonlats.push(new OpenLayers.LonLat(points[i].x, points[i].y));
//						}
//						self.showPopupMarkers(lonlats);
//						this.className = "selected";
//					}
//				} catch (e) { console.error(e); }
//			};
//		}
		return tr;
	},
	/** <span class="ja">HTML形式のデータをそのままポップアップ表示 </span><span class="en">Display popup with HTML data</span>*/
	showRefHtmlPopup : function(request)
	{
		var me = this;
		try {
		var html = request.response;
		var popupOption = request.popupOption;

		if (!html) return;

		if ($.trim(html.substring(html.indexOf('<body>')+6, html.indexOf('</body>'))).length == 0) return;

//		var fromContents = request.fromContents;
//		var linkDiv;
//		if (fromContents) linkDiv = this.getContentsLinkDiv(center, bbox);
//		if (!linkDiv) linkDiv = document.createElement("br");

		//HTML
		var div = document.createElement('div');
		div.className = "popup_ref";
		//<span class="ja">aタグはtargetとhrefのみにする</span><span class="en">Set only 'target' and 'href' for 'A' tag</span>
		if (html) {
			div.innerHTML = html.replace(/<\s*a\s+/ig, '<a target="_blank" ').replace(/onclick\s*=\s*"[^"]*"/ig,'');
		}
		popupOption.div.appendChild(div);

		//<span class="ja">ポップアップ表示</span><span class="en">Display popup</span>
		//var popup = this.showPopupWindow(center, popupDiv, linkDiv, {minWidth:250, maxWidth:this.map.getSize().w*0.6, panIntoView:true, turned:true});
		me.showExtPopup(popupOption);
		//<span class="ja">ポップアップにフィーチャの情報追加</span><span class="en">Insert feature information to popup</span>
		//popup.featureInfo = {typeName:layerId, fid:featureId};
		//popup.hide = function() { OpenLayers.Element.hide(me.div); };

		} catch (e) { console.error(e); }
	}
});
/* ======================================================================
    SaigaiTask/Map/view/MapPanel.js
   ====================================================================== */

/**
 * 
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.MapPanel= function() {
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.MapPanel.prototype = {
	map: null,
	panel: null,
	panelDivElem: null,
	initialize: function(map) {
		var me = this;
		me.map = map;
		var olmap = map.map;
		var mapDom = document.getElementById(map.div);
		var oldWidth = mapDom.clientWidth;
		var oldHeight = mapDom.clientHeight;
		mapDom.style.width = '100%';
		mapDom.style.height = '100%';
		var parent = mapDom.parentNode;
		// Extで要素のidを自動で付ける
		var panelDivElem = new Ext.Element(document.createElement('div'));
		parent.appendChild(panelDivElem.dom);
		var mapPanel = Ext.create("Ext.panel.Panel", {
			renderTo: panelDivElem.dom,
			region: 'center',
			layout: 'hbox',
			contentEl: map.div
		});
		mapPanel.on('resize', function() {
			olmap.updateSize();
		});
		// パネルを地図サイズに合わせる
		mapPanel.setWidth(oldWidth);
		mapPanel.setHeight(oldHeight);
		// パネルを保存
		this.panel = mapPanel;
		this.panelDivElem = panelDivElem;

		// マスク
		var loadMask = new Ext.LoadMask(mapPanel, {msg: lang.__("Now loading..")});
		map.events.on({
			"beforeloadecommap": function() {
				loadMask.show();
			},
			"loadendecommap": function(){
				loadMask.hide();
			}
		});

		// jQuery.Layout や ExtJSのパネル のリサイズ時に、地図上でうまくドラッグできないためドラッグ中だけマスクする。
		var resizeMask = new Ext.LoadMask(mapPanel, {useMsg: false});
		$(document).on("mousedown", ".x-resizable-handle, .ui-layout-resizer", function() {
			resizeMask.show();
		});
		$("body").on("mouseup", function() {
			if(!resizeMask.disabled)
				resizeMask.hide();
		});
	}
};
/* ======================================================================
    SaigaiTask/Map/view/PrintWindow.js
   ====================================================================== */

/**
 * @class SaigaiTask.Map.view.PrintWindow
 * 印刷ダイアログです.
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.PrintWindow = function() {
	this.initialize.apply(this, arguments);
};
SaigaiTask.Map.view.PrintWindow.prototype = {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	pdfControl: null,

	formPanel: null,

	progressbar: null,
	progressbarInitText: lang.__('Creating PDF file..'),

	exportButton: null,
	downloadButton: null,

	win: null,

	initialize: function(pdfControl) {
		var me = this;
		me.pdfControl = pdfControl;
		var stmap = me.stmap = pdfControl.stmap;

		// 印刷設定フォーム
		var formPanel = Ext.create('Ext.form.Panel', {
			frame : false,
			border: false,
			width : 340,
			bodyPadding : 5,

			fieldDefaults : {
				labelAlign : 'left',
				labelWidth : 90,
				anchor : '100%'
			},

			items : [{
				xtype : 'textfield',
				name : 'maptitle',
				fieldLabel : lang.__('Map title'),
				value : "",
				//allowBlank: false // 未入力だと地図タイトルが自動で挿入される（非表示にできない）
				allowBlank: true // 現在は未入力だと非表示にできるのでオプション入力に変更
			}, {
				xtype : 'textareafield',
				name : 'description',
				fieldLabel : lang.__('Explanation, annotations'),
				value : ""
			}, {
				xtype:  'combo',
				fieldLabel: lang.__("Paper size"),
				store: new Ext.data.SimpleStore({
					fields: ['value', 'display'],
					data: [
						["a0", "A0"],
						["a1", "A1"],
						["a2", "A2"],
						["a3", "A3"],
						["a4", "A4"],
						["a5", "A5"],
						["b0", "B0"],
						["b1", "B1"],
						["b2", "B2"],
						["b3", "B3"],
						["b4", "B4"],
						["b5", "B5"]
					],
					autoLoad: false
				}),
				displayField: 'display',
				valueField: 'value',
				name: "pagesize",
				value: "a4",
				editable: false, // 自由入力不可
				//selectOnFocus: true, // editable:false の combo は selectOnFocus:false であるべき
				validator: function(value) {
					value = this.getRawValue();
					var baseLayerInfo = stmap.map.baseLayer.layerInfo;
					/*
					if(typeof baseLayerInfo!="undefined" && baseLayerInfo.type==SaigaiTask.Map.Layer.Type.WEBTIS) {
						// 地理院タイルの場合はA3サイズまで
						var a3 = pdfControl.getPrintSize("a3");
						var selected = pdfControl.getPrintSize(value);
						if(selected.width <= a3.width && selected.height <= a3.height) {
							return true;
						}
						else return lang.__("Paper size of the Geographical Survey Institute tile is up to A3.");
					}
					*/
					return true;
				}
			}, {
				xtype : 'checkboxgroup',
				fieldLabel : lang.__('Paper orientation'),
				cls : 'x-check-group-alt',
				columns: 2,
				items : [{
					xtype : 'radiofield',
					name : 'rotate',
					inputValue : '1',
					boxLabel : lang.__('Horizontal'),
					checked: true
				}, {
					xtype : 'radiofield',
					name : 'rotate',
					inputValue : '0',
					boxLabel : lang.__('Vertical')
				}]
			}, {
				xtype : 'checkboxgroup',
				fieldLabel : lang.__('Base map'),
				cls : 'x-check-group-alt',
				columns: 2,
				items : [{
					xtype : 'radiofield',
					name : 'printBaselayer',
					inputValue : '1',
					boxLabel : lang.__('Existing'),
					checked: true
				}, {
					xtype : 'radiofield',
					name : 'printBaselayer',
					inputValue : '0',
					boxLabel : lang.__('None<!--2-->')
				}]
			}, {
				xtype:  'combo',
				fieldLabel: lang.__("UTM grid"),
				store: new Ext.data.SimpleStore({
					fields: ['value', 'display'],
					data: [
						["-1", lang.__("Hide")],
						["0", lang.__("0 digit: 100km")],
						["1", lang.__("Single digit: 10km")],
						["2", lang.__("The second digit: 1km")],
						["3", lang.__("The third digit: 100m")],
						["4", lang.__("The forth digit: 10m")]
						//"1m(5桁)"
					],
					autoLoad: false
				}),
				displayField: 'display',
				valueField: 'value',
				name: "mgrs",
				value: "-1",
				editable: false, // 自由入力不可
				//selectOnFocus: true // editable:false の combo は selectOnFocus:false であるべき
			}]
		});
		//formPanel.render('form-ct'); // for debug
		me.formPanel = formPanel;

		// プログレスバー
		var progressbar =  Ext.create('Ext.ProgressBar', {
			hidden: true,
			width : 340,
			text : me.progressbarInitText
		});
		me.progressbar = progressbar;

		// PDF出力ボタン
		var exportButton = Ext.create("Ext.Button", {
			text: lang.__("PDF output"),
			icon: stmap.icon.getURL("printIconURL"),
			handler: function() {
				// 電子国土の場合、用紙サイズをA4までに制限する
				if(formPanel.form.isValid()) {
					me.onexport();
				}
				else {
					Ext.MessageBox.show({
						title : lang.__('PDF output error'),
						msg : lang.__('Setting is incorrect.\n Check input content.'),
						buttons : Ext.MessageBox.OK,
						animateTarget : exportButton.getEl(),
						icon : Ext.MessageBox.ERROR
					});
				}
			}
		});
		me.exportButton = exportButton;

		// ダウンロードボタン
		var downloadButton = Ext.create("Ext.Button", {
			text: lang.__("Download"),
			href: SaigaiTask.contextPath+"/PdfServlet?download",
			hidden: true
		});
		me.downloadButton = downloadButton;

		// 印刷ダイアログ
		var win = Ext.create("Ext.Window", {
			closeAction: "hide",
			title: lang.__("Print dialog"),
			items: [formPanel, progressbar],
			fbar: [exportButton, downloadButton],
			listeners: {
				show: function(window, eOpts) {
					var value = ""+(stmap.controls.mgrsControl.layer.getVisibility() ? stmap.controls.mgrsControl.layerInfo.params.precision : "-1");
					var mgrsField = formPanel.form.findField("mgrs");
					mgrsField.setValue(value);
				}
			}
		});
		me.win = win;
	},

	getValues: function() {
		var me = this;
		return me.formPanel.getValues();
	},

	/**
	 * 印刷実行時の処理
	 */
	onexport: function() {
		var me = this;
		me.progressbar.show();
		me.downloadButton.hide();
		//me.formPanel.hide(); // 再表示するとレイアウトが崩れる？
		me.exportButton.hide();

		me.pdfControl.print();

		// パラメータを取得してからformを無効にする
		me.formPanel.disable();
	},

	/**
	 * 印刷成功時の処理
	 */
	onsuccess: function() {
		var me = this;
		me.progressbar.reset(true);
		me.progressbar.text = me.progressbarInitText;
		me.progressbar.hide();
		me.downloadButton.show();
		me.formPanel.enable();
		me.formPanel.show();
		me.exportButton.show();
	}
};
/* ======================================================================
    SaigaiTask/Map/control/SnapControl.js
   ====================================================================== */

/**
 * スナップレイヤを制御するクラスです.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.SnapControl = new OpenLayers.Class(OpenLayers.Control, {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * @type {OpenLayers.Control.Snapping}
	 */
	snap: null,

	wfsLayers: null,

	initialize: function(stmap) {
		var me = this;
		me.stmap = stmap;

		// eコミ情報がなければ初期化終了する
		if(stmap.ecommaps.length==0) return;
		var ecommap = stmap.ecommaps[0];
		var contentsLayerInfos = ecommap.contentsLayerInfos;
		var wfsLayers = [];
		var wfsLayer = null;

		// スナップ用スタイル
		// 塗りつぶしなしで線の色もなし
		var styleMap = new OpenLayers.StyleMap({
			fillOpacity: 0,
			strokeOpacity: 0
		});

		// スナップ対象レイヤがあればWFSレイヤとして追加する.
		for(var idx in contentsLayerInfos) {
			var layerInfo = contentsLayerInfos[idx];
			var mapInfo = ecommap.mapInfo;
			var isSnappableLayer = layerInfo.snappable;
			if(isSnappableLayer) {
				// WFSレイヤを作成
				wfsLayer = stmap.addContentsWFSLayer(mapInfo.communityId, mapInfo.mapId, layerInfo.layerId, null, {
					styleMap: styleMap
				});
				wfsLayers.push(wfsLayer);
			}
		}
		me.wfsLayers = wfsLayers;

		// configure the snapping agent
		var targets = [];
		for(var wfsLayersIdx in wfsLayers) {
			// スナップ対象レイヤに追加
			wfsLayer = wfsLayers[wfsLayersIdx];
			targets.push({
				layer: wfsLayer,
				tolerance: 10
			});
		}
		snap = me.snap = new OpenLayers.Control.Snapping({
			layer : null,
			targets: targets
		});
		stmap.addControl(snap);
		snap.activate();
	},

	/**
	 * スナップ編集用レイヤを設定する
	 * @param layer
	 */
	setLayer: function(layer) {
		var me = this;
		var snap = me.snap;
		if(snap!=null) {
			snap.setLayer(layer);
		}
	},

	/**
	 * 終了処理
	 */
	destroy: function() {
		var me = this;
		var stmap = me.stmap;
		var olmap = stmap.map;
		// スナップWFSレイヤをすべて取り除く
		var wfsLayers = me.wfsLayers;
		for(var idx in wfsLayers) {
			var wfsLayer = wfsLayers[idx];
			olmap.removeLayer(wfsLayer);
			wfsLayer.destroy();
		}
	}
});
/* ======================================================================
    SaigaiTask/Map/control/RakugakiControl.js
   ====================================================================== */

/**
 * メモレイヤを管理するクラスです.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.RakugakiControl = new OpenLayers.Class(OpenLayers.Control, {

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	mainpanel: null,

	kmlFormat: null,

	/**
	 * 編集移行用ツールバー
	 */
	tbar: null,

	/**
	 * 描画ツールバー
	 * @type {SaigaiTask.Map.view.DrawToolbar}
	 */
	drawToolbar: null,

	/**
	 * メモボタン
	 */
	rakugakiButton: null,

	/**
	 * ボタン
	 */
	buttons: null,
	
	/**
	 * メモ編集ウィンドウ
	 * @type {SaigaiTask.Map.view.RakugakiWindow}
	 */
	rakugakiWindow: null,

	initialize: function(stmap) {
		var me = this;
		me.stmap = stmap;

		// KMLフォーマットの初期化
		var wgs84 = new OpenLayers.Projection("EPSG:4326");
		var internalProjection = wgs84;
		if(!!stmap.epsg) internalProjection = new OpenLayers.Projection("EPSG:"+stmap.epsg);
		me.kmlFormat = new OpenLayers.Format.KMLStyle({
			extractStyles: true,
			internalProjection: internalProjection
		});

		// メモボタン
		me.rakugakiButton = Ext.create("Ext.Button", {
			text: lang.__("Memo"),
			icon: stmap.icon.getURL("mapEditIconURL"),
			tooltip: lang.__("Memo layer will be displayed or hided."),
			enableToggle: true,
			handler: function(button, evt) {
				if(button.pressed) {
					// メモを表示
					me.show();
				}
				else {
					if(me.hasUnsaveEdit()) {
						Ext.MessageBox.confirm(lang.__("Hide memo"), lang.__("There is editing memo.<br/>Are you sure to discard the changes?"), function(btn, text){
							if(btn=='yes') {
								// メモを非表示
								me.hide();
							}
							else {
								// キャンセルの場合はボタンを戻す
								button.toggle(true);
								return;
							}
						});
					}
					else {
						// メモを非表示
						me.hide();
					}
				}
			}
		});

		//
		// 編集移行用ボタン
		//
		me.buttons = {};
		var buttonHandler = function(type) {
			me.reload(function() {
				me.startEdit(type);
			});
		};
//		me.buttons.register = Ext.create("Ext.Button", {
//			text: "新規",
//			icon: stmap.icon.getURL("addIconURL"),
//			tooltip: "新しくメモします。",
//			enableToggle: true
//		});
		me.buttons.edit = Ext.create("Ext.Button", {
			text: lang.__("Edit"),
			icon: stmap.icon.getURL("editIconURL"),
			tooltip: lang.__("Edit memo"),
			enableToggle: true
		});
		var types = ["register", "edit"];
		for(var idx in types) {
			var type = types[idx];
			(function(type){
				var button = me.buttons[type];
				if(!!button) {
					button.on("click", function(button, status){
						if(button.pressed) {
							buttonHandler(type);
						}
						// ボタン押下を戻す場合
						else {
							// 編集中の場合は確認する
							if(me.hasUnsaveEdit()) {
								Ext.MessageBox.confirm(lang.__("Cancel memo {0}", button.text), lang.__("There is editing memo.<br/>Are you sure to discard the changes?"), function(btn, text){
									if(btn=='yes') {
										me.cancelEdit();
									}
									else {
										// キャンセルの場合はボタンを戻す
										button.toggle(true);
										return;
									}
								});
							}
							else {
								me.stopEdit();
							}
						}
					});
				}
			})(type);
		}
		me.tbar = Ext.create("Ext.toolbar.Toolbar", {
			hidden: true,
			items: [me.buttons.register, me.buttons.edit]
		});

		// SaigaiTask.Map.view.MainPanel の初期化時にメモボタンを追加する
		stmap.events.on({
			"epsgchanged": function(args) {
				// 地図の投影法が変わったら、KMLFormatも連動して変更する
				var internalProjection = wgs84;
				if(!!stmap.epsg) internalProjection = new OpenLayers.Projection("EPSG:"+stmap.epsg);
				me.kmlFormat.internalProjection = internalProjection;
			},
			"initmainpanel": function(args) {
				me.mainpanel = args.mainpanel;
				// メモボタンを追加
				me.mainpanel.headerToolbar.tbar.add("->", me.rakugakiButton, me.tbar);
			}
		});
	},

	/**
	 * メモの表示
	 */
	show: function() {
		var me = this;
		me.tbar.show();
		// 描画ツールバーがなければ初期化
		if(me.drawToolbar==null) {
			me.rakugakiWindow = new SaigaiTask.Map.view.RakugakiWindow({
				stmap: me.stmap,
				rakugakiControl: me
			});
			me.drawToolbar = me.rakugakiWindow.drawToolbar;
		}
		// レイヤ表示
		me.drawToolbar.drawLayer.layer.setVisibility(true);
		me.reload();
	},
	/**
	 * メモの非表示
	 */
	hide: function() {
		var me = this;
		// 編集中なら
		if(me.hasUnsaveEdit()) {
			// 編集を中止
			me.cancelEdit();
		}
		else {
			// もし、編集していれば終了する
			me.stopEdit();
		}
		// レイヤ非表示
		me.drawToolbar.drawLayer.layer.setVisibility(false);
		// 編集移行用ツールバーを非表示
		me.tbar.hide();
	},


	/**
	 * 編集の開始
	 */
	startEdit: function(type) {
		console.debug("startEdit: "+type);
		var me = this;
		var stmap = me.stmap;

		var onlockfail = function(msg) {
			alert(msg);
			me.buttons[type].toggle();
		}

		// lock
		stmap.api.rakugaki.lock()
		.fail(function() {
			onlockfail(lang.__("Failed to edit lock."));
		})
		.done(function(result) {
			// ロックフラグを取得
			var lock = false;
			if(!!result) lock = !!result.lock;

			// ロック失敗処理
			if(lock==false) {
				var lockInfo = result.lockInfo;
				var username ="";
				if(!!lockInfo.groupInfo && !!lockInfo.groupInfo.name) username="("+lockInfo.groupInfo.name+")";
				if(!!lockInfo.unitInfo && !!lockInfo.unitInfo.name) username="("+lockInfo.unitInfo.name+")";
				onlockfail(lang.__("User {0} is editing.", username));
				return;
			}

			// lockを定期的にリクエストし、ロック時間を延長する
			me.lockTimer = setInterval(function() {
				stmap.api.rakugaki.lock();
			}, 10*1000)

			// 制御ボタンの更新
			for(var btnType in me.buttons) {
				var btn = me.buttons[btnType];
				switch(btnType) {
				// 保存・中止ボタンは表示する
				case "save":
				case "cancel":
					btn.show();
					break;
				default:
					// 押してないボタンは無効
					if(type!=btnType) {
						btn.setDisabled(true);
					}
					break;
				}
			}

			// 描画
			var drawToolbar = me.drawToolbar;
			if(drawToolbar!=null) {
				// メモ編集ウィンドウを表示
				me.rakugakiWindow.showEditWindow();
				
				// 履歴の記録を開始
				drawToolbar.drawLayer.historyControl.clear();
				drawToolbar.drawLayer.historyControl.startHistory();
			}
		});

	},
	/**
	 * 編集の終了
	 */
	stopEdit: function() {
		var me = this;
		var stmap = me.stmap;

		// 編集ロックの延長リクエストを停止
		clearInterval(me.lockTimer);
		// ロック解除
		stmap.api.rakugaki.unlock();

		// 制御ボタンの更新
		for(var btnType in me.buttons) {
			var btn = me.buttons[btnType];
			switch(btnType) {
			// 保存・中止ボタンは表示する
			case "save":
			case "cancel":
				btn.hide();
				break;
			default:
				// すべてのボタンを表示
				btn.show();
				btn.setDisabled(false);
				btn.toggle(false);
				break;
			}
		}

		// 描画
		var drawToolbar = me.drawToolbar;
		if(drawToolbar!=null) {
			// 履歴の記録を停止
			drawToolbar.drawLayer.historyControl.clear();
			drawToolbar.drawLayer.historyControl.stopHistory();

			// メモ編集ウィンドウを非表示
			if(me.rakugakiWindow.window!=null) {
				me.rakugakiWindow.window.close();
			}

			// 地物の削除
			//drawToolbar.drawLayer.layer.removeAllFeatures();
			// 描画コントロール解除
			drawToolbar.drawLayer.deactivateCurrentDrawControl();
			stmap.setNavigationControlActivation(true);
		}
	},
	/**
	 * 編集途中かどうか
	 */
	hasUnsaveEdit: function() {
		try {
			return 0<this.drawToolbar.drawLayer.historyControl.stack.length;
		} catch(e) {
			return false;
		}
	},
	/**
	 * 編集のキャンセル
	 */
	cancelEdit: function() {
		var me = this;

		me.stopEdit();

		// 編集中止
		me.reload();
	},
	/**
	 * 編集の保存
	 */
	saveEdit: function(callback) {
		var me = this;
		var stmap = me.stmap;
		var kml = me.getEditKML();
		stmap.api.rakugaki.save(kml);
		me.stopEdit();
		if(typeof callback=="function") {
			callback();
		}
	},
	
	save: function() {
		var me = this;
		var stmap = me.stmap;
		// 編集していない場合
		if(!me.hasUnsaveEdit()) {
			Ext.MessageBox.alert(lang.__("Save memo"), lang.__("Nothing is changed."));
		}
		else {
			// KMLの取得
			Ext.MessageBox.confirm(lang.__("Save memo"), lang.__("Are you sure to save memo?"), function(btn, text){
				if(btn=='yes') {
					// 保存実行
					me.saveEdit(function() {
						Ext.MessageBox.alert(lang.__("Save memo"), lang.__("Saved."));
					});
				}
			});
		}
	},
	cancel: function() {
		var me = this;
		var stmap = me.stmap;
		// 編集中の場合は確認してから編集モードを終了する
		if(me.hasUnsaveEdit()) {
			Ext.MessageBox.confirm(lang.__("Cancel memo"), lang.__("There is memo that has not been saved.<br/>It will discard the changes and cancel editing memo. <br/> Are you sure?"), function(btn, text){
				if(btn=='yes') {
					me.cancelEdit();
				}
			});
		}
		else {
			me.cancelEdit();
		}
	},
	
	/**
	 * 編集KMLを取得する
	 */
	getEditKML: function() {
		var me = this;
		var drawToolbar = me.drawToolbar;
		var features = drawToolbar.drawLayer.layer.features;
		var kml = me.kmlFormat.write(features);
		return kml;
	},

	/**
	 * 再読み込み処理
	 */
	reload: function(callback) {
		var me = this;
		var stmap = me.stmap;
		var drawToolbar = me.drawToolbar;

		// KMLダウンロード
		stmap.api.rakugaki.download({
			async: true,
			success: function(kml) {
				drawToolbar.drawLayer.layer.removeAllFeatures();
				if(kml!=null) {
					var kmlString = new XMLSerializer().serializeToString(kml);
					var features = me.kmlFormat.read(kmlString);
					drawToolbar.drawLayer.layer.addFeatures(features);
				}
				if(typeof callback=="function") {
					callback();
				}
			},
			error: function() {
				ExtmMessageBox.alert(lang.__("Reload memo"), lang.__("Unable to get memo from server."));
			}
		});
	}
});
/* ======================================================================
    SaigaiTask/Map/view/SpatialSearchForm.js
   ====================================================================== */

/**
 * 登録情報の空間検索フォームのビューです.
 * @class SaigaiTask.Map.view.SpatialSearchForm
 * @requires SaigaiTask/Map/view.js
 */
SaigaiTask.Map.view.SpatialSearchForm = function(){};
SaigaiTask.Map.view.SpatialSearchForm.prototype = {

	/**
	 * デフォルトオプション
	 */
	defaultOptions: {
		limit: 0,
		offset: 0,
		searchButtonInfo: {
			featureInfo: null
		}
	},

	/**
	 * コンストラクタのオプションの保存用
	 */
	options: null,

	/**
	 * フォームパネル
	 * @type {Ext.form.Panel}
	 */
	form: null,

	/**
	 * 登録情報の空間検索フォームのパネルを取得します.
	 * @param {Object<String, *>} options
	 * @param {String} options.layerId
	 * @param {String} options.featureId
	 * @param {Object<String, *>} options.searchButtonInfo
	 * @param {String} options.searchButtonInfo.url
	 * @param {Number} options.searchButtonInfo.mid
	 * @param {Array<Object<String, *>>} options.searchButtonInfo.contentsLayers
	 * @return {Ext.form.Panel}
	 */
	get: function(options) {
		var me = this;

		// 未指定のオプションをデフォルトで上書きする
		me.options = options;
		Ext.applyIf(options, me.defaultOptions);

		var featureInfo = options.searchButtonInfo.featureInfo;

		// 検索対象のデータストア
		var targetsConfig = {
			fields: ['id', 'name'],
			data : []
		};

		// 検索対象のリストの定義と初期値の定義
		var defaultTargetValue = null;
		for(var contentsLayersIdx in options.searchButtonInfo.contentsLayers) {
			var contentsLayerInfo = options.searchButtonInfo.contentsLayers[contentsLayersIdx];
			targetsConfig.data.push({
				id: contentsLayerInfo.layerId,
				name: contentsLayerInfo.name
			});
			if(defaultTargetValue==null) {
				defaultTargetValue = contentsLayerInfo.layerId;
			}
		}
		var targets = Ext.create('Ext.data.Store', targetsConfig);

		// spatialType 空間検索の範囲検索の検索方法のデータストア
		var methods = Ext.create('Ext.data.Store', {
			fields: ['id', 'name'],
			data : [{
				"id": 1,
				"name": lang.__("Include")
			}, {
				"id": 2,
				"name": lang.__("Not include")
			}, {
				"id": 3,
				"name": lang.__("Fully include")
			}, {
				"id": 4,
				"name": lang.__("Not included completely")
			}, {
				"id": 5,
				"name": lang.__("Overlap")
			}, {
				"id": 6,
				"name": lang.__("Not overlap")
			}]
		});

		// 検索フォームの定義
		var form = null;
		form = Ext.create("Ext.form.Panel", {
			bodyPadding: 5,
			url: options.searchButtonInfo.url,
			buttonAlign: 'center',
			fieldDefaults: {
				labelAlign: 'left',
				labelWidth: 100,
				anchor: '100%'
			},
			items: [{
				xtype: 'fieldcontainer',
				fieldLabel: lang.__('Retrieval object'),
				labelWidth: 60,
				layout: 'hbox',
				items: [{
					xtype: "combo",
					editable: false,
					store: targets,
					queryMode: 'local',
					name: 'layer',
					displayField: 'name',
					valueField: 'id',
					value: defaultTargetValue,
					flex: 1
				}, {
					xtype: 'button',
					text: lang.__('Search'),
					margin: '0 0 0 10',
					padding: '2 10 2 10',
					iconCls: 'search-icon',
					handler: function(){
						form.doSearch();
					}
				}]
			}, {
				xtype: 'fieldset',
				title: lang.__('Search condition'),
				margin: 0,
				collapsible: true,
/*
				items: [{
					xtype: 'fieldset',
					title: '属性検索',
					//collapsible: true,
					padding: '0 10 0 10',
					defaults: {
						labelWidth: 80
					},
					items: [{
						xtype: "textfield",
						name: "keyword",
						fieldLabel: "キーワード"
					}]
				}, {
					xtype: 'fieldset',
					title: '空間検索',
*/
					//collapsible: true,
					margin: 0,
					padding: '0 10 0 10',
					defaults: {
						labelWidth: 120
					},
					items: [{
						// 名称を表示
						xtype: "displayfield",
						fieldLabel: lang.__("Search range"),
						value: featureInfo.attrs[0].attrValue
					}, {
						xtype: "textfield",
						hidden: true,
						name: "features",
						value: options.layerId+"."+options.featureId
					}, {
						xtype: "numberfield",
						name: "buffer",
						fieldLabel: lang.__("Search range buffer (m)"),
						value: 0
					}, {
						xtype: "combo",
						fieldLabel: lang.__("Search method"),
						editable: false,
						store: methods,
						queryMode: 'local',
						name: "spatialType",
						displayField: 'name',
						valueField: 'id',
						value: 1
//					}]
				}]
			}],

			/**
			 * 検索イベント(search)を起動する
			 */
			doSearch: function() {
				form.fireEvent('search');
			}
		});
		form.addEvents('search', 'aftersearch');

		me.form = form;
		return form;
	},

	/**
	 * 登録情報の空間検索フォームのウィンドウを表示します.
	 * @param {Object<String, *>} options
	 * @param {String} options.layerId
	 * @param {String} options.featureId
	 * @param {Object<String, *>} options.searchButtonInfo
	 * @param {String} options.searchButtonInfo.url
	 * @param {Number} options.searchButtonInfo.mid
	 * @param {Array<Object<String, *>>} options.searchButtonInfo.contentsLayers
	 */
	show: function(options) {
		var form = this.get(options);
		form.on('search', function(){
			form.submit({
				params: {
					mid: options.searchButtonInfo.mid
				}, success: function(form, action) {
					var result = action.result;
					var spatialSearch = new SaigaiTask.Map.control.SpatialSearch();
					var searchResult = spatialSearch.getSearchResult(result);
					var spatialSearchResult = new SaigaiTask.Map.view.SpatialSearchResult();
					spatialSearchResult.show(searchResult);
				}
			});
		});

		// 検索フォームのウィンドウを表示
		var win = Ext.create("Ext.window.Window", {
			extend: "Ext.window.Window",
			title: lang.__("Registration info Search"),
			width: 500,
			layout: "fit",
			items: [form]
		});
		win.show();
	},

	/**
	 * 追加パラメータ付きでパラメータマップを取得します.
	 * @return {Map.<String, *}
	 */
	getValues: function() {
		var me = this;
		var options = me.options;
		var values = me.form.getValues();
		values.mid = options.searchButtonInfo.mid;
		values.limit = options.limit;
		values.offset = options.offset;
		return values;
	}

};
/* ======================================================================
    SaigaiTask/Map/control/SelectFeatureControl.js
   ====================================================================== */

/**
 * 地物の複数選択コントロール.
 * 検索可能な登録情報レイヤが１つだけの場合、
 * 地図をSHIFTキーを押しながらクリックすると
 * 検索結果の地物を選択状態にします.
 * @requires SaigaiTask/Map/control.js
 */
SaigaiTask.Map.control.SelectFeatureControl = new OpenLayers.Class(OpenLayers.Control, {

	/**
	 * APIProperty: events {<OpenLayers.Events>}
	 *
	 * Supported map event types (in addition to those from
	 * <OpenLayers.Layer.events>): layoutloaded- レイアウト読み込み後にトリガーする.
	 */

	/**
	 * @type {SaigaiTask.Map}
	 */
	stmap: null,

	/**
	 * 選択状態の地物の強調表示レイヤ
	 * @type {OpenLayaers.Layer.Vector}
	 */
	layer: null,

	/**
	 * 選択対象のレイヤ情報
	 * @type {SaigaiTask.Map.LayerInfo}
	 */
	layerInfo: null,

	/**
	 * 選択済みフィーチャデータ
	 * @type {Array<SaigaiTask.Map.control.SelectFeatureControl.FeatureData>}
	 */
	selectedFeatureDatas: null,

	/**
	 * 選択リストウィンドウ
	 * @type {SaigaiTask.Map.view.SelectFeatureWindow}
	 */
	window: null,

	/**
	 * 一括変更クラス
	 * @type {SaigaiTask.Edit.Slimer}
	 */
	slimer: null,

	initialize: function(stmap, options) {
		var me = this;
		me.stmap = stmap;
		me.selectedFeatureDatas = [];

		// 表示状態をサーバに保存するイベントの初期化.
		var handler = function(evt){
			me.saveLayout();
		};
		stmap.events.on({
			"clicksearch": function(args, evt) {
				me.onClickSearch(args);
			}
		});

		// 強調表示レイヤの登録
		me.layer = new OpenLayers.Layer.Vector("Selected Feature Layer", {
			style: {
				strokeColor: "#FFFF00",
				strokeWidth: 2,
				//strokeDashstyle: 'dash',
				fillColor: "white",
				fillOpacity: 0.5,
				// 図の設定
				externalGraphic: stmap.icon.getURL("selectingIconURL"),
				graphicWidth: 19,
				graphicHeight: 32,
				graphicXOffset: -9,
				graphicYOffset: -32,
				graphicOpacity: 1
			}
		});
		stmap.addLayer(me.layer);

		OpenLayers.Control.prototype.initialize.apply(this, [options]);
	},

	/** 
	 * 地図画面クリックによる検索で
	 * 結果が得られた時のハンドラ
	 */
	onClickSearch: function(args) {
		var me = this;
		var stmap = me.stmap;

		var layerIds = args.layerIds;
		var center = args.center;
		var bbox = args.bbox;
		var option = args.option;
		var evt = !!option ? option.evt : null;
		var result = args.result;

		// 結果が 0 ならなにもしない
		if(result[0][0]==0) return;

		// 検索可能なレイヤが１つのみでそれが登録情報レイヤの場合、
		// SHIFTキーを押しながら地物をクリックしたら複数選択する
		if(layerIds.length==1) {
			var ecommap = stmap.ecommaps[0];
			var layerInfo = ecommap.layerInfoStore[layerIds[0]];
			if(layerInfo!=null && layerInfo.type==SaigaiTask.Map.Layer.Type.LOCAL) {
				if(!!evt && evt.shiftKey) {
					// 選択中のレイヤ情報として保持
					if(me.layerInfo==null) me.layerInfo = layerInfo;

					// ポップアップさせない
					args.executePopup = false;

					//console.debug("select features...");
					// 複数の場合でも最も近距離の地物を選択するため
					// 最初の地物を選択状態にする
					var layer = result[1][0][0];
					var fid = result[1][0][1];
					// 名称属性
					var nameAttr = result[1][0][3][0];
					var nameAttrId = nameAttr[0];
					// 名称属性の別名があれば設定する
					nameAttrInfo = me.layerInfo.getAttrInfo(nameAttrId);
					if(!!nameAttrInfo && !!nameAttrInfo.name) nameAttr[1] = nameAttrInfo.name;

					// 選択中かチェックする
					var selected = me.isSelected(layer, fid);

					// 選択中なら解除する
					if(selected) {
						var selectedFeatureData = me.get(layer, fid);
						me.deselect(selectedFeatureData);
					}
					// 未選択なら選択する
					else {
						stmap.api.getContent(stmap.mapId, layer, fid, center, bbox, function(data) {
							if(data==null) {
								return;
							}
							else if(typeof data=="error"){
								console.warn("error!",args);
							}
							else{
								// レスポンスが返ってくるのが遅いこともあるので
								// 選択にする前に、もう一度チェックする
								// 選択中かチェックする
								var selected = me.isSelected(layer, fid);

								// 選択中なら解除する
								if(selected) {
									me.deselect(layer, fid);
								}
								else {
									var featureData = new SaigaiTask.Map.control.SelectFeatureControl.FeatureData(data);
									featureData.nameAttr = nameAttr;
									me.select(featureData);
								}
							}
						});
					}
				}
			}
		}
	},

	/**
	 * 地物を選択状態にします.
	 * @param {SaigaiTask.Map.control.SelectFeatureControl.FeatureData} featureData 
	 */
	select: function(featureData) {
		var me = this;
		var stmap = me.stmap;

		// 選択済みフィーチャデータに追加
		me.selectedFeatureDatas.push(featureData);

		// 選択リストに追加
		if(me.window==null) {
			me.window = new SaigaiTask.Map.view.SelectFeatureWindow({
				stmap: stmap,
				featureData: featureData
			});

			// ウィンドウを閉じたら、選択状態をすべて解除する
			me.window.window.on("destroy", function() {
				me.clear();
			});

			// グリッドでアイテムを選択したら、ポップアップを表示する
			me.window.grid.on("select", function(grid, record, index, eOpts) {
				var data = record.getData();
				var layerId = data.layerId;
				var featureId = Number(data.featureId);
				var featureData = me.get(layerId, featureId);
				// 中心位置を地物に合わされないように、center引数を渡す
				var centroid = featureData.feature.geometry.getCentroid();
				var center = new OpenLayers.LonLat(centroid.x, centroid.y);
				center.transform(stmap.map.getProjectionObject(), new OpenLayers.Projection("EPSG:4326"));
				stmap.getContent(layerId, featureId, center);
			});

			// 解除ボタンハンドラを定義する
			me.window.removeActionColumnItem.handler = function(grid, rowIndex, colIndex) {
				var record = grid.getStore().getAt(rowIndex)
				var data = record.getData();
				var selectedFeatureData = me.get(data.layerId, data.featureId);
				if(selectedFeatureData!=null) {
					me.deselect(selectedFeatureData);
				}
			};

			// 一括変更ボタンハンドラを定義する
			me.window.slimerButton.setHandler(function() {
				me.onClickSlimerButton();
			});

			// 選択対象のレイヤの表示・非表示の連動
			var layerInfo = stmap.getLayerInfo(featureData.layerId);
			var layer = layerInfo.getLayer();
			layer.events.on({
				"refreshParams": function() {
					me.layer.display(layerInfo.visibility);
					if(layerInfo.visibility) {
						me.window.window.show();
					}
					else {
						me.window.window.hide();
					}
				}
			});

			me.window.show();
		}
		else {
			me.window.add(featureData);
		}

		// レイヤにフィーチャを追加
		try{
			var wkt = featureData.geom[0];
			var wktFormat = new OpenLayers.Format.WKT();
			var feature = wktFormat.read(wkt);
			feature.geometry.transform(new OpenLayers.Projection("EPSG:4326"), stmap.map.getProjectionObject());
			featureData.feature = feature;
			me.layer.addFeatures([feature]);
			me.layer.refresh();
			stmap.toFront(me.layer);
		}catch(e) {
			alert(lang.__("Unable to get position info."));
			console.error(lang.__("Failed to get position info :")+layerId+"."+fid);
			console.error(e);
			return;
		}
	},

	/**
	 * 一括変更ボタンが押されたら呼ばれる
	 */
	onClickSlimerButton: function() {
		var me = this;
		var stmap = me.stmap;
		if(!me.selectedFeatureDatas || me.selectedFeatureDatas.length==0) {
			alert(lang.__("Please select one or more."));
		}
		else {
			// カラム情報を生成
			var columns = [];
			for(var idx in me.layerInfo.attrInfos) {
				var attrInfo = me.layerInfo.attrInfos[idx];
				var editable = attrInfo.status==0;
				if(editable) {
					columns.push({
						name: attrInfo.name,
						field: attrInfo.attrId,
						dataType: attrInfo.dataTypeId,
						editable: editable,
						nullable: attrInfo.nullable
					});
				}
			}

			// 選択中のフィーチャだけ変更対象とする
			var targetIds = [];
			var values = {};
			for(var idx in me.selectedFeatureDatas) {
				// id を保持
				var selectedFeatureData = me.selectedFeatureDatas[idx];
				var attrs = selectedFeatureData.attrs;
				targetIds.push(selectedFeatureData.featureId);
				
				for(var attrsIdx in attrs) {
					var attr = attrs[attrsIdx];
					// 最初の地物の属性値を基準にする
					if(idx==0) {
						values[attr.attrId] = attr.attrValue;
					}
					else {
						// 属性値が異なった場合は空値にする
						if(values[attr.attrId]!=attr.attrValue) {
							values[attr.attrId] = null;
						}
					}
				}
			}

			// 一括変更を取得
			var slimer = me.slimer;
			if(!slimer) {
				// 一括変更情報がないか検索する
				var key = "gid";
				var slimers = SaigaiTask.Edit.slimers;
				for(var slimersIdx in slimers) {
					var _slimer = slimers[slimersIdx]
					if(me.layerInfo.layerId==_slimer.table) {
						slimer = me.slimer = _slimer;
						// ダイアログを閉じたときのイベント
						slimer.dialog.bind("slimersuccess", function(evt) {
							// 選択リストも閉じる(選択のクリア)
							//me.window.window.close();
							// 地図のリロード
							stmap.reload();
							// 一括変更対象をクリア
							slimer.targetIds = null;
						});
						break;
					}
				}
			}

			if(!slimer) {
				alert(lang.__("Bulk changes dialog is not found."));
			}
			else {
				// 一括変更対象を設定
				slimer.targetIds = targetIds;

				// 共通の値をフォームにセットする
				slimer.setValues(values);

				// ダイアログを表示
				slimer.dialog.dialog({
					title: lang.__("Bulk change"),
					minWidth: 400,
					maxHeight: 500,
					modal: true
				});
			}
		}
	},

	/**
	 * 地物の選択状態を解除します.
	 * @param {SaigaiTask.Map.control.SelectFeatureControl.FeatureData} selectedFeatureData 
	 */
	deselect: function(selectedFeatureData) {
		var me = this;

		// 選択済みフィーチャデータから削除する
		var index = jQuery.inArray(selectedFeatureData, me.selectedFeatureDatas);
		me.selectedFeatureDatas.splice(index, 1);

		// 選択リストから削除
		me.window.remove(selectedFeatureData);

		// レイヤからフィーチャを削除する
		var feature = selectedFeatureData.feature;
		if(feature!=null) {
			me.layer.removeFeatures([feature]);
			me.layer.refresh();
		}
	},

	/**
	 * すべての選択状態を解除します.
	 */
	clear: function() {
		var me = this;

		while(0<me.selectedFeatureDatas.length) {
			var selectedFeatureData = me.selectedFeatureDatas[0];
			me.deselect(selectedFeatureData);
		}

		me.layerInfo = null;
		me.window = null;
	},

	/**
	 * 選択済みフィーチャデータのインデックスを取得します.
	 * 存在しなければ -1 を返します.
	 */
	indexOf: function(layer, fid) {
		var me = this;
		for(var idx in me.selectedFeatureDatas) {
			var selectedFeatureData = me.selectedFeatureDatas[idx];
			if(selectedFeatureData.layerId==layer && selectedFeatureData.featureId==fid) {
				return idx;
			}
		}
		return -1;
	},

	/**
	 * レイヤID, フィーチャID を指定して地物を取得します.
	 */
	get: function(layer, fid) {
		var me = this;
		var index = me.indexOf(layer, fid);
		return index!=-1 ? me.selectedFeatureDatas[index] : null;
	},

	/**
	 * フィーチャが選択状態かどうかチェックします.
	 * @param {String} layer レイヤID
	 * @param {Number} fid フィーチャID
	 */
	isSelected: function(layer, fid) {
		return this.indexOf(layer, fid)!=-1 ? true : false;
	}
});


/**
 * 選択フィーチャデータ
 */
SaigaiTask.Map.control.SelectFeatureControl.FeatureData = new OpenLayers.Class({

	/**
	 * レイヤID
	 * @type {String}
	 */
	layerId: null,

	/**
	 * フィーチャID
	 * @type {Number}
	 */
	featureId: null,

	/**
	 * 属性データの配列
	 * @type {Array<Object>}
	 */
	attrs: null,

	geom: null,

	files: null,

	meta: null,

	/**
	 * ベクタフィーチャ
	 * @type {OpenLayers.Feature.Vector}
	 */
	feature: null,

	/**
	 * 生のデータ
	 * @type {Object}
	 */
	raw: null,

	initialize: function(data) {
		var me = this;

		// データをコピー
		OpenLayers.Util.extend(me, data);
	}
});
